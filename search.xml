<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Directory_Directory_Directory</title>
      <link href="/2022/07/24/Directory-Record-1/"/>
      <url>/2022/07/24/Directory-Record-1/</url>
      
        <content type="html"><![CDATA[<p><img src="/pictures/222.jpg" alt="You look like a hanhan too!"></p><h2 id="1-Tips"><a href="#1-Tips" class="headerlink" title="1.Tips"></a>1.Tips</h2><h3 id="1-答题的输入输出"><a href="#1-答题的输入输出" class="headerlink" title="  1.答题的输入输出  "></a><a href="https://zichuan365.github.io/2020/07/19/baseC/" target="_blank" rel="noopener"><font size=5>  1.答题的输入输出  </font></a></h3><p><font size=6>  </font></p><hr><h2 id="2-算法"><a href="#2-算法" class="headerlink" title="2.算法"></a>2.算法</h2><h3 id="2-1剑指Offer"><a href="#2-1剑指Offer" class="headerlink" title=" 2.1剑指Offer "></a><a href="https://zichuan365.github.io/2020/07/20/jianzhioffer/" target="_blank" rel="noopener"><font size=5> 2.1剑指Offer </font></a></h3><h3 id="2-2十大排序"><a href="#2-2十大排序" class="headerlink" title=" 2.2十大排序 "></a><a href="https://zichuan365.github.io/2020/07/29/LeetCode-%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F-1/" target="_blank" rel="noopener"><font size=5> 2.2十大排序 </font></a></h3><h3 id="2-3其他算法总结"><a href="#2-3其他算法总结" class="headerlink" title=" 2.3其他算法总结 "></a><a href="https://zichuan365.github.io/2020/07/30/LeetCode-%E5%85%B6%E4%BB%96%E7%AE%97%E6%B3%95/#%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88" target="_blank" rel="noopener"><font size=5> 2.3其他算法总结 </font></a></h3><ol><li>快慢指针</li><li>欧几里得算法</li><li>约瑟夫环问题</li><li>中心扩展法(回文串相关)</li><li>前缀和Sum_K</li><li>筛漏法（求素数个数）</li></ol><h3 id="2-4-滑动窗口问题"><a href="#2-4-滑动窗口问题" class="headerlink" title=" 2.4 滑动窗口问题 "></a><a href="https://zichuan365.github.io/2020/08/10/LeetCode-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E9%97%AE%E9%A2%98/" target="_blank" rel="noopener"><font size=5> 2.4 滑动窗口问题 </font></a></h3><h3 id="2-5-树、链表专题"><a href="#2-5-树、链表专题" class="headerlink" title=" 2.5 树、链表专题 "></a><a href="https://zichuan365.github.io/2020/08/08/LeetCode-%E6%A0%91%E3%80%81%E9%93%BE%E8%A1%A8%E4%B8%93%E9%A2%98/" target="_blank" rel="noopener"><font size=5> 2.5 树、链表专题 </font></a></h3><h3 id="2-6-回溯法"><a href="#2-6-回溯法" class="headerlink" title=" 2.6 回溯法 "></a><a href="https://zuizichuan.cn/2020/08/18/LeetCode-%E5%9B%9E%E6%BA%AF%E6%B3%95/"><font size=5> 2.6 回溯法 </font></a></h3><h3 id="2-7-STL容器"><a href="#2-7-STL容器" class="headerlink" title=" 2.7 STL容器 "></a><a href="https://zuizichuan.cn/2020/08/19/LeetCode-STL%E5%AE%B9%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8/"><font size=5> 2.7 STL容器 </font></a></h3><h3 id="2-8-bfs广度搜索——烂橘子"><a href="#2-8-bfs广度搜索——烂橘子" class="headerlink" title=" 2.8 bfs广度搜索——烂橘子 "></a><a href="https://zuizichuan.cn/2020/08/24/LeetCode-bfs%E5%B9%BF%E5%BA%A6%E6%90%9C%E7%B4%A2/"><font size=5> 2.8 bfs广度搜索——烂橘子 </font></a></h3><h3 id="2-9-dfs深度搜索——二叉树"><a href="#2-9-dfs深度搜索——二叉树" class="headerlink" title=" 2.9 dfs深度搜索——二叉树 "></a><a href="https://zuizichuan.cn/2020/08/24/LeetCode-dfs%E6%B7%B1%E5%BA%A6%E6%90%9C%E7%B4%A2/"><font size=5> 2.9 dfs深度搜索——二叉树 </font></a></h3><h3 id="2-10-动态规划"><a href="#2-10-动态规划" class="headerlink" title=" 2.10 动态规划 "></a><a href="https://zuizichuan.cn/2020/08/24/LeetCode-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"><font size=5> 2.10 动态规划 </font></a></h3><hr><h2 id="3-项目"><a href="#3-项目" class="headerlink" title="3.项目"></a>3.项目</h2><h3 id="3-1树莓派"><a href="#3-1树莓派" class="headerlink" title="  3.1树莓派"></a><a href="https://zichuan365.github.io/2020/07/24/%E9%A1%B9%E7%9B%AE-%E6%A0%91%E8%8E%93%E6%B4%BE/" target="_blank" rel="noopener"><font size=5>  3.1树莓派</font></a></h3><h3 id="3-2水下立体视觉"><a href="#3-2水下立体视觉" class="headerlink" title=" 3.2水下立体视觉 "></a><a href="https://zichuan365.github.io/2020/07/24/%E9%A1%B9%E7%9B%AE-%E6%B0%B4%E4%B8%8B%E7%AB%8B%E4%BD%93%E8%A7%86%E8%A7%89-1/" target="_blank" rel="noopener"><font size=5> 3.2水下立体视觉 </font></a></h3><hr><h2 id="4-基础"><a href="#4-基础" class="headerlink" title="4.基础"></a>4.基础</h2><h3 id="4-1C-基础"><a href="#4-1C-基础" class="headerlink" title=" 4.1C++基础 "></a><a href="https://zichuan365.github.io/2020/07/17/C-base/" target="_blank" rel="noopener"><font size=5> 4.1C++基础 </font></a></h3><h3 id="4-2操作系统"><a href="#4-2操作系统" class="headerlink" title=" 4.2操作系统 "></a><a href="https://zichuan365.github.io/2020/07/13/inter2/" target="_blank" rel="noopener"><font size=5> 4.2操作系统 </font></a></h3><h3 id="4-3计算机网络"><a href="#4-3计算机网络" class="headerlink" title=" 4.3计算机网络 "></a><a href="https://zichuan365.github.io/2020/07/14/714/" target="_blank" rel="noopener"><font size=5> 4.3计算机网络 </font></a></h3><h3 id="4-4数据库"><a href="#4-4数据库" class="headerlink" title=" 4.4数据库 "></a><a href="https://zichuan365.github.io/2020/07/24/C-%E6%95%B0%E6%8D%AE%E5%BA%93-1/" target="_blank" rel="noopener"><font size=5> 4.4数据库 </font></a></h3><h3 id="4-5数据结构"><a href="#4-5数据结构" class="headerlink" title=" 4.5数据结构 "></a><a href="https://zichuan365.github.io/2020/07/28/C-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-1/" target="_blank" rel="noopener"><font size=5> 4.5数据结构 </font></a></h3><hr><h2 id="5-Others"><a href="#5-Others" class="headerlink" title="5.Others"></a>5.Others</h2><h3 id="5-1面经"><a href="#5-1面经" class="headerlink" title=" 5.1面经"></a><a href="https://zichuan365.github.io/2020/08/06/yqz%E9%9D%A2%E7%BB%8F/" target="_blank" rel="noopener"><font size=5> 5.1面经</font></a></h3><h3 id="5-2博客格式模板"><a href="#5-2博客格式模板" class="headerlink" title=" 5.2博客格式模板"></a><a href="https://zichuan365.github.io/2020/07/10/hello-world/" target="_blank" rel="noopener"><font size=5> 5.2博客格式模板</font></a></h3><h3 id="5-3博客搭建"><a href="#5-3博客搭建" class="headerlink" title=" 5.3博客搭建"></a><a href="https://zuizichuan.cn/2020/08/11/Others-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/"><font size=5> 5.3博客搭建</font></a></h3><hr><h2 id="6-任务列表"><a href="#6-任务列表" class="headerlink" title="6.任务列表"></a>6.任务列表</h2><hr><table><thead><tr><th>任务</th><th>日期</th><th>注意事项</th><th>备注</th></tr></thead><tbody><tr><td>9.23 19:00-21:00</td><td>百度笔试</td><td>#</td><td>#</td></tr><tr><td>#</td><td>#</td><td>#</td><td>#</td></tr><tr><td>#</td><td>#</td><td>#</td><td>#</td></tr><tr><td>#</td><td>#</td><td>#</td><td>#</td></tr><tr><td>#</td><td>#</td><td>#</td><td>#</td></tr><tr><td>#</td><td>#</td><td>#</td><td>#</td></tr><tr><td>#</td><td>#</td><td>#</td><td>#</td></tr><tr><td>震坤行工业超市（上海）</td><td>已投递</td><td>#</td><td>#</td></tr><tr><td>中国平安</td><td>已投递</td><td>#</td><td>#</td></tr><tr><td>英伟达</td><td>已投递</td><td>#</td><td>#</td></tr><tr><td>上海商飞</td><td>已投递</td><td>#</td><td>#</td></tr><tr><td>航空工业上电所</td><td>已投递</td><td>测评未作</td><td>#</td></tr><tr><td>邮政苏州</td><td>已投递</td><td>#</td><td>#</td></tr><tr><td>德邦快递</td><td>已投递</td><td>#</td><td>#</td></tr><tr><td>经纬恒润</td><td>已投递</td><td>#</td><td>#</td></tr><tr><td>广联达</td><td>已投递</td><td>#</td><td>#</td></tr><tr><td>—–</td><td>—–</td><td>—–</td><td>—–</td></tr><tr><td>浪潮</td><td>笔试完成</td><td>#</td><td>#</td></tr><tr><td>奇安信</td><td>笔试完成</td><td>#</td><td>#</td></tr><tr><td>爱奇艺</td><td>笔试完成</td><td>#</td><td>#</td></tr><tr><td>华为</td><td>笔试完成</td><td>#</td><td>#</td></tr><tr><td>小红书</td><td>笔试完成</td><td>#</td><td>#</td></tr><tr><td>三一</td><td>offer</td><td>#</td><td>#</td></tr><tr><td>中兴</td><td>二面完成</td><td>#</td><td>#</td></tr><tr><td>中金所</td><td>一面完成</td><td>#</td><td>#</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Directory </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode / 笔试真题</title>
      <link href="/2020/09/02/LeetCode-%E7%AC%94%E8%AF%95%E7%9C%9F%E9%A2%98/"/>
      <url>/2020/09/02/LeetCode-%E7%AC%94%E8%AF%95%E7%9C%9F%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="1-拆迁分房问题"><a href="#1-拆迁分房问题" class="headerlink" title="1.拆迁分房问题"></a>1.拆迁分房问题</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;numeric&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> pp[] = &#123; <span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> *p = pp;</span><br><span class="line"><span class="keyword">int</span> plen = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;res(plen, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; plen; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (p[i] == p[i - <span class="number">1</span>])</span><br><span class="line">res[i] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (p[i] &gt; p[i - <span class="number">1</span>])</span><br><span class="line">res[i] = res[i<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(p[i] &lt; p[i - <span class="number">1</span>]&amp;&amp; res[i - <span class="number">1</span>]&gt;<span class="number">1</span>)</span><br><span class="line">res[i] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (p[i] &lt; p[i - <span class="number">1</span>] &amp;&amp; res[i - <span class="number">1</span>] == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (i - <span class="number">2</span> &lt; <span class="number">0</span>) &#123;</span><br><span class="line">res[i - <span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">res[i] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">res[i] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> tmp = i;</span><br><span class="line"><span class="keyword">while</span> (p[tmp - <span class="number">2</span>] &gt; p[tmp - <span class="number">1</span>] &amp;&amp; tmp - <span class="number">2</span> &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">res[tmp - <span class="number">2</span>]++;</span><br><span class="line">res[tmp - <span class="number">1</span>]++;</span><br><span class="line">tmp--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; plen; i++)</span><br><span class="line">sum += res[i];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; sum;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-打印矩阵问题"><a href="#2-打印矩阵问题" class="headerlink" title="2.打印矩阵问题"></a>2.打印矩阵问题</h3><ul><li><blockquote><p>小红书：打印矩阵米字型和十字型</p></blockquote></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span>&amp; P = N;</span><br><span class="line"><span class="keyword">int</span>&amp; I = P;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; N;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;arr(N, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(N, <span class="number">0</span>));</span><br><span class="line"><span class="keyword">if</span> (N % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">//偶数</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N / <span class="number">2</span>; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> one = i;</span><br><span class="line"><span class="keyword">int</span> two = N / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> three = N - i - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (i + j == N - <span class="number">1</span>)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (j &lt; one)</span><br><span class="line">arr[i][j] = <span class="number">7</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (j &gt; one &amp;&amp; j &lt; two)</span><br><span class="line">arr[i][j] = <span class="number">8</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (j &gt;= two &amp;&amp; j &lt;= three)</span><br><span class="line">arr[i][j] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (j &gt; three)</span><br><span class="line">arr[i][j] = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = N / <span class="number">2</span>; i &lt; N; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> three = i;</span><br><span class="line"><span class="keyword">int</span> two = N / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> one = N - i - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (i + j == N - <span class="number">1</span>)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> (j &lt; one)</span><br><span class="line">arr[i][j] = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (j &gt; one &amp;&amp; j &lt; two)</span><br><span class="line">arr[i][j] = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (j &gt;= two &amp;&amp; j &lt; three)</span><br><span class="line">arr[i][j] = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (j &gt; three)</span><br><span class="line">arr[i][j] = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//奇数</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N / <span class="number">2</span>; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> one = i;</span><br><span class="line"><span class="keyword">int</span> two = N / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> three = N - i - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (j &lt; one)</span><br><span class="line">arr[i][j] = <span class="number">7</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (j &gt; one &amp;&amp; j &lt; two)</span><br><span class="line">arr[i][j] = <span class="number">8</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (j &gt; two &amp;&amp; j &lt; three)</span><br><span class="line">arr[i][j] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (j &gt; three)</span><br><span class="line">arr[i][j] = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = N / <span class="number">2</span> + <span class="number">1</span>; i &lt; N; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> three = i;</span><br><span class="line"><span class="keyword">int</span> two = N / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> one = N - i - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (j &lt; one)</span><br><span class="line">arr[i][j] = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (j &gt; one &amp;&amp; j &lt; two)</span><br><span class="line">arr[i][j] = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (j &gt; two &amp;&amp; j &lt; three)</span><br><span class="line">arr[i][j] = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (j &gt; three)</span><br><span class="line">arr[i][j] = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; arr[i][j] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode / 动态规划</title>
      <link href="/2020/08/24/LeetCode-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
      <url>/2020/08/24/LeetCode-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
      
        <content type="html"><![CDATA[<h2 id="动态规划dp"><a href="#动态规划dp" class="headerlink" title="动态规划dp"></a>动态规划dp</h2><p><img src="/pictures/clipboard114.png" alt="img"></p><ul><li><blockquote><p>动态规划和贪心算法的区别</p></blockquote><ul><li>贪心算法：每一步最优解包含上一步最优解，上一步最优解不保留 <ul><li>从<strong>根节点</strong>到<strong>叶子节点</strong></li></ul></li><li>动态规划：穷举法，全局一定包含某个局部最优解，因此保留局部最优解。由局部最优解拼接而成的最优解。 <ul><li>从<strong>叶子节点</strong>到<strong>根节点</strong></li></ul></li></ul></li></ul><hr><ul><li><blockquote><p>关键是写出：</p></blockquote></li><li><p>1.状态定义</p></li><li><p>2.<strong>状态转移方程</strong>—dp方程，前后变量之间的相互关系</p></li><li><p>3.初始化</p></li><li><ol><li>0-1 true/false，背包是否装满问题—分割等和子级           <ul><li>01背包：当前的物品用或者不用</li></ul></li></ol></li><li><ol start="2"><li>完全背包问题，目标等于target—零钱问题                       -     <ul><li>完全背包：当前的物品可以用无限次</li></ul></li></ol></li></ul><hr><h3 id="416-分割等和子集——（和阿里面试那题很像）"><a href="#416-分割等和子集——（和阿里面试那题很像）" class="headerlink" title="416.分割等和子集——（和阿里面试那题很像）"></a>416.分割等和子集——（和阿里面试那题很像）</h3><ul><li><blockquote><p>给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p></blockquote></li><li><blockquote><p>输入: [1, 5, 11, 5]</p></blockquote></li><li><p>输出: true</p></li><li><p>解释: 数组可以分割成 [1, 5, 5] 和 [11].</p></li><li><blockquote><p>输入: [1, 2, 3, 5]</p></blockquote></li><li><p>输出: false</p></li><li><p>解释: 数组不能分割成两个元素和相等的子集.<br><img src="/pictures/clipboard120.png" alt="img"></p></li></ul><p><font size=6> dp[target] = dp[Sum/2]</font><br><font size=6> dp[target] = dp[Sum/2]</font><br><font size=6> dp[target] = dp[Sum/2]</font> </p><ul><li><blockquote><p>解：target = Sum / 2，所以dp方程的定义就是在于dp[0]到dp[Sum/2]</p></blockquote><ul><li>以一个数可以组成的sum，以两个数可以组成的sum</li></ul></li><li><strong>动态方程</strong>：以一个或两个，依次往上加能组成的情况<ul><li>dp[i][j] =  dp[i-1][j]——继承上</li><li>当j &gt;= nums[i],dp[i][j] =  dp[i-1][j]  <strong>||  dp[i-1][j-nums[i]]</strong></li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canPartition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line"><span class="comment">//求取target</span></span><br><span class="line"><span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">if</span> (n &lt;= <span class="number">1</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it : nums) &#123;</span><br><span class="line">sum += it;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (sum % <span class="number">2</span> == <span class="number">1</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">int</span> target = sum / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt;dp(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(target + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line"><span class="comment">//dp方程:1.当nums[i]&lt;j    dp[i][nums[i]] = true</span></span><br><span class="line"><span class="comment">//       2.              dp[i][j]=dp[i-1][j]           上满足,下肯定满足</span></span><br><span class="line"><span class="comment">//       3.              dp[i][j]=dp[i-1][j-nums[i]]   上满足,加上新num肯定满足</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//因为包含dp[i-1],所以需要多初始化一行,或者手动初始化第一行</span></span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= target; j++) &#123;</span><br><span class="line">dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line"><span class="keyword">if</span> (j &gt;= nums[i - <span class="number">1</span>])</span><br><span class="line">dp[i][j] = dp[i - <span class="number">1</span>][j - nums[i - <span class="number">1</span>]] || dp[i - <span class="number">1</span>][j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (dp[i][target])<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[n][target];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="阿里面试拓展"><a href="#阿里面试拓展" class="headerlink" title="阿里面试拓展"></a>阿里面试拓展</h3><ul><li><blockquote><p>给出一系列字符串，拼接成最长的字符串</p></blockquote></li><li><blockquote><p>输入：</p></blockquote></li><li><p>ab</p></li><li><p>abcd</p></li><li><p>cde</p></li><li><p>fgh</p></li><li><blockquote><p>输出：ab + cde + fgh</p></blockquote></li></ul><p><font size=6> dp[target] = dp[z]</font> </p><ul><li><blockquote><p>解：这里的target就是dp[0]、dp[a]、dp[b]，一直到26个字母的最后一个dp[z]</p></blockquote></li><li><p><strong>动态方程</strong>：以末尾字符排序，dp[index]表示以index结尾最长连续字符串</p><ul><li>index不存在，dp[index] =  dp[index-1]</li><li>index存在，dp[index] =  arr[index] + dp[arr[first]-1],比较大小留下最大的</li><li>arr遍历完成，return，数组弹出。<ul><li>用到的方法：vector合并：    </li><li>vecNew.insert(vecNew.end(),vec1.begin(),vec1.end()); </li><li>vecNew.insert(vecNew.end(),vec2.begin(),vec2.end());</li></ul></li></ul></li></ul><hr><h3 id="322-零钱兑换-完全背包-—最少Coins组成"><a href="#322-零钱兑换-完全背包-—最少Coins组成" class="headerlink" title="322.零钱兑换(完全背包)—最少Coins组成"></a>322.零钱兑换(完全背包)—最少Coins组成</h3><ul><li><blockquote><p>给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。</p></blockquote></li><li><blockquote><p>输入: coins = [1, 2, 5], amount = 11</p></blockquote></li><li><p>输出: 3 </p></li><li><p>解释: 11 = 5 + 5 + 1</p></li><li><blockquote><p>输入: coins = [2], amount = 3</p></blockquote></li><li><p>输出: -1</p></li></ul><p><img src="/pictures/clipboard121.png" alt="img"></p><p><font size=6> dp[target] = dp[amount]</font> </p><ul><li><blockquote><p>组成1块钱的最少硬币个数、组成2块钱的最少硬币个数</p></blockquote><ul><li>所以组成N块钱的最少硬币个数 = min(f（N-coins[0]）,f（N-coins[1]）,f（N-coins[2]）)<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; coins, <span class="keyword">int</span> amount)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (amount == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;dp(amount + <span class="number">1</span>, <span class="number">9999</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line">dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dp.<span class="built_in">size</span>(); i++)  <span class="comment">//i是钱总数</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; coins.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (i - coins[j] &lt; <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">dp[i] = <span class="built_in">min</span>(dp[i], dp[i - coins[j]] + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>   dp[amount] == <span class="number">9999</span> ? <span class="number">-1</span> : dp[amount];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><hr><h3 id="518-零钱兑换II-完全背包-—组合可能"><a href="#518-零钱兑换II-完全背包-—组合可能" class="headerlink" title="518.零钱兑换II(完全背包)—组合可能"></a>518.零钱兑换II(完全背包)—组合可能</h3><ul><li><blockquote><p>给定不同面额的硬币和一个总金额。写出函数来计算可以凑成总金额的硬币组合数。假设每一种面额的硬币有无限个。 </p></blockquote></li><li><blockquote><p>输入: amount = 5, coins = [1, 2, 5]</p></blockquote></li><li><p>输出: 4</p></li><li><p>解释: 有四种方式可以凑成总金额:</p></li><li><p>5 = 5</p></li><li><p>5 = 2+2+1</p></li><li><p>5 = 2+1+1+1</p></li><li><p>5 = 1+1+1+1+1</p></li></ul><p><img src="/pictures/clipboard122.png" alt="img"></p><ul><li><blockquote><p>dp方程：dp[ i ][ j ] =  dp[ i -1][ j ]   + dp[ i ][ j - coin[ i - 1 ] ]</p></blockquote><ul><li>1.不用新的硬币—————— 2.用新的硬币，去除一个至少用一次<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> amount, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; coins)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> N = coins.<span class="built_in">size</span>();</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">long</span>&gt; &gt; <span class="title">dp</span><span class="params">(N + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">long</span>&gt;(amount + <span class="number">1</span>, <span class="number">0</span>))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//一种硬币组成amount,两种硬币组成amount,三种硬币组成amount..........</span></span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= amount; ++j) &#123;</span><br><span class="line">dp[i][j] = dp[i - <span class="number">1</span>][j] + ((j &gt;= coins[i - <span class="number">1</span>]) ? dp[i][j - coins[i - <span class="number">1</span>]] : <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[N][amount];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><hr><h3 id="22-括号生成—列出所有括号的可能性"><a href="#22-括号生成—列出所有括号的可能性" class="headerlink" title="22.括号生成—列出所有括号的可能性"></a>22.括号生成—列出所有括号的可能性</h3><ul><li><blockquote><p>数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。</p></blockquote></li><li><blockquote><p>输入：n = 3</p></blockquote></li><li><p>输出：[</p></li><li><p>“((()))”,</p></li><li><p>“(()())”,</p></li><li><p>“(())()”,</p></li><li><p>“()(())”,</p></li><li><p>“()()()”</p></li><li><p>]</p></li><li><blockquote><p>解：</p></blockquote></li><li><p>（  左 ） 右</p></li><li><p>1组   </p><ul><li>（  ）</li></ul></li><li><p>2组      </p><ul><li>（  dp[0]  ） dp[1]</li><li>（ dp[1]   ） dp[0]</li></ul></li><li><p>3组  </p><ul><li>（ dp[0] ）  dp[2]</li><li>（dp[1] ）  dp[1]</li><li>（dp[2] ）  dp[0]</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> &#123; <span class="string">""</span> &#125;;</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">1</span>)<span class="keyword">return</span> &#123; <span class="string">"()"</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt;dp(n + <span class="number">1</span>);</span><br><span class="line">dp[<span class="number">0</span>] = &#123; <span class="string">""</span> &#125;;</span><br><span class="line">dp[<span class="number">1</span>] = &#123; <span class="string">"()"</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">string</span> p : dp[j])</span><br><span class="line">&#123;     <span class="comment">//左和右的不同组合，添加到vector中去，使用vector添加</span></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">string</span> q : dp[i - j - <span class="number">1</span>])</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">string</span> str = <span class="string">"("</span> + p + <span class="string">")"</span> + q;</span><br><span class="line">dp[i].push_back(str);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="121-买股票最佳时机"><a href="#121-买股票最佳时机" class="headerlink" title="121.买股票最佳时机"></a>121.买股票最佳时机</h3><ul><li><blockquote><p>记录之前的最小价格即可</p></blockquote></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h3 id="300-最长上升序列-类似阿里面试题"><a href="#300-最长上升序列-类似阿里面试题" class="headerlink" title="300.最长上升序列(类似阿里面试题)"></a>300.最长上升序列(类似阿里面试题)</h3><ul><li><blockquote><p>数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合</p></blockquote></li><li><blockquote><p>两种思路</p></blockquote><ul><li>dp方程O（n^2）</li><li>元素替换O（n*logN）<ul><li>创建数组，每次进来一个元素都替换一个元素。</li></ul></li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;dp(nums.<span class="built_in">size</span>(), <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (nums[i] &gt; nums[j]) &#123;</span><br><span class="line">dp[i] = <span class="built_in">max</span>(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">res = <span class="built_in">max</span>(res, dp[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="945-括号生成—列出所有括号的可能性"><a href="#945-括号生成—列出所有括号的可能性" class="headerlink" title="945.括号生成—列出所有括号的可能性"></a>945.括号生成—列出所有括号的可能性</h3><ul><li><blockquote><p>给定整数数组 A，每次 move 操作将会选择任意 A[i]，并将其递增 1。</p></blockquote></li><li><p>返回使 A 中的每个值都是唯一的最少操作次数。</p></li><li><blockquote><p>输入：[1,2,2]</p></blockquote></li><li><p>输出：1</p></li><li><p>解释：经过一次 move 操作，数组将变为 [1, 2, 3]。</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minIncrementForUnique</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (A.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">sort(A.<span class="built_in">begin</span>(), A.<span class="built_in">end</span>());</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; A.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (A[i] &lt;= A[i - <span class="number">1</span>]) &#123;</span><br><span class="line"><span class="keyword">int</span> temp = A[i];</span><br><span class="line">A[i] = A[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">res = res + A[i] - temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="面试17-16按摩师-198-打家劫舍（类似斐波那契数列）"><a href="#面试17-16按摩师-198-打家劫舍（类似斐波那契数列）" class="headerlink" title="面试17.16按摩师 / 198. 打家劫舍（类似斐波那契数列）"></a>面试17.16按摩师 / 198. 打家劫舍（类似斐波那契数列）</h3><ul><li><blockquote><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p></blockquote></li><li><p>给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</p></li><li><blockquote><p>输入：[1,2,3,1]</p></blockquote></li><li><p>输出：4</p></li><li><p>解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。<br>   偷窃到的最高金额 = 1 + 3 = 4 。</p></li><li><blockquote><p>输入：[2,7,9,3,1]</p></blockquote></li><li><p>输出：12</p></li><li><p>解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。偷窃到的最高金额 = 2 + 9 + 1 = 12 。</p></li></ul><ul><li><blockquote><p>解：就是不能连续偷窃</p></blockquote><ul><li>dp[i] = max(dp[i - 1], dp[i - 2] + nums[i - 1]);</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">if</span> (len == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (len == <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;dp(len + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">dp[<span class="number">1</span>] = nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= len; i++) &#123;</span><br><span class="line">dp[i] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>], dp[i - <span class="number">2</span>] + nums[i - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">max</span>(dp[len], dp[len - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="72-编辑距离"><a href="#72-编辑距离" class="headerlink" title="72.编辑距离"></a>72.编辑距离</h3><ul><li><blockquote><p>给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。</p></blockquote></li><li><p>你可以对一个单词进行如下三种操作：</p></li><li><p>1.插入一个字符</p></li><li><p>2.删除一个字符</p></li><li><p>3.替换一个字符</p></li><li><blockquote><p>输入：word1 = “horse”, word2 = “ros”</p></blockquote></li><li><p>输出：3</p></li><li><ul><li>解释：</li></ul></li><li><p>horse -&gt; rorse (将 ‘h’ 替换为 ‘r’)</p></li><li><p>rorse -&gt; rose (删除 ‘r’)</p></li><li><p>rose -&gt; ros (删除 ‘e’)</p></li><li><blockquote><p>dp方程：</p></blockquote><ul><li>int temp1 = dp[i-1][j] + 1;</li><li>int temp2 = dp[i][j-1] + 1;</li><li>int temp3 = dp[i-1][j-1];</li><li>if(word1[i-1]!= word2[j-1])<ul><li>temp3++;</li></ul></li><li>dp[i][j] = min(temp1,min(temp2,temp3));  </li></ul></li></ul><p><img src="/pictures/clipboard123.png" alt="img">    </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(<span class="built_in">string</span> word1, <span class="built_in">string</span> word2)</span> </span>&#123;</span><br><span class="line"><span class="comment">//word1转换为word2</span></span><br><span class="line"><span class="keyword">int</span> len1 = word1.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">int</span> len2 = word2.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (len1*len2 == <span class="number">0</span>)<span class="keyword">return</span> <span class="built_in">max</span>(len1, len2);</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;dp(len1 + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(len2 + <span class="number">1</span>));<span class="comment">//都要+1  dp[0][0]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len1 + <span class="number">1</span>; i++) &#123;</span><br><span class="line">dp[i][<span class="number">0</span>] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len2 + <span class="number">1</span>; i++) &#123;</span><br><span class="line">dp[<span class="number">0</span>][i] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len1 + <span class="number">1</span>; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; len2 + <span class="number">1</span>; j++) &#123;</span><br><span class="line"><span class="keyword">int</span> temp1 = dp[i - <span class="number">1</span>][j] + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> temp2 = dp[i][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> temp3 = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">if</span> (word1[i - <span class="number">1</span>] != word2[j - <span class="number">1</span>])</span><br><span class="line">temp3++;</span><br><span class="line">dp[i][j] = <span class="built_in">min</span>(temp1, <span class="built_in">min</span>(temp2, temp3));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[len1][len2];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="1143-最长公共子串"><a href="#1143-最长公共子串" class="headerlink" title="1143.最长公共子串"></a>1143.最长公共子串</h3><ul><li><blockquote><p>给定两个字符串 text1 和 text2，返回这两个字符串的最长公共子序列的长度。</p></blockquote></li><li><p>一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</p></li><li><p>例如，”ace” 是 “abcde” 的子序列，但 “aec” 不是 “abcde” 的子序列。两个字符串的「公共子序列」是这两个字符串所共同拥有的子序列。</p></li><li><p>若这两个字符串没有公共子序列，则返回 0。</p></li><li><blockquote><p>输入：text1 = “abcde”, text2 = “ace” </p></blockquote></li><li><p>输出：3  </p></li><li><p>解释：最长公共子序列是 “ace”，它的长度为 3。</p></li><li><blockquote><p>输入：text1 = “abc”, text2 = “abc”</p></blockquote></li><li><p>输出：3</p></li><li><p>解释：最长公共子序列是 “abc”，它的长度为 3。</p></li></ul><p><img src="/pictures/clipboard124.png" alt="img"> </p><ul><li><blockquote><p>dp方程</p></blockquote></li><li>if（text1[ i-1 ]=text2[ j-1]）<ul><li>dp[ i ][ j ] = dp[i-1 ][ j-1 ] +1;</li></ul></li><li>else <ul><li>dp[ i ][ j ] = max(dp[i-1 ][ j ],dp[i ][ j-1 ];)</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(<span class="built_in">string</span> text1, <span class="built_in">string</span> text2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> m = text1.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">int</span> n = text2.<span class="built_in">size</span>();</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;dp(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m + <span class="number">1</span>; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n + <span class="number">1</span>; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (text1[i - <span class="number">1</span>] == text2[j - <span class="number">1</span>])</span><br><span class="line">dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">dp[i][j] = <span class="built_in">max</span>(dp[i][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[m][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="718-最长重复子数组-类似1143"><a href="#718-最长重复子数组-类似1143" class="headerlink" title="718.最长重复子数组(类似1143)"></a>718.最长重复子数组(类似1143)</h3><ul><li><blockquote><p>给两个整数数组 A 和 B ，返回两个数组中公共的、长度最长的子数组的长度。</p></blockquote></li><li><blockquote><p>输入：</p></blockquote></li><li><p>A: [1,2,3,2,1]</p></li><li><p>B: [3,2,1,4,7]</p></li><li><p>输出：3</p></li><li><p>解释：</p></li><li><p>长度最长的公共子数组是 [3, 2, 1] 。<br><img src="/pictures/clipboard125.png" alt="img"> </p></li><li><blockquote><p>dp方程：</p></blockquote><ul><li>if (A[i] == B[j])<ul><li>dp[i][j] = dp[i - 1][j - 1] + 1;</li></ul></li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findLength</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; B)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> len1 = A.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">int</span> len2 = B.<span class="built_in">size</span>();</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;dp(len1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(len2, <span class="number">0</span>));</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len1; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (A[i] == B[<span class="number">0</span>])</span><br><span class="line">dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len2; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (B[i] == A[<span class="number">0</span>])</span><br><span class="line">dp[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len1; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; len2; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (A[i] == B[j])</span><br><span class="line">dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">res = <span class="built_in">max</span>(res, dp[i][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="53-最大子序和"><a href="#53-最大子序和" class="headerlink" title="53.最大子序和"></a>53.最大子序和</h3><ul><li><blockquote><p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p></blockquote></li><li><blockquote><p>输入: [-2,1,-3,4,-1,2,1,-5,4]</p></blockquote></li><li><p>输出: 6</p></li><li><p>解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</p></li><li><blockquote><p>简单DP，遇负反转。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> res = nums[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it : nums) &#123;</span><br><span class="line"><span class="keyword">if</span> (sum &gt; <span class="number">0</span>)</span><br><span class="line">sum += it;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">sum = it;</span><br><span class="line">&#125;</span><br><span class="line">res = <span class="built_in">max</span>(sum, res);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line"><span class="comment">// int res = nums[0];</span></span><br><span class="line"><span class="comment">// int len = nums.size();</span></span><br><span class="line"><span class="comment">// vector&lt;int&gt;dp(len+1,0);</span></span><br><span class="line"><span class="comment">// for(int i = 1;i&lt;len+1;i++)&#123;</span></span><br><span class="line"><span class="comment">//     dp[i]=max(dp[i-1]+nums[i-1],nums[i-1]);</span></span><br><span class="line"><span class="comment">//     res = max(res,dp[i]);</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// return res;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="983-最低票价"><a href="#983-最低票价" class="headerlink" title="983.最低票价"></a>983.最低票价</h3><ul><li><blockquote><p>在一个火车旅行很受欢迎的国度，你提前一年计划了一些火车旅行。在接下来的一年里，你要旅行的日子将以一个名为 days 的数组给出。每一项是一个从 1 到 365 的整数。</p></blockquote></li><li><p>火车票有三种不同的销售方式：</p></li><li><p>一张为期一天的通行证售价为 costs[0] 美元；</p></li><li><p>一张为期七天的通行证售价为 costs[1] 美元；</p></li><li><p>一张为期三十天的通行证售价为 costs[2] 美元。</p></li><li><p>通行证允许数天无限制的旅行。 例如，如果我们在第 2 天获得一张为期 7 天的通行证，那么我们可以连着旅行 7 天：第 2 天、第 3 天、第 4 天、第 5 天、第 6 天、第 7 天和第 8 天。</p></li><li><p>返回你想要完成在给定的列表 days 中列出的每一天的旅行所需要的最低消费。</p></li><li><blockquote><p>输入：days = [1,4,6,7,8,20], costs = [2,7,15]</p></blockquote></li><li><p>输出：11</p></li><li><p>解释： </p></li><li><p>例如，这里有一种购买通行证的方法，可以让你完成你的旅行计划：</p></li><li><p>在第 1 天，你花了 costs[0] = $2 买了一张为期 1 天的通行证，它将在第 1 天生- 效。</p></li><li><p>在第 3 天，你花了 costs[1] = $7 买了一张为期 7 天的通行证，它将在第 3, 4, …, 9 天生效。</p></li><li><p>在第 20 天，你花了 costs[0] = $2 买了一张为期 1 天的通行证，它将在第 20 天生效。</p></li><li><p>你总共花了 $11，并完成了你计划的每一天旅行。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mincostTickets</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; days, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; costs)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> len = days.back();</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//max(&#123;a,b,c&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;dp(len + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="comment">//记录需要出行日期</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; days.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">dp[days[i]] = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; i++) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (dp[i] == <span class="number">0</span>)<span class="comment">//当天不需要出行</span></span><br><span class="line">dp[i] = dp[i - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">else</span> &#123;       <span class="comment">//当天需要出行</span></span><br><span class="line">a = dp[i - <span class="number">1</span>] + costs[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">if</span> (i - <span class="number">7</span> &gt;= <span class="number">0</span>)</span><br><span class="line">b = dp[i - <span class="number">7</span>] + costs[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">b = costs[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (i - <span class="number">30</span> &gt;= <span class="number">0</span>)</span><br><span class="line">c = dp[i - <span class="number">30</span>] + costs[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">c = costs[<span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line">dp[i] = <span class="built_in">min</span>(&#123; a,b,c &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[len];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="63-不同路径"><a href="#63-不同路径" class="headerlink" title="63.不同路径"></a>63.不同路径</h3><ul><li><blockquote><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</p></blockquote></li><li><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p></li><li><p>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</p></li><li><blockquote><p>dp方程：</p></blockquote><ul><li>if (i == 0 &amp;&amp; j == 0) dp[i][j] = 1;</li><li>else if (i == 0) dp[i][j] = dp[i][j - 1];</li><li>else if (j == 0) dp[i][j] = dp[i - 1][j];</li><li>else dp[i][j] = dp[i - 1][j] + dp[i][j - 1];</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; obstacleGrid)</span> </span>&#123;</span><br><span class="line"><span class="comment">//dp[i][j] = dp[i-1][j] + dp[i][j-1]</span></span><br><span class="line"><span class="keyword">int</span> lenX = obstacleGrid.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">int</span> lenY = obstacleGrid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;dp(lenX, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(lenY, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lenX; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; lenY; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (obstacleGrid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">dp[i][j] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>) dp[i][j] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">0</span>) dp[i][j] = dp[i][j - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (j == <span class="number">0</span>) dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line"><span class="keyword">else</span> dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[lenX - <span class="number">1</span>][lenY - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
          <category> 动态规划 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode / dfs深度搜索_树</title>
      <link href="/2020/08/24/LeetCode-dfs%E6%B7%B1%E5%BA%A6%E6%90%9C%E7%B4%A2/"/>
      <url>/2020/08/24/LeetCode-dfs%E6%B7%B1%E5%BA%A6%E6%90%9C%E7%B4%A2/</url>
      
        <content type="html"><![CDATA[<h2 id="dfs深度搜索"><a href="#dfs深度搜索" class="headerlink" title="dfs深度搜索"></a>dfs深度搜索</h2><p><font size=6> 找到递归关系</font><br><font size=6> 找到递归关系</font><br><font size=6> 找到递归关系</font> </p><hr><h3 id="695-岛屿最大面积"><a href="#695-岛屿最大面积" class="headerlink" title="695.岛屿最大面积"></a>695.岛屿最大面积</h3><ul><li><blockquote><p>给定一个包含了一些 0 和 1 的非空二维数组 grid 。</p></blockquote></li><li>一个 岛屿 是由一些相邻的 1 (代表土地) 构成的组合，这里的「相邻」要求两个 1 必须在水平或者竖直方向上相邻。你可以假设 grid 的四个边缘都被 0（代表水）包围着。<br><img src="/pictures/clipboard119.png" alt="img"></li></ul><ul><li><blockquote><p>解题：因为一片联通区域一次性肯定是算出来了,就可以将访问过的路径置为0</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfsArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp;grid, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line"><span class="comment">//界定范围，当是岛屿时，继续向外拓展，标定为0已经搜寻</span></span><br><span class="line"><span class="comment">//所以是引用操作，一片连着的岛屿只会搜寻一次整片区域</span></span><br><span class="line"><span class="keyword">if</span> (i &lt; <span class="number">0</span> || i == grid.<span class="built_in">size</span>() || j &lt; <span class="number">0</span> || j == grid[<span class="number">0</span>].<span class="built_in">size</span>() || grid[i][j] == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">grid[i][j] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> xDir[<span class="number">4</span>] = &#123; <span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> yDir[<span class="number">4</span>] = &#123; <span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span> &#125;;</span><br><span class="line"><span class="comment">//这此区域已经为陆地满足初始为1</span></span><br><span class="line"><span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> m = <span class="number">0</span>; m != <span class="number">4</span>; m++) &#123;</span><br><span class="line">res += dfsArea(grid, i + xDir[m], j + yDir[m]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxAreaOfIsland</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (grid.<span class="built_in">size</span>() == <span class="number">0</span> || grid[<span class="number">0</span>].<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> area = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> maxArea = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != grid.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j != n; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">area = dfsArea(grid, i, j);</span><br><span class="line">maxArea = <span class="built_in">max</span>(maxArea, area);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> maxArea;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="剑指Offer12-矩阵中的路径-和695区别-需要回溯"><a href="#剑指Offer12-矩阵中的路径-和695区别-需要回溯" class="headerlink" title="剑指Offer12.矩阵中的路径(和695区别:需要回溯)"></a>剑指Offer12.矩阵中的路径(和695区别:需要回溯)</h3><ul><li><blockquote><p>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。例如，在下面的3×4的矩阵中包含一条字符串“bfce”的路径（路径中的字母用加粗标出）</p></blockquote></li></ul><ul><li>[[“a”,<strong>“b”</strong>,”c”,”e”],</li><li>[“s”,<strong>“f”</strong>,<strong>“c”</strong>,”s”],</li><li>[“a”,”d”,<strong>“e”</strong>,”e”]]</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">exist</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="built_in">string</span> <span class="keyword">word</span>)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> len = board.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">if</span> (len == <span class="number">0</span> || board[<span class="number">0</span>].<span class="built_in">size</span>() == <span class="number">0</span> || <span class="keyword">word</span>.empty())<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt;vis(len, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(board[<span class="number">0</span>].<span class="built_in">size</span>(), <span class="literal">true</span>));<span class="comment">//辅助数组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; board[<span class="number">0</span>].<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (board[i][j] == <span class="keyword">word</span>[<span class="number">0</span>]) &#123;</span><br><span class="line"><span class="keyword">if</span> (dfs(i, j, board, <span class="keyword">word</span>, <span class="number">0</span>, vis))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="built_in">string</span> <span class="keyword">word</span>, <span class="keyword">int</span> length, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt;&amp;vis)</span> </span>&#123;</span><br><span class="line"><span class="comment">//回溯的返回条件</span></span><br><span class="line"><span class="keyword">if</span> (length == <span class="keyword">word</span>.<span class="built_in">size</span>())</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="comment">//排除不合法</span></span><br><span class="line"><span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= board.<span class="built_in">size</span>() || j &lt; <span class="number">0</span> || j &gt;= board[<span class="number">0</span>].<span class="built_in">size</span>()</span><br><span class="line">|| vis[i][j] == <span class="literal">false</span> || board[i][j] != <span class="keyword">word</span>[length])</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//做出选择</span></span><br><span class="line">vis[i][j] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//回溯函数，有真则真</span></span><br><span class="line"><span class="keyword">bool</span> res = dfs(i, j + <span class="number">1</span>, board, <span class="keyword">word</span>, length + <span class="number">1</span>, vis) || dfs(i, j - <span class="number">1</span>, board, <span class="keyword">word</span>, length + <span class="number">1</span>, vis) ||</span><br><span class="line">dfs(i + <span class="number">1</span>, j, board, <span class="keyword">word</span>, length + <span class="number">1</span>, vis) || dfs(i - <span class="number">1</span>, j, board, <span class="keyword">word</span>, length + <span class="number">1</span>, vis);</span><br><span class="line"></span><br><span class="line"><span class="comment">//撤销选择</span></span><br><span class="line">vis[i][j] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="0828笔试题—目标路径到目的路径"><a href="#0828笔试题—目标路径到目的路径" class="headerlink" title="0828笔试题—目标路径到目的路径"></a>0828笔试题—目标路径到目的路径</h3><p><img src="/pictures/clipboard137.png" alt="img"></p><ul><li><blockquote><p>从（x1，y1）到（X，Y）路径上的最小和，同时遇到-1为路障，无法通过</p></blockquote></li><li><blockquote><p>输入：</p></blockquote></li><li><p>3,4</p></li><li><p>1,3,4,-1</p></li><li><p>-1,11,6,8</p></li><li><p>-1,2,1,9</p></li><li><p>起始：(0，0)——&gt;（2，1）</p></li><li><blockquote><p>输出：16</p></blockquote></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> res = INT_MAX;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;arr, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt;&amp;vis,<span class="keyword">int</span> sum,<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> m,<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (x &lt; <span class="number">0</span> || x &gt;= arr.<span class="built_in">size</span>() || y &lt; <span class="number">0</span> || y &gt;= arr[<span class="number">0</span>].<span class="built_in">size</span>() || vis[x][y] == <span class="literal">false</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (x == m &amp;&amp; y == n) &#123;</span><br><span class="line">res = <span class="built_in">min</span>(res, sum);</span><br><span class="line"><span class="comment">//cout &lt;&lt; res &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">vis[x][y] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> XX[<span class="number">4</span>] = &#123; <span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> YY[<span class="number">4</span>] = &#123; <span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">dfs(arr, vis, sum + arr[x][y], x + XX[i], y + YY[i], m, n);</span><br><span class="line"></span><br><span class="line">vis[x][y] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
          <category> 深度搜索——二叉树 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode / bfs广度搜索_烂橘子</title>
      <link href="/2020/08/24/LeetCode-bfs%E5%B9%BF%E5%BA%A6%E6%90%9C%E7%B4%A2/"/>
      <url>/2020/08/24/LeetCode-bfs%E5%B9%BF%E5%BA%A6%E6%90%9C%E7%B4%A2/</url>
      
        <content type="html"><![CDATA[<h2 id="bfs广度搜索"><a href="#bfs广度搜索" class="headerlink" title="bfs广度搜索"></a>bfs广度搜索</h2><ul><li><blockquote><p>关键在于寻找种子</p></blockquote></li><li><blockquote><p>auto [tempX , tempY] = arr.front();</p></blockquote></li></ul><p><font size=6> 找到污染源</font><br><font size=6> 找到污染源</font><br><font size=6> 找到污染源</font> </p><hr><h3 id="542-01-矩阵"><a href="#542-01-矩阵" class="headerlink" title="542. 01 矩阵"></a>542. 01 矩阵</h3><ul><li><blockquote><p>给定一个由 0 和 1 组成的矩阵，找出每个元素到最近的 0 的距离。</p></blockquote></li><li><p>两个相邻元素间的距离为 1 。</p></li><li><blockquote><p>输入：</p></blockquote></li><li><p>0 0 0</p></li><li><p>0 1 0</p></li><li><p>0 0 0</p></li><li><blockquote><p>输出：</p></blockquote></li><li><p>0 0 0</p></li><li><p>0 1 0</p></li><li><p>0 0 0</p></li><li><blockquote><p>输入：</p></blockquote></li><li><p>0 0 0</p></li><li><p>0 1 0</p></li><li><p>1 1 1</p></li><li><blockquote><p>输出：</p></blockquote></li><li><p>0 0 0</p></li><li><p>0 1 0</p></li><li><p>1 2 1</p></li><li><blockquote><p>解题：找到污染源，用0去污染1，距离就是污染源的值+1。queue所以能保证，路径先是1.然后是2。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">updateMatrix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> m = matrix.<span class="built_in">size</span>(), n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">res</span><span class="params">(m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n, <span class="number">0</span>))</span></span>;</span><br><span class="line"><span class="built_in">queue</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line"><span class="comment">//找到为0的种子，入队列，0相当于烂橘子，污染源</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line"><span class="keyword">if</span> (matrix[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">q.push(make_pair(i, j));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dx[<span class="number">4</span>] = &#123; <span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> dy[<span class="number">4</span>] = &#123; <span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line"><span class="keyword">auto</span>[i, j] = q.front();</span><br><span class="line">q.pop();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> d = <span class="number">0</span>; d &lt; <span class="number">4</span>; ++d) &#123;</span><br><span class="line"><span class="keyword">int</span> ni = i + dx[d];</span><br><span class="line"><span class="keyword">int</span> nj = j + dy[d];</span><br><span class="line"><span class="keyword">if</span> (ni &gt;= <span class="number">0</span> &amp;&amp; ni &lt; m &amp;&amp; nj &gt;= <span class="number">0</span> &amp;&amp; nj &lt; n &amp;&amp; matrix[ni][nj] == <span class="number">1</span>) </span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//这部最重要</span></span><br><span class="line">res[ni][nj] = res[i][j] + <span class="number">1</span>;</span><br><span class="line">q.push(make_pair(ni, nj));</span><br><span class="line">matrix[ni][nj] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="994-烂橘子"><a href="#994-烂橘子" class="headerlink" title="994.烂橘子"></a>994.烂橘子</h3><ul><li><blockquote><p>在给定的网格中，每个单元格可以有以下三个值之一：</p></blockquote></li><li>值 0 代表空单元格；</li><li>值 1 代表新鲜橘子；</li><li>值 2 代表腐烂的橘子。<ul><li>每分钟，任何与腐烂的橘子（在 4 个正方向上）相邻的新鲜橘子都会腐烂。</li><li>返回直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回-1。<br><img src="/pictures/clipboard116.png" alt="img"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">orangesRotting</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = grid.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">int</span> m = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">int</span> orangeNum = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">queue</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;Q;</span><br><span class="line"><span class="comment">//将污染源入队列</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line"><span class="keyword">if</span> (grid[i][j] == <span class="number">2</span>)</span><br><span class="line">Q.push(make_pair(i, j));</span><br><span class="line"><span class="keyword">int</span> xDir[<span class="number">4</span>] = &#123; <span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> yDir[<span class="number">4</span>] = &#123; <span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">while</span> (!Q.empty()) &#123;</span><br><span class="line"><span class="keyword">int</span> num = Q.<span class="built_in">size</span>();     <span class="comment">//现存的烂橘子数量</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">auto</span>[X, Y] = Q.front();</span><br><span class="line">Q.pop();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++) &#123;</span><br><span class="line"><span class="keyword">int</span> x1 = X + xDir[j];</span><br><span class="line"><span class="keyword">int</span> y1 = Y + yDir[j];</span><br><span class="line"><span class="keyword">if</span> (x1 &gt;= <span class="number">0</span> &amp;&amp; x1 &lt; n &amp;&amp; y1 &gt;= <span class="number">0</span> &amp;&amp; y1 &lt; m &amp;&amp; grid[x1][y1] == <span class="number">1</span>) &#123;</span><br><span class="line">grid[x1][y1] = <span class="number">2</span>;</span><br><span class="line">Q.push(make_pair(x1, y1));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//污染第一次循环结束，当还有橘子在队列说明此次又有好橘子被污染</span></span><br><span class="line"><span class="keyword">if</span> (!Q.empty())</span><br><span class="line">orangeNum++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line"><span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">return</span> orangeNum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><hr><h3 id="1162-地图分析"><a href="#1162-地图分析" class="headerlink" title="1162.地图分析"></a>1162.地图分析</h3><ul><li><blockquote><p>你现在手里有一份大小为 N x N 的 网格 grid，上面的每个 单元格 都用 0 和 1 标记好了。其中 0 代表海洋，1 代表陆地，请你找出一个海洋单元格，这个海洋单元格到离它最近的陆地单元格的距离是最大的。</p></blockquote></li><li><p>我们这里说的距离是「曼哈顿距离」（ Manhattan Distance）：(x0, y0) 和 (x1, y1) 这两个单元格之间的距离是 |x0 - x1| + |y0 - y1| 。</p></li><li><p>如果网格上只有陆地或者海洋，请返回 -1。<br><img src="/pictures/clipboard117.png" alt="img"></p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxDistance</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">queue</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;que;</span><br><span class="line"><span class="comment">//找到种子，以陆地去找海洋</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; grid.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; grid.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>)</span><br><span class="line">que.push(make_pair(i, j));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (que.empty() || que.<span class="built_in">size</span>() == grid.<span class="built_in">size</span>()*grid[<span class="number">0</span>].<span class="built_in">size</span>())<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dirX[<span class="number">4</span>] = &#123; <span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> dirY[<span class="number">4</span>] = &#123; <span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">while</span> (!que.empty()) &#123;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">size</span> = que.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="built_in">size</span>; j++) &#123;</span><br><span class="line"><span class="keyword">auto</span>[tempX, tempY] = que.front();</span><br><span class="line">que.pop();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> X = tempX + dirX[i];</span><br><span class="line"><span class="keyword">int</span> Y = tempY + dirY[i];</span><br><span class="line"><span class="keyword">if</span> (X &gt;= <span class="number">0</span> &amp;&amp; X &lt; grid.<span class="built_in">size</span>() &amp;&amp; Y &gt;= <span class="number">0</span> &amp;&amp; Y &lt; grid[<span class="number">0</span>].<span class="built_in">size</span>() &amp;&amp; grid[X][Y] == <span class="number">0</span>) &#123;</span><br><span class="line">grid[X][Y] = <span class="number">1</span>;</span><br><span class="line">que.push(make_pair(X, Y));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!que.empty())</span><br><span class="line">res++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="17-电话号码的字母组合"><a href="#17-电话号码的字母组合" class="headerlink" title="17. 电话号码的字母组合"></a>17. 电话号码的字母组合</h3><ul><li><blockquote><p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。</p></blockquote></li><li>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。<br><img src="/pictures/clipboard118.png" alt="img"></li></ul><ul><li><blockquote><p>解：</p></blockquote></li><li>1.利用map将数字和string对应关系确定。</li><li>2.然后利用queue依次遍历<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">letterCombinations</span><span class="params">(<span class="built_in">string</span> digits)</span> </span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="built_in">string</span>&gt; m = &#123; &#123;<span class="string">'2'</span>,<span class="string">"abc"</span> &#125;,&#123;<span class="string">'3'</span>,<span class="string">"def"</span>&#125;,&#123;<span class="string">'4'</span>,<span class="string">"ghi"</span>&#125;,&#123;<span class="string">'5'</span>,<span class="string">"jkl"</span>&#125;,&#123;<span class="string">'6'</span>,<span class="string">"mno"</span>&#125;,</span><br><span class="line">&#123;<span class="string">'7'</span>,<span class="string">"pqrs"</span>&#125;,&#123;<span class="string">'8'</span>,<span class="string">"tuv"</span>&#125;,&#123;<span class="string">'9'</span>,<span class="string">"wxyz"</span>&#125; &#125;;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">size</span> = digits.<span class="built_in">size</span>();<span class="comment">//输入字符串产长度</span></span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="built_in">string</span>&gt; que;<span class="comment">//新建队列</span></span><br><span class="line"><span class="comment">//先将第一个元素对应的码表入队</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m[digits[<span class="number">0</span>]].<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line"><span class="built_in">string</span> str;</span><br><span class="line">str.push_back(m[digits[<span class="number">0</span>]][j]);</span><br><span class="line">que.push(str);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">string</span> s;       <span class="comment">//用于存储队头元素</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="built_in">size</span>; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> length = que.<span class="built_in">size</span>();        <span class="comment">//当前队列长度</span></span><br><span class="line"><span class="keyword">while</span> (length--) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m[digits[i]].<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">s = que.front();</span><br><span class="line">s = s + m[digits[i]][j];<span class="comment">//队头元素加上新元素</span></span><br><span class="line">que.push(s);<span class="comment">//入队</span></span><br><span class="line">&#125;</span><br><span class="line">que.pop();<span class="comment">//队头出队</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (!que.empty()) &#123;</span><br><span class="line">res.push_back(que.front());</span><br><span class="line">que.pop();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="1030-距离顺序排列矩阵单元格"><a href="#1030-距离顺序排列矩阵单元格" class="headerlink" title="1030. 距离顺序排列矩阵单元格"></a>1030. 距离顺序排列矩阵单元格</h3><ul><li><blockquote><p>给出 R 行 C 列的矩阵，其中的单元格的整数坐标为 (r, c)，满足 0 &lt;= r &lt; R 且 0 &lt;= c &lt; C。</p></blockquote></li><li>另外，我们在该矩阵中给出了一个坐标为 (r0, c0) 的单元格。</li><li>返回矩阵中的所有单元格的坐标，并按到 (r0, c0) 的距离从最小到最大的顺序排，其中，两单元格(r1, c1) 和 (r2, c2) 之间的距离是曼哈顿距离，|r1 - r2| + |c1 - c2|。（你可以按任何满足此条件的顺序返回答案。）</li></ul><ul><li><p>输入：R = 1, C = 2, r0 = 0, c0 = 0</p></li><li><p>输出：[[0,0],[0,1]]</p></li><li><p>解释：从 (r0, c0) 到其他单元格的距离为：[0,1]</p></li><li><p>输入：R = 2, C = 2, r0 = 0, c0 = 1</p></li><li><p>输出：[[0,1],[0,0],[1,1],[1,0]]</p></li><li><p>解释：从 (r0, c0) 到其他单元格的距离为：[0,1,1,2]</p></li><li><p>[[0,1],[1,1],[0,0],[1,0]] 也会被视作正确答案。</p></li><li><blockquote><p>典型的广度搜索,起始节点为种子</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">allCellsDistOrder</span><span class="params">(<span class="keyword">int</span> R, <span class="keyword">int</span> C, <span class="keyword">int</span> r0, <span class="keyword">int</span> c0)</span> </span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;res;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt;vis(R, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(C, <span class="literal">true</span>));</span><br><span class="line"><span class="built_in">queue</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;arr;</span><br><span class="line">arr.push(&#123; r0,c0 &#125;);</span><br><span class="line">vis[r0][c0] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dX[<span class="number">4</span>] = &#123; <span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> dY[<span class="number">4</span>] = &#123; <span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">while</span> (!arr.empty()) &#123;</span><br><span class="line"><span class="keyword">auto</span>[x, y] = arr.front();</span><br><span class="line">arr.pop();</span><br><span class="line">res.push_back(&#123; x,y &#125;);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> tempX = x + dX[i];</span><br><span class="line"><span class="keyword">int</span> tempY = y + dY[i];</span><br><span class="line"><span class="keyword">if</span> (tempX &gt;= <span class="number">0</span> &amp;&amp; tempX &lt; R &amp;&amp; tempY &gt;= <span class="number">0</span> &amp;&amp; tempY &lt; C &amp;&amp; vis[tempX][tempY]) &#123;</span><br><span class="line">vis[tempX][tempY] = <span class="literal">false</span>;</span><br><span class="line">arr.push(&#123; tempX,tempY &#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
          <category> 广度搜索——烂橘子 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>生活 / 感概</title>
      <link href="/2020/08/22/%E7%94%9F%E6%B4%BB-%E6%84%9F%E6%A6%82/"/>
      <url>/2020/08/22/%E7%94%9F%E6%B4%BB-%E6%84%9F%E6%A6%82/</url>
      
        <content type="html"><![CDATA[<p><img src="/pictures/0822.jpg" alt="img"><br><img src="/pictures/0833.jpg" alt="img"></p><ul><li><blockquote><p>陆陆续续也面试了很多公司，感觉还是和互联网大厂有差距啊。</p></blockquote></li><li><blockquote><p>国米也倒在了决赛，人生就是这样，继续加油吧！！！</p></blockquote></li></ul>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
          <category> 近期感悟(2020/08/22) </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Others / ubuntu开机程序终端自启动</title>
      <link href="/2020/08/19/Others-Qt%E5%BC%80%E6%9C%BA%E7%A8%8B%E5%BA%8F%E7%BB%88%E7%AB%AF%E8%87%AA%E5%90%AF%E5%8A%A8/"/>
      <url>/2020/08/19/Others-Qt%E5%BC%80%E6%9C%BA%E7%A8%8B%E5%BA%8F%E7%BB%88%E7%AB%AF%E8%87%AA%E5%90%AF%E5%8A%A8/</url>
      
        <content type="html"><![CDATA[<p><font size=5>方法一</font> </p><ul><li><blockquote><p>设置程序自启动目录为：/home/userName/.config/autostart</p></blockquote></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">cd /<span class="built_in">home</span>/nvidia/.<span class="built_in">config</span></span><br><span class="line">cd autostart #若没有创建,<span class="built_in">mkdir</span> autostart</span><br><span class="line">touch app.desktop</span><br><span class="line">gedit app.desktop</span><br><span class="line"></span><br><span class="line">##添加</span><br><span class="line">[Desktop Entry]</span><br><span class="line">Type=Application</span><br><span class="line">Exec=gnome-terminal -x bash -c <span class="string">"sh /home/nvidia/appTest/CameraWater.sh;exec bash;"</span></span><br><span class="line">Hidden=<span class="literal">false</span></span><br><span class="line">NoDisplay=<span class="literal">false</span></span><br><span class="line">X-GNOME-Autostart-enabled=<span class="literal">true</span></span><br></pre></td></tr></table></figure><hr><p><font size=5>方法二</font> </p><ul><li><blockquote><p>gedit /etc/rc.local</p></blockquote></li></ul>]]></content>
      
      
      <categories>
          
          <category> Others </category>
          
          <category> ubuntu开机程序终端自启动 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Others / ubuntu_GPIO触发</title>
      <link href="/2020/08/19/Others-Qt%E7%A8%8B%E5%BA%8F%E6%89%93%E5%8C%85/"/>
      <url>/2020/08/19/Others-Qt%E7%A8%8B%E5%BA%8F%E6%89%93%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<ul><li><blockquote><p>解决方法链接：<a href="https://stackoverflow.com/questions/30938991/access-gpio-sys-class-gpio-as-non-root/30940526" target="_blank" rel="noopener">https://stackoverflow.com/questions/30938991/access-gpio-sys-class-gpio-as-non-root/30940526</a></p></blockquote></li><li><blockquote><p>硬件获取触发权限、开放对应端口</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.开放权限</span></span><br><span class="line">gedit /etc/udev/rules.d/<span class="number">99</span>-galaxy-u3v.rules</span><br><span class="line">##添加</span><br><span class="line">SUBSYSTEM==<span class="string">"gpio*"</span>, PROGRAM=<span class="string">"/bin/sh -c 'chown -R root:gpio /sys/class/gpio &amp;&amp; chmod -R 770 /sys/class/gpio'"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.设置触发</span></span><br><span class="line">gedit /etc/rc.local</span><br><span class="line">##添加</span><br><span class="line">sudo chmod <span class="number">770</span> /sys/class/gpio/unexport /sys/class/gpio/<span class="keyword">export</span></span><br><span class="line">sudo echo <span class="number">246</span> &gt; /sys/class/gpio/<span class="keyword">export</span></span><br><span class="line">sudo chmod -R <span class="number">777</span> /sys/class/gpio/gpio246</span><br><span class="line">sudo echo out &gt; /sys/class/gpio/gpio246/direcion</span><br><span class="line">sudo echo <span class="number">0</span> &gt; /sys/class/gpio/gpio246/value</span><br></pre></td></tr></table></figure></li></ul><hr><ul><li><blockquote><p>C++具体实现<br><font size=5>gpioset.h</font> </p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> GPIOSET</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIOSET</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYSFS_GPIO_DIR <span class="meta-string">"/sys/class/gpio"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> POLL_TIMEOUT (3 * 1000) <span class="comment">/* 3 seconds */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_BUF 64</span></span><br><span class="line"><span class="comment">//int keepgoing = 1;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> PIN_DIRECTION</span><br><span class="line">&#123;</span><br><span class="line">    INPUT_PIN=<span class="number">0</span>,</span><br><span class="line">    OUTPUT_PIN=<span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> PIN_VALUE</span><br><span class="line">&#123;</span><br><span class="line">    <span class="literal">LOW</span> = <span class="number">0</span>,</span><br><span class="line">    <span class="literal">HIGH</span> = <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*****************************************/</span></span><br><span class="line"><span class="comment">/* gpio export */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gpio_export</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> gpio)</span></span>;</span><br><span class="line"><span class="comment">/* gpio unexport */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gpio_unexport</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> gpio)</span></span>;</span><br><span class="line"><span class="comment">/* gpio set dir */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gpio_set_dir</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> gpio, <span class="keyword">const</span> <span class="keyword">char</span> *dir)</span></span>;</span><br><span class="line"><span class="comment">/* gpio set value */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gpio_set_value</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> gpio, <span class="keyword">unsigned</span> <span class="keyword">int</span> value)</span></span>;</span><br><span class="line"><span class="comment">/* gpio get value */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gpio_get_value</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> gpio, <span class="keyword">unsigned</span> <span class="keyword">int</span> *value)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* gpio set edge</span></span><br><span class="line"><span class="comment">控制中断触发模式:引脚被配置为中断后可以使用poll()函数监听引脚</span></span><br><span class="line"><span class="comment">非中断引脚:echo "none" &gt;edge</span></span><br><span class="line"><span class="comment">上升沿触发:rising</span></span><br><span class="line"><span class="comment">下降沿触发:falling</span></span><br><span class="line"><span class="comment">边沿触发:both</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gpio_set_edge</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> gpio, <span class="keyword">const</span> <span class="keyword">char</span> *edge)</span></span>;</span><br><span class="line"><span class="comment">/* gpio fd open */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gpio_fd_open</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> gpio, <span class="keyword">unsigned</span> <span class="keyword">int</span> dir)</span></span>;</span><br><span class="line"><span class="comment">/* gpio fd close */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gpio_fd_close</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br><span class="line"><span class="comment">/*// Callback called when SIGINT is sent to the process (Ctrl-C)</span></span><br><span class="line"><span class="comment">void signal_handler(int sig);*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// GPIOSET</span></span></span><br></pre></td></tr></table></figure><font size=5>gpioset.cpp</font> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"gpioset.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* gpio export */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gpio_export</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> gpio)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd, len;</span><br><span class="line">    <span class="keyword">char</span> buf[MAX_BUF];</span><br><span class="line"></span><br><span class="line">    fd = <span class="built_in">open</span>(SYSFS_GPIO_DIR <span class="string">"/export"</span>, O_WRONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">"\nFailed export GPIO-%d\n"</span>, gpio);</span><br><span class="line">        <span class="keyword">return</span> fd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    len = <span class="built_in">snprintf</span>(buf, <span class="keyword">sizeof</span>(buf), <span class="string">"%d"</span>, gpio);</span><br><span class="line">    <span class="built_in">write</span>(fd, buf, len);</span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">"\nSucessfully export GPIO-%d\n"</span>, gpio);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* gpio unexport */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gpio_unexport</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> gpio)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd, len;</span><br><span class="line">    <span class="keyword">char</span> buf[MAX_BUF];</span><br><span class="line"></span><br><span class="line">    fd = <span class="built_in">open</span>(SYSFS_GPIO_DIR <span class="string">"/unexport"</span>, O_WRONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">"\nFailed unexport GPIO-%d\n"</span>, gpio);</span><br><span class="line">        <span class="keyword">return</span> fd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    len = <span class="built_in">snprintf</span>(buf, <span class="keyword">sizeof</span>(buf), <span class="string">"%d"</span>, gpio);</span><br><span class="line">    <span class="built_in">write</span>(fd, buf, len);</span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">"\nSucessfully unexport GPIO-%d\n"</span>, gpio);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* gpio set dir */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gpio_set_dir</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> gpio, <span class="keyword">const</span> <span class="keyword">char</span> *dir)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd, len;</span><br><span class="line">    <span class="keyword">char</span> buf[MAX_BUF];</span><br><span class="line"></span><br><span class="line">    len = <span class="built_in">snprintf</span>(buf, <span class="keyword">sizeof</span>(buf), SYSFS_GPIO_DIR <span class="string">"/gpio%d/direction"</span>, gpio);</span><br><span class="line">    fd = <span class="built_in">open</span>(buf, O_WRONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">"\nFailed set GPIO-%d direction\n"</span>, gpio);</span><br><span class="line">        <span class="keyword">return</span> fd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">write</span>(fd, dir, <span class="built_in">strlen</span>(dir)+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">"\nSucessfully set GPIO-%d direction\n"</span>, gpio);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* gpio set value */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gpio_set_value</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> gpio, <span class="keyword">unsigned</span> <span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd, len;</span><br><span class="line">    <span class="keyword">char</span> buf[MAX_BUF];</span><br><span class="line"></span><br><span class="line">    len = <span class="built_in">snprintf</span>(buf, <span class="keyword">sizeof</span>(buf), SYSFS_GPIO_DIR <span class="string">"/gpio%d/value"</span>, gpio);</span><br><span class="line"></span><br><span class="line">    fd = <span class="built_in">open</span>(buf, O_WRONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">"\nFailed set GPIO-%d value\n"</span>, gpio);</span><br><span class="line">        <span class="keyword">return</span> fd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (value!=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="built_in">write</span>(fd, <span class="string">"1"</span>, <span class="number">2</span>);</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">"\nGPIO-%d value set high\n"</span>, gpio);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">write</span>(fd, <span class="string">"0"</span>, <span class="number">2</span>);</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">"\nGPIO-%d value set low\n"</span>, gpio);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">"\nSucessfully set GPIO-%d value\n"</span>, gpio);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* gpio get value */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gpio_get_value</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> gpio, <span class="keyword">unsigned</span> <span class="keyword">int</span> *value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd, len;</span><br><span class="line">    <span class="keyword">char</span> buf[MAX_BUF];</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line"></span><br><span class="line">    len = <span class="built_in">snprintf</span>(buf, <span class="keyword">sizeof</span>(buf), SYSFS_GPIO_DIR <span class="string">"/gpio%d/value"</span>, gpio);</span><br><span class="line"></span><br><span class="line">    fd = <span class="built_in">open</span>(buf, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">"\nFailed get GPIO-%d value\n"</span>, gpio);</span><br><span class="line">        <span class="keyword">return</span> fd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">read</span>(fd, &amp;ch, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ch != <span class="string">'0'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        *value = <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        *value = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">"\nSucessfully get GPIO-%d value\n"</span>, gpio);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* gpio set edge */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gpio_set_edge</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> gpio, <span class="keyword">const</span> <span class="keyword">char</span> *edge)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd, len;</span><br><span class="line">    <span class="keyword">char</span> buf[MAX_BUF];</span><br><span class="line"></span><br><span class="line">    len = <span class="built_in">snprintf</span>(buf, <span class="keyword">sizeof</span>(buf), SYSFS_GPIO_DIR <span class="string">"/gpio%d/edge"</span>, gpio);</span><br><span class="line"></span><br><span class="line">    fd = <span class="built_in">open</span>(buf, O_WRONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">"\nFailed set GPIO-%d edge\n"</span>, gpio);</span><br><span class="line">        <span class="keyword">return</span> fd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">write</span>(fd, edge, <span class="built_in">strlen</span>(edge) + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* gpio fd open */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gpio_fd_open</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> gpio, <span class="keyword">unsigned</span> <span class="keyword">int</span> dir)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd, len;</span><br><span class="line">    <span class="keyword">char</span> buf[MAX_BUF];</span><br><span class="line"></span><br><span class="line">    len = <span class="built_in">snprintf</span>(buf, <span class="keyword">sizeof</span>(buf), SYSFS_GPIO_DIR <span class="string">"/gpio%d/value"</span>, gpio);</span><br><span class="line"></span><br><span class="line">    fd = <span class="built_in">open</span>(buf, dir | O_NONBLOCK );</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"gpio/fd_open"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fd;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* gpio fd close */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gpio_fd_close</span><span class="params">(<span class="keyword">int</span> fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">close</span>(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Callback called when SIGINT is sent to the process (Ctrl-C)</span></span><br><span class="line"><span class="comment">/*void signal_handler(int sig)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    printf( "Ctrl-C pressed, cleaning up and exiting..\n" );</span></span><br><span class="line"><span class="comment">    keepgoing = 0;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br></pre></td></tr></table></figure><font size=5>main.cpp / 具体调用</font> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gpio_set_dir(<span class="number">246</span>,<span class="string">"out"</span>);</span><br><span class="line">gpio_set_value(<span class="number">246</span>,<span class="number">0</span>);</span><br><span class="line">gpio_set_value(<span class="number">246</span>,<span class="number">1</span>);</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Others </category>
          
          <category> ubuntu_GPIO触发 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode / STL容器</title>
      <link href="/2020/08/19/LeetCode-STL%E5%AE%B9%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2020/08/19/LeetCode-STL%E5%AE%B9%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<ul><li><blockquote><p>六大模块：容器、容器适配器、迭代器、算法、仿函数、空间适配器</p></blockquote></li></ul><h2 id="1-Stack-栈"><a href="#1-Stack-栈" class="headerlink" title="1.Stack_栈"></a>1.Stack_栈</h2><hr><h3 id="LC-32-最长有效括号"><a href="#LC-32-最长有效括号" class="headerlink" title="LC_32.最长有效括号"></a>LC_32.最长有效括号</h3><ul><li><blockquote><p>给定一个只包含 ‘(‘ 和 ‘)’ 的字符串，找出<strong>最长</strong>的包含<strong>有效括号的子串的长度。</strong></p></blockquote></li><li><blockquote><p>子串：<strong>最长子串、最长子串、最长子串、最长子串、最长子串、最长子串</strong></p></blockquote></li><li><blockquote><p>输入: “(()”</p></blockquote></li><li><p>输出: 2</p></li><li><p>解释: 最长有效括号子串为 “()”</p></li><li><blockquote><p>输入: “)()())”</p></blockquote></li><li><p>输出: 4</p></li><li><p>解释: 最长有效括号子串为 “()()”</p></li><li><blockquote><p>解题：</p></blockquote></li></ul><ol><li>stack找到有效的括号，利用辅助vis(false,true)</li><li>然后找到最长的连续区间即可<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line"><span class="comment">//题目的意思是子串,所以先找到符合的做出判断</span></span><br><span class="line"><span class="comment">//再使用滑动区间找寻</span></span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt;arr;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;vis(s.<span class="built_in">size</span>(), <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (s[i] == <span class="string">'('</span>)</span><br><span class="line">arr.push(i);</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (arr.empty())</span><br><span class="line">vis[i] = <span class="literal">false</span>; <span class="comment">//没有匹配的括号</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">arr.pop();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (!arr.empty()) &#123;</span><br><span class="line">vis[arr.top()] = <span class="literal">false</span>;</span><br><span class="line">arr.pop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vis.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (vis[i] == <span class="literal">false</span>) &#123;</span><br><span class="line">len = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">len++;</span><br><span class="line">res = <span class="built_in">max</span>(len, res);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><hr><h3 id="LC-32-剑指09两个栈实现队列"><a href="#LC-32-剑指09两个栈实现队列" class="headerlink" title="LC_32.剑指09两个栈实现队列"></a>LC_32.剑指09两个栈实现队列</h3><ul><li><blockquote><p>解题：用一个辅助栈来过一次手</p></blockquote></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CQueue</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt;s1;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt;s2;</span><br><span class="line">    CQueue() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//利用两个栈，加的时候，先将s1的放入s2, 然会加s1，s2的再回来</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">appendTail</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(!s1.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = s1.top();</span><br><span class="line">            s2.push(temp);</span><br><span class="line">            s1.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        s1.push(value);</span><br><span class="line">        <span class="keyword">while</span>(!s2.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = s2.top();</span><br><span class="line">            s1.push(temp);</span><br><span class="line">            s2.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">deleteHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s1.empty())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> temp = s1.top();</span><br><span class="line">        s1.pop();</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h3 id="单调栈问题"><a href="#单调栈问题" class="headerlink" title="单调栈问题"></a>单调栈问题</h3><ul><li><blockquote><p>入栈元素小标</p></blockquote></li><li><p>进行比较的是栈顶元素</p></li><li><blockquote><p>模板</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt;minn;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!minn.empty() &amp;&amp; T[i] &gt; T[minn.top()]) &#123;</span><br><span class="line"></span><br><span class="line">minn.pop();</span><br><span class="line">&#125;</span><br><span class="line">minn.push(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="LC-739-每日温度（找右边第一个比他大的数—递减栈）"><a href="#LC-739-每日温度（找右边第一个比他大的数—递减栈）" class="headerlink" title="LC_739. 每日温度（找右边第一个比他大的数—递减栈）"></a>LC_739. 每日温度（找右边第一个比他大的数—递减栈）</h3><ul><li><blockquote><p>请根据每日 气温 列表，重新生成一个列表。对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，请在该位置用 0 来代替。</p></blockquote></li><li><p>例如，给定一个列表 temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。</p></li><li><p>提示：气温 列表长度的范围是 [1, 30000]。每个气温的值的均为华氏度，都是在 [30, 100] 范围内的整数。</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;dailyTemperatures(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; T) &#123;</span><br><span class="line"><span class="keyword">int</span> len = T.<span class="built_in">size</span>();</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;res(len, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt;minn;</span><br><span class="line"><span class="comment">//单调栈问题,储存的的元素下标</span></span><br><span class="line"><span class="comment">//递减栈: 小于栈顶,加入栈</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line"><span class="keyword">while</span> (!minn.empty() &amp;&amp; T[i] &gt; T[minn.top()]) &#123;</span><br><span class="line"><span class="keyword">int</span> resCnt = i - minn.top();</span><br><span class="line">res[minn.top()] = resCnt;</span><br><span class="line">minn.pop();</span><br><span class="line">&#125;</span><br><span class="line">minn.push(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="LC-84-柱状图中最大的矩形"><a href="#LC-84-柱状图中最大的矩形" class="headerlink" title="LC_84. 柱状图中最大的矩形"></a>LC_84. 柱状图中最大的矩形</h3><ul><li><blockquote><p>给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。</p></blockquote></li><li><p>求在该柱状图中，能够勾勒出来的矩形的最大面积。<br><img src="/pictures/clipboard128.png" alt="img"></p></li><li><blockquote><p>他的最大面积：高*宽，每个高度能把他包住都算一次。</p></blockquote></li><li><p>宽度：左边第一个比他小的，右边第一个比他小的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; heights)</span> </span>&#123;</span><br><span class="line"><span class="comment">//为了当只存在一个元素时,也能计算</span></span><br><span class="line">heights.push_back(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//相当于维护一个递增栈</span></span><br><span class="line"><span class="keyword">int</span> len = heights.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//靠单调栈、靠特性:递增栈，下面的第一个元素肯定比他小</span></span><br><span class="line"><span class="comment">//找到右边第一个比他小的数、左边第一个比他小的数字</span></span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt;maxx;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line"><span class="keyword">while</span> (!maxx.empty() &amp;&amp; heights[i] &lt; heights[maxx.top()]) &#123;</span><br><span class="line"><span class="keyword">int</span> temp = maxx.top();</span><br><span class="line">maxx.pop();</span><br><span class="line">res = <span class="built_in">max</span>(res, heights[temp] * (maxx.empty() ? i : (i - maxx.top() - <span class="number">1</span>)));</span><br><span class="line">&#125;                  <span class="comment">//高度              宽度</span></span><br><span class="line">maxx.push(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="2-Map-映射表"><a href="#2-Map-映射表" class="headerlink" title="2.Map_映射表"></a>2.Map_映射表</h2><ul><li><blockquote><p>成员函数</p></blockquote></li><li>auto it = A.find(key)<ul><li>if(it == A.end())没查找到</li></ul></li></ul><hr><h3 id="LC-1-两数之和"><a href="#LC-1-两数之和" class="headerlink" title="LC_1.两数之和"></a>LC_1.两数之和</h3><ul><li><blockquote><p>数组中找两个元素之和为target</p></blockquote></li><li><blockquote><p>解法：暴力：time——O（n^2）,空间——O（1）</p></blockquote></li><li>哈希表：time——O（n）,空间——O（n）<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//vector&lt;int&gt;a;</span></span><br><span class="line"><span class="comment">//暴力O(n^2)</span></span><br><span class="line"><span class="comment">// for(int i=0;i!=nums.size();i++)</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//     for(int j=i;j!=nums.size();j++)</span></span><br><span class="line"><span class="comment">//     &#123;</span></span><br><span class="line"><span class="comment">//         if(nums[i]+nums[j]==target&amp;&amp;i!=j)</span></span><br><span class="line"><span class="comment">//         &#123;</span></span><br><span class="line"><span class="comment">//             a.push_back(i);</span></span><br><span class="line"><span class="comment">//             a.push_back(j);</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;vis;<span class="comment">//存放元素值,和元素下标</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line"><span class="keyword">auto</span> iter = vis.<span class="built_in">find</span>(target - nums[i]);</span><br><span class="line"><span class="keyword">if</span> (iter != vis.<span class="built_in">end</span>()) &#123;</span><br><span class="line"><span class="keyword">return</span> &#123; i,iter-&gt;second &#125;;</span><br><span class="line">&#125;</span><br><span class="line">vis.emplace(nums[i], i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="LC-387-字符串中的第一个唯一字符"><a href="#LC-387-字符串中的第一个唯一字符" class="headerlink" title="LC_387.字符串中的第一个唯一字符"></a>LC_387.字符串中的第一个唯一字符</h3><ul><li><blockquote><p>数组中找两个元素之和为target</p></blockquote></li><li><blockquote><p>解法：暴</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//时间复杂度n,空间复杂度n</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//哈希表的很多使用都可以转化为vector&lt;int&gt;的使用</span></span><br><span class="line"><span class="comment">//26个字母:vector&lt;int&gt;vis(26,0);</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">firstUniqChar</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;vis;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++)</span><br><span class="line">vis[s[i]]++;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (vis[s[i]] == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="3-Set-集合"><a href="#3-Set-集合" class="headerlink" title="3.Set_集合"></a>3.Set_集合</h2><ul><li><blockquote><p>成员函数</p></blockquote></li><li>初始化：unordered_set&lt; string &gt;res <strong>(words.begin(),words.end())</strong>; //vector&lt; string &gt; &amp; words</li></ul><hr><h3 id="LC-820-单词的压缩编码"><a href="#LC-820-单词的压缩编码" class="headerlink" title="LC_820.单词的压缩编码"></a>LC_820.单词的压缩编码</h3><ul><li><blockquote><p>给定一个单词列表，我们将这个列表编码成一个索引字符串 S 与一个索引列表 A。</p></blockquote></li><li><p>例如，如果这个列表是 [“time”, “me”, “bell”]，我们就可以将其表示为 S = “time#bell#” 和 indexes = [0, 2, 5]。</p></li><li><p>对于每一个索引，我们可以通过从字符串 S 中索引的位置开始读取字符串，直到 “#” 结束，来恢复我们之前的单词列表。</p></li><li><p>那么成功对给定单词列表进行编码的最小字符串长度是多少呢？</p></li><li><blockquote><p>输入: words = [“time”, “me”, “bell”]</p></blockquote></li><li><p>输出: 10</p></li><li><p>说明: S = “time#bell#” ， indexes = [0, 2, 5] 。</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minimumLengthEncoding</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words)</span> </span>&#123;</span><br><span class="line"><span class="comment">//初始化:1</span></span><br><span class="line"><span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt;res;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it : words) &#123;</span><br><span class="line">res.insert(it);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//初始化:2</span></span><br><span class="line"><span class="comment">//unordered_set&lt;string&gt;res(words.begin(),words.end());</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//对于每个单词,我们对其进行重复的查找,利用set容器无重复元素，删除重复的元素</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it : words) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; it.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">res.erase(it.substr(i));    <span class="comment">// time "ime" "me" "e"</span></span><br><span class="line">&#125;                               <span class="comment">// me "e" </span></span><br><span class="line">&#125;                                   <span class="comment">// bell "e" "el" "ell"</span></span><br><span class="line"><span class="comment">//time#bell#,一个单词需要加上一个#</span></span><br><span class="line"><span class="keyword">int</span> nums = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it : res) &#123;</span><br><span class="line">nums += it.<span class="built_in">size</span>() + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="4-Queue-单向队列"><a href="#4-Queue-单向队列" class="headerlink" title="4.Queue_单向队列"></a>4.Queue_单向队列</h2><ul><li><blockquote><p>成员函数</p></blockquote></li><li>A.push();</li><li>A.front();//返回元素</li><li>A.back(); //返回元素</li><li>A.pop();</li></ul><hr><h3 id="LC-225-用队列实现栈"><a href="#LC-225-用队列实现栈" class="headerlink" title="LC_225. 用队列实现栈"></a>LC_225. 用队列实现栈</h3><ul><li><blockquote><p>进入之后，N-1个元素再重新进</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;arr;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">arr.push(x);</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">size</span> = arr.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span> - <span class="number">1</span>; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> temp = arr.front();</span><br><span class="line">arr.push(temp);</span><br><span class="line">arr.pop();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (arr.empty())</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">int</span> temp = arr.front();</span><br><span class="line">arr.pop();</span><br><span class="line"><span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> arr.front();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> arr.empty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="5-deque-双向队列"><a href="#5-deque-双向队列" class="headerlink" title="5.deque_双向队列"></a>5.deque_双向队列</h2><hr><h2 id="6-list-双向链表"><a href="#6-list-双向链表" class="headerlink" title="6.list_双向链表"></a>6.list_双向链表</h2><ul><li><blockquote><p>成员函数</p></blockquote></li><li>A.erase(迭代器)</li></ul><hr><h3 id="LC-146-LRU缓存机制"><a href="#LC-146-LRU缓存机制" class="headerlink" title="LC_146. LRU缓存机制"></a>LC_146. LRU缓存机制</h3><ul><li><blockquote><p>运用你所掌握的数据结构，设计和实现一个  LRU (最近最少使用) 缓存机制。它应该支持以下操作： 获取数据 get 和 写入数据 put 。</p></blockquote></li><li><p>获取数据 get(key) - 如果关键字 (key) 存在于缓存中，则获取关键字的值（总是正数），否则返回 -1。</p></li><li><p>写入数据 put(key, value) - 如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字/值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。</p></li><li><blockquote><p>例题：</p></blockquote></li><li><p>LRUCache cache = new LRUCache( 2 /* 缓存容量 */ );</p></li><li><p>cache.put(1, 1);</p></li><li><p>cache.put(2, 2);</p></li><li><p>cache.get(1);       // 返回  1</p></li><li><p>cache.put(3, 3);    // 该操作会使得关键字 2 作废</p></li><li><p>cache.get(2);       // 返回 -1 (未找到)</p></li><li><p>cache.put(4, 4);    // 该操作会使得关键字 1 作废</p></li><li><p>cache.get(1);       // 返回 -1 (未找到)</p></li><li><p>cache.get(3);       // 返回  3</p></li><li><p>cache.get(4);       // 返回  4</p></li><li><blockquote><p>题解：</p></blockquote><ul><li>利用list存储元素，从而保证时序性</li><li>利用unordered_map存储list的iterator，从而保证删除、查找的时间<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">LRUCache(<span class="keyword">int</span> capacity) &#123;</span><br><span class="line"><span class="built_in">size</span> = capacity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">list</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;arr;</span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">list</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;::iterator&gt;vis;</span><br><span class="line"><span class="comment">//list&lt;pair&lt;int,int&gt;&gt;arr;</span></span><br><span class="line"><span class="comment">//unordered_map&lt;key,arr::iterator&gt;vis;</span></span><br><span class="line"><span class="comment">//存放迭代器是为了便于删除和查找</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line"><span class="comment">//it是key值</span></span><br><span class="line"><span class="keyword">auto</span> it = vis.<span class="built_in">find</span>(key);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (it == vis.<span class="built_in">end</span>()) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//放到前面去</span></span><br><span class="line">pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;temp = *vis[key];<span class="comment">//迭代器解引就是对应值</span></span><br><span class="line"></span><br><span class="line">arr.erase(vis[key]);</span><br><span class="line">arr.push_front(temp);</span><br><span class="line">vis[key] = arr.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">return</span> temp.second;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line"><span class="keyword">auto</span> it = vis.<span class="built_in">find</span>(key);</span><br><span class="line"></span><br><span class="line"><span class="comment">//不存在</span></span><br><span class="line"><span class="keyword">if</span> (it == vis.<span class="built_in">end</span>()) &#123;</span><br><span class="line"><span class="keyword">if</span> (arr.<span class="built_in">size</span>() == <span class="built_in">size</span>) &#123;</span><br><span class="line"><span class="comment">//删除尾元素</span></span><br><span class="line">pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;temp = arr.back();</span><br><span class="line"><span class="comment">//双删除</span></span><br><span class="line"><span class="keyword">int</span> deleteKey = temp.first;</span><br><span class="line">vis.erase(deleteKey);</span><br><span class="line">arr.pop_back();</span><br><span class="line"></span><br><span class="line">arr.push_front(&#123; key,value &#125;);</span><br><span class="line">vis[key] = arr.<span class="built_in">begin</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">arr.push_front(&#123; key,value &#125;);</span><br><span class="line">vis[key] = arr.<span class="built_in">begin</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//存在</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//存在只需要放到前面去,list删除只能用迭代器</span></span><br><span class="line">arr.erase(vis[key]);</span><br><span class="line"></span><br><span class="line">arr.push_front(&#123; key,value &#125;);</span><br><span class="line">vis[key] = arr.<span class="built_in">begin</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">size</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></li></ul><hr><h2 id="7-vector-动态数组"><a href="#7-vector-动态数组" class="headerlink" title="7.vector_动态数组"></a>7.vector_动态数组</h2><ul><li><blockquote><p>成员函数：</p></blockquote></li><li><blockquote><p>Copy：归并算法会使用到</p></blockquote></li><li><p>copy(B.begin() , B.end(), A.begin());</p><ul><li>OutputIterator copy (InputIterator first, InputIterator last, <strong>OutputIterator result</strong>)</li></ul></li><li><blockquote><p>erase(iterator position)//返回下元素指针</p></blockquote></li><li><blockquote><p>insert ()</p></blockquote><ul><li>单一元素(1)——A.insert (iterator position, const value_type&amp; val);</li><li>相同元素(2)——A.insert (iterator position, size_type n, const value_type&amp; val);</li><li>范围元素(3)——使用广泛——A.insert (iterator position, <strong>InputIterator first</strong>, <strong>InputIterator last</strong>);</li></ul></li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
          <category> STL容器的使用 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode / 回溯法</title>
      <link href="/2020/08/18/LeetCode-%E5%9B%9E%E6%BA%AF%E6%B3%95/"/>
      <url>/2020/08/18/LeetCode-%E5%9B%9E%E6%BA%AF%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="回溯法"><a href="#回溯法" class="headerlink" title="回溯法"></a>回溯法</h2><p><font size=6> 求解所有可能性问题的方法</font> </p><ul><li><blockquote><p>解决一个回溯问题，实际上就是一个决策树的遍历过程。</p></blockquote><ul><li>1、结束条件：也就是到达决策树底层，无法再做选择的条件。return</li><li>2、选择列表：也就是你当前可以做的选择。</li><li>3、路径：也就是已经做出的选择。<br><img src="/pictures/clipboard108.png" alt="img1"><br><img src="/pictures/clipboard109.png" alt="img1"></li></ul></li></ul><p><font size=6> 固定套路</font> </p><ul><li>1、结束条件</li><li>2、条件选择</li><li>3、做出选择</li><li>4、继续dfs</li><li>5、撤销选择</li></ul><hr><h3 id="46-全排列（无重复、最经典）"><a href="#46-全排列（无重复、最经典）" class="headerlink" title="46.全排列（无重复、最经典）"></a>46.全排列（无重复、最经典）</h3><ul><li><blockquote><p>给定一个 <strong>没有重复</strong> 数字的序列，返回其所有可能的全排列。</p></blockquote></li><li><p>输入: [1,2,3]</p></li><li><p>输出:</p></li><li><p>[</p></li><li><p>[1,2,3],</p></li><li><p>[1,3,2],</p></li><li><p>[2,1,3],</p></li><li><p>[2,3,1],</p></li><li><p>[3,1,2],</p></li><li><p>[3,2,1]</p></li><li><p>]</p></li><li><blockquote><p>解题：最经典的回溯法求问题</p></blockquote></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;res;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">calculate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;arr;</span><br><span class="line"><span class="comment">//辅助判断函数</span></span><br><span class="line">   <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;vis(nums.<span class="built_in">size</span>(), <span class="literal">false</span>);</span><br><span class="line">dfs(nums, arr, vis);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&amp; vis)</span> </span>&#123;</span><br><span class="line"><span class="comment">//结束条件</span></span><br><span class="line"><span class="keyword">if</span> (arr.<span class="built_in">size</span>() == nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">res.emplace_back(arr);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line"><span class="comment">//条件选择</span></span><br><span class="line"><span class="keyword">if</span> (vis[i])<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//做出选择</span></span><br><span class="line">arr.emplace_back(nums[i]);</span><br><span class="line">vis[i] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//继续dfs</span></span><br><span class="line">dfs(nums, arr, vis);</span><br><span class="line"></span><br><span class="line"><span class="comment">//撤销选择</span></span><br><span class="line">arr.pop_back();</span><br><span class="line">vis[i] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><ul><li><blockquote><p>unordered_map</p></blockquote></li><li><a href="https://www.cnblogs.com/slothrbk/p/8823092.html" target="_blank" rel="noopener">https://www.cnblogs.com/slothrbk/p/8823092.html</a></li></ul><h3 id="47-全排列II（重复元素，unordered-map存储元素）"><a href="#47-全排列II（重复元素，unordered-map存储元素）" class="headerlink" title="47.全排列II（重复元素，unordered_map存储元素）"></a>47.全排列II（重复元素，unordered_map存储元素）</h3><ul><li><blockquote><p>给定一个可包含重复数字的序列，返回所有不重复的全排列。</p></blockquote></li><li>输入: [1,1,2]</li><li>输出:</li><li>[</li><li>[1,1,2],</li><li>[1,2,1],</li><li>[2,1,1]</li><li>]<br><img src="/pictures/clipboard127.png" alt="img1"></li><li><blockquote><p>解题：利用unordered_map来存储元素，从而避免重复元素</p></blockquote></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;res;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">permuteUnique</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;vis;</span><br><span class="line"><span class="keyword">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it : nums)vis[it]++;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;arr;</span><br><span class="line">dfs(vis, len, arr);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&amp;vis, <span class="keyword">int</span> len, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line"><span class="comment">//结束条件</span></span><br><span class="line"><span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">res.push_back(arr);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;it : vis) &#123;</span><br><span class="line"><span class="comment">//条件选择</span></span><br><span class="line"><span class="keyword">if</span> (it.second == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//做出选择</span></span><br><span class="line">it.second--;</span><br><span class="line">arr.push_back(it.first);</span><br><span class="line"></span><br><span class="line"><span class="comment">//继续dfs</span></span><br><span class="line">dfs(vis, len - <span class="number">1</span>, arr);</span><br><span class="line"></span><br><span class="line"><span class="comment">//撤销选择</span></span><br><span class="line">it.second++;</span><br><span class="line">arr.pop_back();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="39-组合中元素和为Sum（无重复元素、任意次数使用）"><a href="#39-组合中元素和为Sum（无重复元素、任意次数使用）" class="headerlink" title="39.组合中元素和为Sum（无重复元素、任意次数使用）"></a>39.组合中元素和为Sum（无重复元素、任意次数使用）</h3><ul><li><blockquote><p>给定一个无重复元素的数组 arr 和一个目标数 target ，找出 arr 中所有可以使数字和为 target 的组合。</p></blockquote></li><li><p>arr 中的数字可以无限制重复被选取。</p></li><li><blockquote><p>输入：candidates = [2,3,6,7], target = 7,</p></blockquote></li><li><p>所求解集为：</p></li><li><p>[</p></li><li><p>[7],</p></li><li><p>[2,2,3]</p></li><li><p>]</p></li><li><blockquote><p>解题：sort后：大剪枝</p></blockquote></li><li><blockquote><p>可以重复使用：传入的还是index——<strong>传入一个开始的index</strong>，防止<strong>重复使用前面的元素</strong></p></blockquote></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;res;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">combinationSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;arr;</span><br><span class="line"><span class="comment">//先排序</span></span><br><span class="line">sort(candidates.<span class="built_in">begin</span>(), candidates.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">dfs(arr, candidates, target, <span class="number">0</span>);<span class="comment">//0_index</span></span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这里的index很重要，防止重复223,232,322，又回去使用重复元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;arr, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> sum, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (sum == <span class="number">0</span>) &#123;</span><br><span class="line">res.emplace_back(arr);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt; candidates.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line"><span class="comment">//条件选择</span></span><br><span class="line"><span class="keyword">if</span> (sum - candidates[i] &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//做出选择(无限次用)</span></span><br><span class="line">arr.emplace_back(candidates[i]);</span><br><span class="line"><span class="comment">//继续DFS</span></span><br><span class="line">dfs(arr, candidates, sum - candidates[i], i);</span><br><span class="line"><span class="comment">//撤销选择</span></span><br><span class="line">arr.pop_back();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="40-组合中元素和为Sum-II（重复元素、使用一次）"><a href="#40-组合中元素和为Sum-II（重复元素、使用一次）" class="headerlink" title="40.组合中元素和为Sum II（重复元素、使用一次）"></a>40.组合中元素和为Sum II（重复元素、使用一次）</h3><ul><li><blockquote><p>给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</p></blockquote></li><li><p>candidates 中的每个数字在每个组合中只能使用一次。</p></li><li><blockquote><p>题解：</p></blockquote><ul><li>sort后：<strong>大剪纸</strong></li><li>剔除重复的可能：<strong>小剪枝</strong><ul><li>if (i != index &amp;&amp; candidates[i] == candidates[i - 1])</li><li>continue;</li></ul></li><li>元素只能使用一次传入index + 1</li></ul></li></ul><p><img src="/pictures/clipboard112.png" alt="img1">  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;res;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">combinationSum2</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;arr;</span><br><span class="line">sort(candidates.<span class="built_in">begin</span>(), candidates.<span class="built_in">end</span>());</span><br><span class="line">dfs(candidates, arr, target, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;candidates, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;arr, <span class="keyword">int</span> target, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">res.emplace_back(arr);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt; candidates.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line"><span class="comment">//大剪枝</span></span><br><span class="line"><span class="keyword">if</span> (target - candidates[i] &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="comment">//小剪枝：</span></span><br><span class="line"><span class="keyword">if</span> (i &gt; index &amp;&amp; candidates[i] == candidates[i - <span class="number">1</span>])</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//做出选择</span></span><br><span class="line">arr.emplace_back(candidates[i]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//继续dfs,index+1是因为不能重复使用元素</span></span><br><span class="line">dfs(candidates, arr, target - candidates[i], i + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//撤销选择</span></span><br><span class="line">arr.pop_back();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="78-数组内元素组成不同子集-不含重复元素"><a href="#78-数组内元素组成不同子集-不含重复元素" class="headerlink" title="78.数组内元素组成不同子集(不含重复元素)"></a>78.数组内元素组成不同子集(不含重复元素)</h3><ul><li><blockquote><p>给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。</p></blockquote></li><li><p>说明：解集不能包含重复的子集。</p></li><li><p>输入: nums = [1,2,3]</p></li><li><p>输出:</p></li><li><p>[</p></li><li><p>[3],</p></li><li><p>[1],</p></li><li><p>[2],</p></li><li><p>[1,2,3],</p></li><li><p>[1,3],</p></li><li><p>[2,3],</p></li><li><p>[1,2],</p></li><li><p>[]</p></li><li><p>]</p></li><li><blockquote><p>题解：sort后传入index辅助判断</p></blockquote><ul><li>传入index+1：只能用一次 </li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;res;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">subsets</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;arr;</span><br><span class="line">dfs(nums, arr, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;nums, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;arr, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line"><span class="comment">//满足条件，加入res</span></span><br><span class="line">res.emplace_back(arr);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line"></span><br><span class="line">arr.emplace_back(nums[i]);</span><br><span class="line"></span><br><span class="line">dfs(nums, arr, i + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">arr.pop_back();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="90-数组内元素组成不同子集II-包含重复元素"><a href="#90-数组内元素组成不同子集II-包含重复元素" class="headerlink" title="90.数组内元素组成不同子集II(包含重复元素)"></a>90.数组内元素组成不同子集II(包含重复元素)</h3><ul><li><blockquote><p>给定一个可能包含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。</p></blockquote></li><li><blockquote><p>说明：解集不能包含重复的子集。</p></blockquote></li><li><p>输入: [1,2,2]</p></li><li><p>输出:</p></li><li><p>[</p></li><li><p>[2],</p></li><li><p>[1],</p></li><li><p>[1,2,2],</p></li><li><p>[2,2],</p></li><li><p>[1,2],</p></li><li><p>[]</p></li><li><p>]</p></li><li><blockquote><p>题解：包含重复元素，只能用一次</p></blockquote></li><li><blockquote><p>小剪枝：</p></blockquote></li><li><p>if (i != index &amp;&amp; candidates[i] == candidates[i - 1])</p></li><li><p>continue;</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;res;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">subsetsWithDup</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;arr;</span><br><span class="line">sort(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">dfs(nums, arr, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">res.emplace_back(arr);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (i != index &amp;&amp; nums[i] == nums[i - <span class="number">1</span>])</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">arr.emplace_back(nums[i]);</span><br><span class="line">dfs(nums, arr, i + <span class="number">1</span>);</span><br><span class="line">arr.pop_back();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="51-N皇后"><a href="#51-N皇后" class="headerlink" title="51.N皇后"></a>51.N皇后</h3><ul><li><blockquote><p>n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。<br><img src="/pictures/clipboard110.png" alt="img"><br><img src="/pictures/clipboard111.png" alt="img"></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt;res;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; <span class="title">solveNQueens</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="comment">//'.'表示空，'Q'表示皇后</span></span><br><span class="line"><span class="comment">//初始化棋盘，n行，n列</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;board(n, <span class="built_in">string</span>(n, <span class="string">'.'</span>));</span><br><span class="line"><span class="comment">//0表示row = 0</span></span><br><span class="line">backtrack(board, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp;board, <span class="keyword">int</span> row)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (row == board.<span class="built_in">size</span>()) &#123;</span><br><span class="line">res.emplace_back(board);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; board[<span class="number">0</span>].<span class="built_in">size</span>(); col++) &#123;</span><br><span class="line"><span class="comment">//排序不合法</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">isValid</span>(board, row, col)) <span class="keyword">continue</span>;</span><br><span class="line"><span class="comment">//做选择</span></span><br><span class="line">board[row][col] = <span class="string">'Q'</span>;</span><br><span class="line"></span><br><span class="line">backtrack(board, row + <span class="number">1</span>);</span><br><span class="line"><span class="comment">//撤销选择</span></span><br><span class="line">board[row][col] = <span class="string">'.'</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp;board, <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = board.<span class="built_in">size</span>();</span><br><span class="line"><span class="comment">//检查列</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (board[i][col] == <span class="string">'Q'</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//检查左上</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = row - <span class="number">1</span>, j = col - <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>; j--, i--) &#123;</span><br><span class="line"><span class="keyword">if</span> (board[i][j] == <span class="string">'Q'</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//检查右上</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = row - <span class="number">1</span>, j = col + <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &lt; n; j++, i--) &#123;</span><br><span class="line"><span class="keyword">if</span> (board[i][j] == <span class="string">'Q'</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="93-复原IP地址的问题"><a href="#93-复原IP地址的问题" class="headerlink" title="93.复原IP地址的问题"></a>93.复原IP地址的问题</h3><ul><li><blockquote><p>给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。</p></blockquote></li><li><p>有效的 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 ‘.’ 分隔。</p></li><li><p>例如：”0.1.2.201” 和 “192.168.1.1” 是 有效的 IP 地址，但是 “0.011.255.245”、”192.168.1.312” 和 “<a href="mailto:192.168@1.1">192.168@1.1</a>“ 是 无效的 IP 地址。</p></li><li><blockquote><p>输入：s = “25525511135”</p></blockquote></li><li><p>输出：[“255.255.11.135”,”255.255.111.35”]</p></li><li><blockquote><p>输入：s = “0000”</p></blockquote></li><li><p>输出：[“0.0.0.0”]</p></li></ul><p><img src="/pictures/clipboard126.png" alt="img"></p><ul><li><blockquote><p>解：不用考虑剩余元素的个数，只要直接最后判断：1.是否剩余元素 2.是否cnt=4</p></blockquote></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">restoreIpAddresses</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;res;</span><br><span class="line">dfs(s, <span class="string">""</span>, <span class="number">0</span>, res);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> out, <span class="keyword">int</span> cnt, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; res)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (cnt == <span class="number">4</span> &amp;&amp; s.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">out.pop_back();</span><br><span class="line">res.push_back(out);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (cnt == <span class="number">4</span> &amp;&amp; s.<span class="built_in">size</span>())</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= s.<span class="built_in">size</span>() &amp;&amp; i &lt;= <span class="number">3</span>; i++) &#123;</span><br><span class="line"><span class="built_in">string</span> temp = s.substr(<span class="number">0</span>, i);</span><br><span class="line"><span class="keyword">int</span> num = stoi(temp);</span><br><span class="line"></span><br><span class="line"><span class="comment">//防止出现0开头的数。01.01.01.01</span></span><br><span class="line"><span class="keyword">if</span> (to_string(num).<span class="built_in">size</span>() != temp.<span class="built_in">size</span>())</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (num &gt;= <span class="number">0</span> &amp;&amp; num &lt;= <span class="number">255</span>) &#123;</span><br><span class="line"><span class="built_in">string</span> before = out;</span><br><span class="line"><span class="comment">//做出选择</span></span><br><span class="line">out += temp + <span class="string">"."</span>;</span><br><span class="line"><span class="comment">//继续dfs</span></span><br><span class="line">dfs(s.substr(i), out, cnt + <span class="number">1</span>, res);</span><br><span class="line"><span class="comment">//撤销选择</span></span><br><span class="line">out = before;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
          <category> 回溯法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Others / 博客搭建教程</title>
      <link href="/2020/08/11/Others-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/"/>
      <url>/2020/08/11/Others-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<ul><li><blockquote><p>hexo github博客搭建</p></blockquote></li><li><p><a href="https://handsomesuperred.github.io/archives/" target="_blank" rel="noopener">https://handsomesuperred.github.io/archives/</a></p></li><li><blockquote><p>hexo gitee博客搬运</p></blockquote></li><li><p><a href="https://blog.csdn.net/cungudafa/article/details/104260494" target="_blank" rel="noopener">https://blog.csdn.net/cungudafa/article/details/104260494</a></p></li><li><blockquote><p>melody主题设置</p></blockquote></li><li><p><a href="https://molunerfinn.com/hexo-theme-melody-doc/zh-Hans/quick-start.html#%E5%AE%89%E8%A3%85" target="_blank" rel="noopener">https://molunerfinn.com/hexo-theme-melody-doc/zh-Hans/quick-start.html#%E5%AE%89%E8%A3%85</a></p></li></ul><p><img src="/pictures/clipboard107.png" alt="img1"></p>]]></content>
      
      
      <categories>
          
          <category> Others </category>
          
          <category> 博客搭建 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode  / 滑动窗口</title>
      <link href="/2020/08/10/LeetCode-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E9%97%AE%E9%A2%98/"/>
      <url>/2020/08/10/LeetCode-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="滑动窗口问题"><a href="#滑动窗口问题" class="headerlink" title="滑动窗口问题"></a>滑动窗口问题</h2><p><font size=6> 求解的是连续子集问题</font> </p><ul><li><blockquote><p>优秀博文：<a href="https://blog.csdn.net/qq_43152052/article/details/102840715" target="_blank" rel="noopener">https://blog.csdn.net/qq_43152052/article/details/102840715</a></p></blockquote></li><li><blockquote><p>①窗口由两个指针构成，一个左指针left，一个右指针right，然后[left,right]表示的索引范围是一个窗口了。</p></blockquote></li><li><blockquote><p>②右指针right的功能是用来扩展窗口：当窗口内的条件没有达到题目要求时，我们需要不断移动右指针right直到窗口内的条件第一次满足题目要求为止。</p></blockquote></li><li><blockquote><p>③左指针left的功能是用来缩小窗口的：当窗口内的条件已满足题目条件或多于题目条件时（窗口溢出），我们缩小窗口，也就是左指针left需要右移直到窗口条件不满足为止。这时，我们需要记录当前窗口的大小，并更新目前为止满足条件的最小窗口记录。之后，再次扩展右指针right，使得窗口满足题目的条件。</p></blockquote></li></ul><p><font size=6> 固定套路</font> </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> left = <span class="number">0</span>，res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> tiaojian = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//满足情况：扩大右指针</span></span><br><span class="line"><span class="comment">//不满足情况：移动左值针，缩小范围</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;arr.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="424-替换后的最长重复字符"><a href="#424-替换后的最长重复字符" class="headerlink" title="424.替换后的最长重复字符"></a>424.替换后的最长重复字符</h2><ul><li><blockquote><p>给你一个仅由大写英文字母组成的字符串，你可以将任意位置上的字符替换成另外的字符，总共可最多替换 k 次。在执行上述操作后，找到包含重复字母的最长子串的长度。</p></blockquote></li><li><blockquote><p>输入:</p></blockquote></li><li><p>s = “ABAB”, k = 2</p></li><li><p>输出:</p></li><li><p>4</p></li><li><blockquote><p>输入:</p></blockquote></li><li><p>s = “AABABBA”, k = 1</p></li><li><p>输出:</p></li><li><p>4</p></li><li><blockquote><p>解题：</p></blockquote></li></ul><ol><li>滑动窗口范围内的数字替换成<strong>区间内数最多的数</strong></li><li>所以定义变量maxNum为当前区间数量最多的那个数</li><li>当不满足情况的时候，左值针移动，利用辅助数组vector<int>ABC(26,0);</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">characterReplacement</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;vis(<span class="number">26</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">int</span> left = <span class="number">0</span>, res = <span class="number">0</span>, numSize = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//numSize当前窗口中数量最多的数    </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">vis[s[i] - <span class="string">'A'</span>]++;</span><br><span class="line">numSize = <span class="built_in">max</span>(vis[s[i] - <span class="string">'A'</span>], numSize);</span><br><span class="line"><span class="comment">//i - left + 1当前区间所有元素数量</span></span><br><span class="line"><span class="keyword">while</span> (i - left + <span class="number">1</span> - numSize &gt; k) &#123;</span><br><span class="line">vis[s[left] - <span class="string">'A'</span>]--;</span><br><span class="line">left++;</span><br><span class="line">&#125;</span><br><span class="line">res = <span class="built_in">max</span>(res, i - left + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3. 无重复字符的最长子串"></a>3. 无重复字符的最长子串</h2><ul><li><blockquote><p>给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。</p></blockquote></li><li><blockquote><p>输入: “abcabcbb”</p></blockquote></li><li><p>输出: 3 </p></li><li><p>解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。</p></li><li><blockquote><p>输入: “bbbbb”</p></blockquote></li><li><p>输出: 1</p></li><li><p>解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。</p></li><li><blockquote><p>解题：只有可能是新添加进来的那个数字，出现重复数字。</p></blockquote></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">characterReplacement</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;vis(<span class="number">26</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">int</span> left = <span class="number">0</span>, res = <span class="number">0</span>, numSize = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//numSize当前窗口中数量最多的数    </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">vis[s[i] - <span class="string">'A'</span>]++;</span><br><span class="line">numSize = <span class="built_in">max</span>(vis[s[i] - <span class="string">'A'</span>], numSize);</span><br><span class="line"><span class="comment">//i - left + 1当前区间所有元素数量</span></span><br><span class="line"><span class="keyword">while</span> (i - left + <span class="number">1</span> - numSize &gt; k) &#123;</span><br><span class="line">vis[s[left] - <span class="string">'A'</span>]--;</span><br><span class="line">left++;</span><br><span class="line">&#125;</span><br><span class="line">res = <span class="built_in">max</span>(res, i - left + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="76-最小覆盖子串-困难"><a href="#76-最小覆盖子串-困难" class="headerlink" title="76. 最小覆盖子串(困难)"></a>76. 最小覆盖子串(困难)</h2><ul><li><blockquote><p>给你一个字符串 S、一个字符串 T 。请你设计一种算法，可以在 O(n) 的时间复杂度内，从字符串 S 里面找出：包含 T 所有字符的最小子串。</p></blockquote></li><li><blockquote><p>输入：S = “ADOBECODEBANC”, T = “ABC”</p></blockquote></li><li><p>输出：”BANC”</p></li><li><blockquote><p>解题：滑动窗口</p></blockquote></li><li><p>需要判断的主要是满不满足T中的字符数量，使用vector<int>vis,和match来双重判断</p></li><li><p>满足数量match++</p></li><li><p>当产生数量变化match–</p></li><li><p>只有当vis[i] == vis[need]才进行match++，保证了match不会出现大于其max的情况</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">minWindow</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> left = <span class="number">0</span>, len = INT_MAX, leftres = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">string</span> resString;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;vis(<span class="number">256</span>, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;need(<span class="number">256</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it : t)</span><br><span class="line">vis[it]++;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> matchSuccess = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it : vis) &#123;</span><br><span class="line"><span class="keyword">if</span> (it != <span class="number">0</span>)</span><br><span class="line">matchSuccess++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> match = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line"><span class="keyword">char</span> tempR = s[i];</span><br><span class="line"><span class="keyword">if</span> (vis[tempR] &gt; <span class="number">0</span>) &#123;  <span class="comment">//这个数是需要的</span></span><br><span class="line">need[tempR]++;</span><br><span class="line"><span class="keyword">if</span> (need[tempR] == vis[tempR])</span><br><span class="line">match++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (match == matchSuccess) &#123;</span><br><span class="line"><span class="keyword">char</span> tempL = s[left];</span><br><span class="line"><span class="keyword">if</span> (vis[tempL] &lt;= <span class="number">0</span>)</span><br><span class="line">left++;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">need[tempL]--;</span><br><span class="line">left++;</span><br><span class="line"><span class="keyword">if</span> (need[tempL] &lt; vis[tempL]) &#123;<span class="comment">//match不匹配了需要恢复</span></span><br><span class="line">need[tempL]++;</span><br><span class="line">left--;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (match == matchSuccess &amp;&amp; i - left + <span class="number">1</span> &lt; len) &#123;</span><br><span class="line">leftres = left;</span><br><span class="line">len = i - left + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> len == INT_MAX ? <span class="string">""</span> : s.substr(leftres, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="239-滑动窗口最大值（时间复杂度要求）"><a href="#239-滑动窗口最大值（时间复杂度要求）" class="headerlink" title="239. 滑动窗口最大值（时间复杂度要求）"></a>239. 滑动窗口最大值（时间复杂度要求）</h2><ul><li><blockquote><p>给定一个数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。</p></blockquote></li><li><p>返回滑动窗口中的最大值。</p></li><li><blockquote><p>题目：</p></blockquote></li><li><p>输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3</p></li><li><p>输出: [3,3,5,5,6,7] </p></li><li><p>解释: </p></li><li><p>滑动窗口的位置       —–          最大值</p></li><li><p>[1  3  -1] -3  5  3  6  7     —–   3</p></li><li><p>1 [3  -1  -3] 5  3  6  7     —–   3</p></li><li><p>1  3 [-1  -3  5] 3  6  7     —–   5</p></li><li><p>1  3  -1 [-3  5  3] 6  7     —–   5</p></li><li><p>1  3  -1  -3 [5  3  6] 7     —–   6</p></li><li><p>1  3  -1  -3  5 [3  6  7]    —–   7</p></li><li><blockquote><p>解题：</p></blockquote></li><li><p>利用双向队列的堆栈特性</p></li><li><p>pop_back()\ pop_front() \ push_back()\ push_front()\ A.front()\ A.back()</p><ul><li>头部保存最大元素</li><li>利用<strong>存放元素下标</strong>来保证没有超出区间的范围</li><li>每次比较和尾部数据进行比较，从而保证前面节点：老元素。后面节点：新元素。这样可以完成上一条。</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> &#123;&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;res;</span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;<span class="built_in">deque</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//头部:max数据</span></span><br><span class="line"><span class="comment">//尾部比较，然后淘汰元素:保证了老元素前,新元素后</span></span><br><span class="line"><span class="comment">//元素下标,保证区间范围</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">deque</span>.empty() &amp;&amp; i - <span class="built_in">deque</span>.front() &gt;= k)</span><br><span class="line"><span class="built_in">deque</span>.pop_front();</span><br><span class="line"><span class="keyword">while</span> (!<span class="built_in">deque</span>.empty() &amp;&amp; nums[i] &gt; nums[<span class="built_in">deque</span>.back()])</span><br><span class="line"><span class="built_in">deque</span>.pop_back();</span><br><span class="line"><span class="comment">//这里忘记了</span></span><br><span class="line"><span class="built_in">deque</span>.push_back(i);</span><br><span class="line"><span class="comment">//这里忘记了</span></span><br><span class="line"><span class="keyword">if</span> (i - k + <span class="number">1</span> &gt;= <span class="number">0</span>)</span><br><span class="line">res.push_back(nums[<span class="built_in">deque</span>.front()]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="438-找到字符串中所有字母异位词（固定窗口）"><a href="#438-找到字符串中所有字母异位词（固定窗口）" class="headerlink" title="438. 找到字符串中所有字母异位词（固定窗口）"></a>438. 找到字符串中所有字母异位词（固定窗口）</h2><ul><li><blockquote><p>给定一个字符串 s 和一个非空字符串 p，找到 s 中所有是 p 的字母异位词的子串，返回这些子串的起始索引。</p></blockquote></li><li><p>字符串只包含小写英文字母，并且字符串 s 和 p 的长度都不超过 20100。</p></li></ul><ul><li><blockquote><p>题目：</p></blockquote></li><li><p>输入: s: “cbaebabacd” p: “abc”</p></li><li><p>输出: [0, 6]</p></li><li><p>输入:s: “abab” p: “ab”</p></li><li><p>[0, 1, 2]</p></li><li><blockquote><p>解题固定窗口，求是否满足</p></blockquote></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findAnagrams</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (p.<span class="built_in">size</span>() &gt; s.<span class="built_in">size</span>())</span><br><span class="line"><span class="keyword">return</span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//连续的子串</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;vis(<span class="number">256</span>, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;need(<span class="number">256</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;res;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it : p)</span><br><span class="line">vis[it]++;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> H = p.<span class="built_in">size</span>();</span><br><span class="line"><span class="comment">//固定长度的滑动窗口</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (i &lt; H) &#123;</span><br><span class="line">need[s[i]]++;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (vis == need)</span><br><span class="line">res.push_back(left);</span><br><span class="line"></span><br><span class="line">need[s[i]]++;</span><br><span class="line">need[s[left++]]--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (vis == need)</span><br><span class="line">res.push_back(left);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="480-滑动窗口中位数（困难—不会）"><a href="#480-滑动窗口中位数（困难—不会）" class="headerlink" title="480. 滑动窗口中位数（困难—不会）"></a>480. 滑动窗口中位数（困难—不会）</h2><ul><li><blockquote><p>中位数是有序序列最中间的那个数。如果序列的大小是偶数，则没有最中间的数；此时中位数是最中间的两个数的平均数。</p></blockquote></li><li><p>[2,3,4]，中位数是 3</p></li><li><p>[2,3]，中位数是 (2 + 3) / 2 = 2.5</p></li><li><p>给出 nums = [1,3,-1,-3,5,3,6,7]，以及 k = 3。</p></li></ul><ul><li><p>窗口位置                      中位数</p></li><li><p>[1  3  -1] -3  5  3  6  7   ————    1</p></li><li><p>1 [3  -1  -3] 5  3  6  7   ————    -1</p></li><li><p>1  3 [-1  -3  5] 3  6  7   ————    -1</p></li><li><p>1  3  -1 [-3  5  3] 6  7    ————    3</p></li><li><p>1  3  -1  -3 [5  3  6] 7    ————    5</p></li><li><p>1  3  -1  -3  5 [3  6  7]   ————    6</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; <span class="title">medianSlidingWindow</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> nums_size = nums.<span class="built_in">size</span>();</span><br><span class="line"><span class="function"><span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt; <span class="title">window</span><span class="params">(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">begin</span>() + k)</span></span>;</span><br><span class="line"><span class="comment">//mid即是high_p</span></span><br><span class="line"><span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt;::iterator mid = window.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k / <span class="number">2</span>; ++i)</span><br><span class="line">++mid;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; ans;</span><br><span class="line">ans.reserve(nums_size - k + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = k;; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (k % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt;::iterator low_p = prev(mid, <span class="number">1</span>);</span><br><span class="line">ans.push_back(((<span class="keyword">double</span>)*low_p + *mid) / <span class="number">2.0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">ans.push_back(*mid);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (i == nums_size)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">window.insert(nums.at(i));</span><br><span class="line"><span class="keyword">if</span> (nums.at(i) &lt; *mid)</span><br><span class="line">--mid;</span><br><span class="line"><span class="keyword">if</span> (nums.at(i - k) &lt;= *mid)</span><br><span class="line">++mid;</span><br><span class="line">window.erase(window.<span class="built_in">find</span>(nums.at(i - k)));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="567-字符串的排列（固定窗口—438一样）"><a href="#567-字符串的排列（固定窗口—438一样）" class="headerlink" title="567.字符串的排列（固定窗口—438一样）"></a>567.字符串的排列（固定窗口—438一样）</h2><ul><li><blockquote></blockquote></li><li><p>给定两个字符串 s1 和 s2，写一个函数来判断 s2 是否包含 s1 的排列。</p></li><li><p>换句话说，第一个字符串的排列之一是第二个字符串的子串。</p></li><li><blockquote><p>输入: s1 = “ab” s2 = “eidbaooo”</p></blockquote></li><li><p>输出: True</p></li><li><p>解释: s2 包含 s1 的排列之一 (“ba”).</p></li><li><blockquote><p>输入: s1= “ab” s2 = “eidboaoo”</p></blockquote></li><li><p>输出: False</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">checkInclusion</span><span class="params">(<span class="built_in">string</span> s1, <span class="built_in">string</span> s2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (s1.<span class="built_in">size</span>() &gt; s2.<span class="built_in">size</span>())</span><br><span class="line"><span class="keyword">return</span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//连续的子串</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;vis(<span class="number">256</span>, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;need(<span class="number">256</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it : s1)</span><br><span class="line">vis[it]++;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> H = s1.<span class="built_in">size</span>();</span><br><span class="line"><span class="comment">//固定长度的滑动窗口</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s2.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (i &lt; H) &#123;</span><br><span class="line">need[s2[i]]++;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (vis == need)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">need[s2[i]]++;</span><br><span class="line">need[s2[left++]]--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (vis == need)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="992-K个不同整数的子数组"><a href="#992-K个不同整数的子数组" class="headerlink" title="992. K个不同整数的子数组"></a>992. K个不同整数的子数组</h2><ul><li><blockquote><p>给定一个正整数数组 A，如果 A 的某个子数组中不同整数的个数恰好为 K，则称 A 的这个连续、不一定独立的子数组为好子数组。</p></blockquote></li><li><p>（例如，[1,2,3,1,2] 中有 3 个不同的整数：1，2，以及 3。）</p></li><li><p>返回 A 中好子数组的数目。</p></li><li><blockquote><p>输入：A = [1,2,1,2,3], K = 2</p></blockquote></li><li><p>输出：7</p></li><li><p>解释：恰好由 2 个不同整数组成的子数组：[1,2], [2,1], [1,2], [2,3], [1,2,1], [2,1,2], [1,2,1,2].</p></li><li><blockquote><p>输入：A = [1,2,1,3,4], K = 3</p></blockquote></li><li><p>输出：3</p></li><li><p>解释：恰好由 3 个不同整数组成的子数组：[1,2,1,3], [2,1,3], [1,3,4].</p></li><li><blockquote><p>采用unordered_map&lt;int,int&gt;来统计,</p></blockquote></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">subarraysWithKDistinct</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (K == <span class="number">0</span> || A.empty())</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;vis;</span><br><span class="line"><span class="keyword">int</span> left = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">vis[A[i]]++;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (vis.<span class="built_in">size</span>() &gt; K) &#123;</span><br><span class="line"><span class="keyword">if</span> (vis[A[left]] &gt; <span class="number">1</span>)</span><br><span class="line">vis[A[left]]--;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">vis.erase(A[left]);</span><br><span class="line"></span><br><span class="line">left++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> tempL = left;<span class="comment">//当前的左指针位置,然后右移看子集有没有满足要求的</span></span><br><span class="line"><span class="keyword">while</span> (vis.<span class="built_in">size</span>() == K) &#123;</span><br><span class="line">res++;</span><br><span class="line"><span class="keyword">if</span> (vis[A[left]] &gt; <span class="number">1</span>)</span><br><span class="line">vis[A[left]]--;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">vis.erase(A[left]);</span><br><span class="line"></span><br><span class="line">left++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//还原</span></span><br><span class="line"><span class="keyword">while</span> (left &gt; tempL) &#123;</span><br><span class="line"></span><br><span class="line">vis[A[left - <span class="number">1</span>]]++;</span><br><span class="line">left--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="995-K-连续位的最小翻转次数（类似翻金币）（困难不会）"><a href="#995-K-连续位的最小翻转次数（类似翻金币）（困难不会）" class="headerlink" title="995. K 连续位的最小翻转次数（类似翻金币）（困难不会）"></a>995. K 连续位的最小翻转次数（类似翻金币）（困难不会）</h2><ul><li><blockquote><p>在仅包含 0 和 1 的数组 A 中，一次 K 位翻转包括选择一个长度为 K 的（连续）子数组，同时将子数组中的每个 0 更改为 1，而每个 1 更改为 0。</p></blockquote></li><li><p>返回所需的 K 位翻转的次数，以便数组没有值为 0 的元素。如果不可能，返回 -1。</p></li><li><blockquote><p>输入：A = [0,1,0], K = 1</p></blockquote></li><li><p>输出：2</p></li><li><p>解释：先翻转 A[0]，然后翻转 A[2]。</p></li></ul><ul><li><blockquote><p>输入：A = [1,1,0], K = 2</p></blockquote></li><li><p>输出：-1</p></li><li><p>解释：无论我们怎样翻转大小为 2 的子数组，我们都不能使数组变为 [1,1,1]。</p></li><li><blockquote><p>输入：A = [0,0,0,1,0,1,1,0], K = 3</p></blockquote></li><li><p>输出：3</p></li><li><p>解释：</p></li><li><p>翻转 A[0],A[1],A[2]: A变成 [1,1,1,1,0,1,1,0]</p></li><li><p>翻转 A[4],A[5],A[6]: A变成 [1,1,1,1,1,0,0,0]</p></li><li><p>翻转 A[5],A[6],A[7]: A变成 [1,1,1,1,1,1,1,1]</p></li><li><blockquote><p>利用队列</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minKBitFlips</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (A.empty())<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> result = <span class="number">0</span>, N = A.<span class="built_in">size</span>();</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; window;<span class="comment">//window用来存放被反转元素的下标，window的长度表示反转的次数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//当下标之间的距离大于k时，需要移除队头下标了</span></span><br><span class="line"><span class="keyword">while</span> (!window.empty() &amp;&amp; window.front() + K &lt;= i)</span><br><span class="line">window.pop();</span><br><span class="line"></span><br><span class="line"><span class="comment">//当前位置的1反转奇数次为0，需要反转；当前位置的0反转偶数次还是为0，还是需要反转</span></span><br><span class="line"><span class="keyword">if</span> (A[i] == window.<span class="built_in">size</span>() % <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (i + K &gt; N)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">window.push(i);</span><br><span class="line">result++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="978-最长湍流子数组"><a href="#978-最长湍流子数组" class="headerlink" title="978. 最长湍流子数组"></a>978. 最长湍流子数组</h2><ul><li><blockquote><p>数组的形式是升降升降升，这种形式</p></blockquote></li><li><blockquote><p>输入：[9,4,2,10,7,8,8,1,9]</p></blockquote></li><li><p>输出：5</p></li><li><p>解释：(A[1] &gt; A[2] &lt; A[3] &gt; A[4] &lt; A[5])</p></li><li><blockquote><p>题解：compare前后数据——遍历一遍数组</p></blockquote></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span> A, <span class="keyword">int</span> B)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (A &gt; B) ? <span class="number">1</span> : (A == B) ? <span class="number">0</span> : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxTurbulenceSize</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (A.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; A.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line"><span class="keyword">int</span> flag = compare(A[i - <span class="number">1</span>], A[i]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (i == A.<span class="built_in">size</span>() - <span class="number">1</span> || flag * compare(A[i], A[i + <span class="number">1</span>]) != <span class="number">-1</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (flag != <span class="number">0</span>)res = <span class="built_in">max</span>(res, i - left + <span class="number">1</span>);</span><br><span class="line">left = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><ul><li><a href="https://blog.csdn.net/qq_43152052/article/details/102840715" target="_blank" rel="noopener">https://blog.csdn.net/qq_43152052/article/details/102840715</a><h2 id="1040-移动石子直到连续Ⅱ"><a href="#1040-移动石子直到连续Ⅱ" class="headerlink" title="1040.移动石子直到连续Ⅱ"></a>1040.移动石子直到连续Ⅱ</h2></li><li><blockquote></blockquote></li></ul><hr><h2 id="1052-爱生气的书店老板"><a href="#1052-爱生气的书店老板" class="headerlink" title="1052.爱生气的书店老板"></a>1052.爱生气的书店老板</h2><ul><li><blockquote></blockquote></li></ul><hr><h2 id="1074-元素和为目标值的子矩阵数量"><a href="#1074-元素和为目标值的子矩阵数量" class="headerlink" title="1074.元素和为目标值的子矩阵数量"></a>1074.元素和为目标值的子矩阵数量</h2><ul><li><blockquote></blockquote></li></ul><hr><h2 id="1208-尽可能使字符串相等"><a href="#1208-尽可能使字符串相等" class="headerlink" title="1208.尽可能使字符串相等"></a>1208.尽可能使字符串相等</h2><ul><li><blockquote></blockquote></li></ul><hr><h2 id="56-合并区间（重要）"><a href="#56-合并区间（重要）" class="headerlink" title="56.合并区间（重要）"></a>56.合并区间（重要）</h2><ul><li><blockquote><p>给出一个区间的集合，请合并所有重叠的区间。</p></blockquote></li><li>输入: intervals = [[1,3],[2,6],[8,10],[15,18]]</li><li>输出: [[1,6],[8,10],[15,18]]</li><li>解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (arr.<span class="built_in">size</span>() &lt;= <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> arr;</span><br><span class="line"><span class="comment">//排序</span></span><br><span class="line">sort(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>());</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;res;</span><br><span class="line"><span class="keyword">int</span> len = arr.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">int</span> L = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> R = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (R &lt; len) &#123;</span><br><span class="line"><span class="keyword">if</span> (arr[L][<span class="number">1</span>] &gt;= arr[R][<span class="number">1</span>]) &#123;</span><br><span class="line">R++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (arr[L][<span class="number">1</span>] &lt; arr[R][<span class="number">0</span>])&#123;</span><br><span class="line">res.push_back(arr[L]);</span><br><span class="line">L = R;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">arr[L][<span class="number">1</span>] = arr[R][<span class="number">1</span>];</span><br><span class="line">R++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">res.push_back(arr[L]);<span class="comment">//添加最后元素</span></span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="11-盛最多的水"><a href="#11-盛最多的水" class="headerlink" title="11.盛最多的水"></a>11.盛最多的水</h2><p><img src="/pictures/clipboard115.png" alt="img"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; <span class="built_in">height</span>)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">height</span>.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">int</span> L = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> R = len - <span class="number">1</span>;</span><br><span class="line"><span class="comment">//消状态这点讲的很好，其实质就是在移动的过程中不断消去不可能成为最大值的状态。！</span></span><br><span class="line"><span class="comment">//当 i = j 都只能减小，所以随便往哪边动都是减小</span></span><br><span class="line"><span class="comment">//i &gt; j,移动只能减小或者不变，所以移动j可能增加面积</span></span><br><span class="line"><span class="comment">//尽可能的去增加面积</span></span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (L &lt; R) &#123;</span><br><span class="line"><span class="keyword">int</span> h = <span class="built_in">min</span>(<span class="built_in">height</span>[L], <span class="built_in">height</span>[R]);</span><br><span class="line">res = <span class="built_in">max</span>(h *(R - L), res);</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">height</span>[L] &gt;= <span class="built_in">height</span>[R])</span><br><span class="line">R--;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">L++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="腾讯面试题"><a href="#腾讯面试题" class="headerlink" title="腾讯面试题"></a>腾讯面试题</h2><hr><h2 id="11-盛最多的水-1"><a href="#11-盛最多的水-1" class="headerlink" title="11.盛最多的水"></a>11.盛最多的水</h2><ul><li><p><a href="https://www.nowcoder.com/discuss/488619" target="_blank" rel="noopener">https://www.nowcoder.com/discuss/488619</a></p></li><li><blockquote><p>题目：</p></blockquote></li><li><p>小Q在进行射击气球的游戏，如果小Q在连续T枪中打爆了所有颜色的气球，将得到一只QQ公仔作为奖励。（每种颜色的气球至少被打爆一只）。这个游戏中有m种不同颜色的气球，编号1到m。小Q一共有n发子弹，然后连续开了n枪。小Q想知道在这n枪中，打爆所有颜色的气球最少用了连续几枪？</p></li><li><p>输入描述：一个整数表示小Q打爆所有颜色气球用的最少枪数。如果小Q无法在这n枪打爆所有颜色的气球，则输出-1</p></li><li><p>例子：</p></li><li><blockquote><p>输入：</p></blockquote></li><li><p>12 5</p></li><li><p>2 5 3 1 3 2 4 1 0 5 4 3</p></li><li><blockquote><p>输出：</p></blockquote></li><li><p>6</p></li><li><blockquote><p>解题：</p></blockquote></li><li><p>1.暴力O(n^2)</p></li><li><p>2.滑动窗口O(n^2)</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//输入12 和 5</span></span><br><span class="line"><span class="keyword">int</span> index = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;arr&#123; <span class="number">0</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> res = <span class="number">9999</span>;</span><br><span class="line"><span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;vis(index + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">vis[arr[i]]++;</span><br><span class="line"><span class="keyword">if</span> (vis[arr[i]] == <span class="number">1</span>) &#123;</span><br><span class="line">cnt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//cout &lt;&lt; "i:"&lt;&lt;i &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; "cnt:" &lt;&lt; cnt &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(cnt == vis.<span class="built_in">size</span>()) &#123;</span><br><span class="line"><span class="keyword">while</span> (cnt == vis.<span class="built_in">size</span>()) &#123;</span><br><span class="line"><span class="keyword">int</span> numtemp = arr[left];</span><br><span class="line">vis[numtemp]--;</span><br><span class="line">left++;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (vis[numtemp] == <span class="number">0</span>)</span><br><span class="line">cnt--;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">left--;</span><br><span class="line">vis[arr[left]]++;</span><br><span class="line">cnt++;</span><br><span class="line">res = <span class="built_in">min</span>(res, i - left + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; res;</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
          <category> 滑动窗口问题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode  / 树、链表专题</title>
      <link href="/2020/08/08/LeetCode-%E6%A0%91%E3%80%81%E9%93%BE%E8%A1%A8%E4%B8%93%E9%A2%98/"/>
      <url>/2020/08/08/LeetCode-%E6%A0%91%E3%80%81%E9%93%BE%E8%A1%A8%E4%B8%93%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Definition for singly-linked list.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> val;</span><br><span class="line">ListNode *next;</span><br><span class="line">ListNode(<span class="keyword">int</span> x) : val(x), next(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="LC-206-反转链表（最基础的）"><a href="#LC-206-反转链表（最基础的）" class="headerlink" title="LC_206.反转链表（最基础的）"></a>LC_206.反转链表（最基础的）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.递归</span></span><br><span class="line"><span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">ListNode* temp = head-&gt;next;</span><br><span class="line">ListNode* res = reverseList(temp);<span class="comment">//找到最后一个节点,返回head</span></span><br><span class="line"></span><br><span class="line">temp-&gt;next = head;</span><br><span class="line">head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//2.辅助双指针</span></span><br><span class="line"><span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">ListNode* pre = <span class="literal">NULL</span>;</span><br><span class="line">ListNode* next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (head) &#123;</span><br><span class="line">next = head-&gt;next;</span><br><span class="line">head-&gt;next = pre;</span><br><span class="line">pre = head;</span><br><span class="line">head = next;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="LC-92-反转链表，第N到M个节点"><a href="#LC-92-反转链表，第N到M个节点" class="headerlink" title="LC_92.反转链表，第N到M个节点"></a>LC_92.反转链表，第N到M个节点</h3><ul><li><blockquote><p>1.哨兵节点，定位pre、cur节点</p></blockquote></li><li><p>2.开始反转</p></li><li><blockquote><p>辅助节点<strong>pre、cur是不会变化的</strong>，<strong>next节点不断前移</strong><br><img src="/pictures/clipboard129.png" alt="img"></p></blockquote></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">reverseBetween</span><span class="params">(ListNode* head, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="comment">//哨兵节点</span></span><br><span class="line">ListNode* returnNode = <span class="keyword">new</span> ListNode(<span class="number">999</span>);</span><br><span class="line">returnNode-&gt;next = head;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定位pre节点</span></span><br><span class="line">ListNode* pre = returnNode;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m - <span class="number">1</span>; i++)</span><br><span class="line">pre = pre-&gt;next;</span><br><span class="line"></span><br><span class="line"><span class="comment">//辅助双节点</span></span><br><span class="line">ListNode* cur = pre-&gt;next;</span><br><span class="line">ListNode* next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - m; i++) &#123;</span><br><span class="line">next = cur-&gt;next;</span><br><span class="line">cur-&gt;next = next-&gt;next;</span><br><span class="line">next-&gt;next = pre-&gt;next;</span><br><span class="line">pre-&gt;next = next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> returnNode-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="LC-24-反转链表（相邻节点）"><a href="#LC-24-反转链表（相邻节点）" class="headerlink" title="LC_24.反转链表（相邻节点）"></a>LC_24.反转链表（相邻节点）</h3><ul><li><blockquote><p>反转链表：</p></blockquote></li><li><p>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。</p></li><li><p>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p></li><li><blockquote><p>案列：- 给定 1-&gt;2-&gt;3-&gt;4, 你应该返回 2-&gt;1-&gt;4-&gt;3.<br><img src="/pictures/clipboard130.png" alt="img"></p></blockquote></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">ListNode* returnNode = <span class="keyword">new</span> ListNode(<span class="number">999</span>);</span><br><span class="line">returnNode-&gt;next = head;</span><br><span class="line"></span><br><span class="line">ListNode* cur = returnNode;</span><br><span class="line"><span class="keyword">while</span> (cur-&gt;next &amp;&amp; cur-&gt;next-&gt;next) &#123;</span><br><span class="line">ListNode* first = cur-&gt;next;</span><br><span class="line">ListNode* second = cur-&gt;next-&gt;next;</span><br><span class="line"></span><br><span class="line"><span class="comment">//依次改变节点</span></span><br><span class="line">cur-&gt;next = second;</span><br><span class="line">first-&gt;next = second-&gt;next;</span><br><span class="line">second-&gt;next = first;</span><br><span class="line"></span><br><span class="line"><span class="comment">//更新cur节点,注意:first和second节点位置,已经发生了变化,只能在原节点的基础上进行修改</span></span><br><span class="line">cur = cur-&gt;next-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> returnNode-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="LC-148-无序链表排序-归并实现"><a href="#LC-148-无序链表排序-归并实现" class="headerlink" title="LC_148.无序链表排序(归并实现)"></a>LC_148.无序链表排序(归并实现)</h3><ul><li><blockquote><p>时间复杂度O（nlogn）</p></blockquote></li><li>归并排序：递归，需要额外空间复杂度</li></ul><ol><li>快慢指针、找到中心节点，进行切断</li><li>cut-&gt;next = NULL;同时先分割再合并</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function">ListNode* <span class="title">sortList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!head || !head-&gt;next) <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line"><span class="comment">//分割链表、快慢指针找出中点</span></span><br><span class="line">ListNode *middle = findMiddle(head);</span><br><span class="line"></span><br><span class="line">ListNode* L = sortList(head);</span><br><span class="line">ListNode* R = sortList(middle);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> mergeSort(L, R); <span class="comment">//采用归并排序有序链表、递归方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//找到中间位置</span></span><br><span class="line"><span class="function">ListNode *<span class="title">findMiddle</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">ListNode *fast = head, *slow = head;</span><br><span class="line">ListNode *cut;</span><br><span class="line"><span class="keyword">while</span> (fast &amp;&amp; fast-&gt;next)</span><br><span class="line">&#123;</span><br><span class="line">cut = slow;<span class="comment">//////重要</span></span><br><span class="line">slow = slow-&gt;next;</span><br><span class="line">fast = fast-&gt;next-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">cut-&gt;next = <span class="literal">NULL</span>; <span class="comment">// 这一步很重要！需要把前半部分和后半部分断开</span></span><br><span class="line"><span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//两个链表进行比较合并</span></span><br><span class="line"><span class="function">ListNode *<span class="title">mergeSort</span><span class="params">(ListNode *head, ListNode *mid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ListNode *returnNode = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">ListNode *pos = returnNode;</span><br><span class="line"><span class="keyword">while</span> (head &amp;&amp; mid)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (head-&gt;val &lt; mid-&gt;val)&#123;</span><br><span class="line">pos-&gt;next = head;</span><br><span class="line">head = head-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">pos-&gt;next = mid;</span><br><span class="line">mid = mid-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">pos = pos-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (head != <span class="literal">NULL</span>)</span><br><span class="line">pos-&gt;next = head;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">pos-&gt;next = mid;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> returnNode-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><blockquote><p>时间复杂度O（nlogn），额外空间复杂度O（1）</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Definition for singly-linked list.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> val;</span><br><span class="line">ListNode *next;</span><br><span class="line">ListNode(<span class="keyword">int</span> x) : val(x), next(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="两个链表是否有交点"><a href="#两个链表是否有交点" class="headerlink" title="两个链表是否有交点"></a>两个链表是否有交点</h3><ul><li><blockquote><p>解法：</p></blockquote><ul><li>1.都不是环形（走A+C+B = B+C+A）</li><li>2.一个环一个不是环（无交点）</li><li>3.都是环（快慢指针分别找到一个随机点p1、p2。p1往前走能遇到p2有交点）</li></ul></li></ul><hr><h3 id="LC-83-排序链表删除重复节点-保留一个"><a href="#LC-83-排序链表删除重复节点-保留一个" class="headerlink" title="LC_83.排序链表删除重复节点 / 保留一个"></a>LC_83.排序链表删除重复节点 / 保留一个</h3><ul><li><blockquote><p>给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。</p></blockquote></li><li><blockquote><p>输入: 1-&gt;1-&gt;2</p></blockquote></li><li><p>输出: 1-&gt;2</p></li><li><blockquote><p>输入: 1-&gt;1-&gt;2-&gt;3-&gt;3</p></blockquote></li><li><p>输出: 1-&gt;2-&gt;3</p></li><li><blockquote><p>解：关键是要删除节点</p></blockquote></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注意需要删除节点</span></span><br><span class="line">ListNode* cur = head;</span><br><span class="line"><span class="keyword">while</span> (cur &amp;&amp; cur-&gt;next) &#123;</span><br><span class="line"><span class="keyword">if</span> (cur-&gt;val == cur-&gt;next-&gt;val) &#123;</span><br><span class="line">ListNode* temp = cur-&gt;next;</span><br><span class="line">cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line"><span class="keyword">delete</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">cur = cur-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="LC-82-排序链表删除重复节点-不保留"><a href="#LC-82-排序链表删除重复节点-不保留" class="headerlink" title="LC_82.排序链表删除重复节点 / 不保留"></a>LC_82.排序链表删除重复节点 / 不保留</h3><ul><li><blockquote><p>给定一个排序链表，删除所有含有重复数字的节点，只保留原始链表中 没有重复出现 的数字。</p></blockquote></li><li><blockquote><p>输入: 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5</p></blockquote></li><li><p>输出: 1-&gt;2-&gt;5</p></li><li><blockquote><p>输入: 1-&gt;1-&gt;1-&gt;2-&gt;3</p></blockquote></li><li><p>输出: 2-&gt;3</p></li><li><blockquote><p>题解：<br><img src="/pictures/clipboard131.png" alt="img"></p></blockquote></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line"><span class="comment">//哨兵节点</span></span><br><span class="line">ListNode *returnNode = <span class="keyword">new</span> ListNode(<span class="number">9999</span>);</span><br><span class="line">returnNode-&gt;next = head;</span><br><span class="line"></span><br><span class="line">ListNode *cur = returnNode;</span><br><span class="line"><span class="keyword">while</span> (cur &amp;&amp; cur-&gt;next) &#123;</span><br><span class="line">ListNode *first = cur-&gt;next;</span><br><span class="line">ListNode *second = cur-&gt;next-&gt;next;</span><br><span class="line"><span class="comment">//1.还剩一个节点 或 2.first!=second  满足条件,后移cur指针</span></span><br><span class="line"><span class="keyword">if</span> (second == <span class="literal">NULL</span> || first-&gt;val != second-&gt;val)</span><br><span class="line">cur = cur-&gt;next;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//持续排除连续的节点,找到1223中的后面一个2节点位置</span></span><br><span class="line"><span class="comment">//都用first来写,second节点会发生变化</span></span><br><span class="line"><span class="keyword">while</span> (first-&gt;next &amp;&amp; first-&gt;val == first-&gt;next-&gt;val)</span><br><span class="line">first = first-&gt;next;</span><br><span class="line"></span><br><span class="line"><span class="comment">//舍去这部分重复的</span></span><br><span class="line">cur-&gt;next = first-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> returnNode-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="LC-19-删除链表的倒数第N个节点-快慢指针"><a href="#LC-19-删除链表的倒数第N个节点-快慢指针" class="headerlink" title="LC_19.删除链表的倒数第N个节点(快慢指针)"></a>LC_19.删除链表的倒数第N个节点(快慢指针)</h3><ul><li><blockquote><p>给定一个排序链表，删除所有含有重复数字的节点，只保留原始链表中 没有重复出现 的数字。</p></blockquote></li><li><blockquote><p>解：</p></blockquote></li><li>快慢指针实现：注意的是while(fast-&gt;next)</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">ListNode* fast = head;</span><br><span class="line">ListNode* slow = head;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">fast = fast-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//fast==NULL，说明删除的是第一个节点，防止下面fast-&gt;next不存在,</span></span><br><span class="line"><span class="keyword">if</span> (fast == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> head-&gt;next;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (fast-&gt;next) &#123;</span><br><span class="line">fast = fast-&gt;next;</span><br><span class="line">slow = slow-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">slow-&gt;next = slow-&gt;next-&gt;next;</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="LC-2-两数相加"><a href="#LC-2-两数相加" class="headerlink" title="LC_2.两数相加"></a>LC_2.两数相加</h3><ul><li><blockquote><p>输入：L1：(2 -&gt; 4 -&gt; 3) + L2：(5 -&gt; 6 -&gt; 4)</p></blockquote></li><li>输出：7 -&gt; 0 -&gt; 8</li><li>原因：342 + 465 = 807</li><li>有点类似归并，一个一个接上去</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">ListNode* head = <span class="keyword">new</span> ListNode(<span class="number">1</span>);<span class="comment">//头节点,用于保存第一个节点信息</span></span><br><span class="line">ListNode* res = head;<span class="comment">//移动节点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> carry = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">while</span> (l1 || l2) &#123;</span><br><span class="line">sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (l1) &#123;</span><br><span class="line">sum += l1-&gt;val;</span><br><span class="line">l1 = l1-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (l2) &#123;</span><br><span class="line">sum += l2-&gt;val;</span><br><span class="line">l2 = l2-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (carry)</span><br><span class="line">sum++;</span><br><span class="line">res-&gt;next = <span class="keyword">new</span> ListNode(sum % <span class="number">10</span>);</span><br><span class="line">res = res-&gt;next;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (sum &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">carry = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">carry = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (carry)</span><br><span class="line">res-&gt;next = <span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> head-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="LC-25-K-个一组翻转链表"><a href="#LC-25-K-个一组翻转链表" class="headerlink" title="LC_25. K 个一组翻转链表"></a>LC_25. K 个一组翻转链表</h3><ul><li><blockquote><p>给你这个链表：1-&gt;2-&gt;3-&gt;4-&gt;5</p></blockquote></li><li>当 k = 2 时，应当返回: 2-&gt;1-&gt;4-&gt;3-&gt;5</li><li>当 k = 3 时，应当返回: 3-&gt;2-&gt;1-&gt;4-&gt;5</li></ul><p><img src="/pictures/clipboard138.png" alt="img"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">reverseKGroup</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">ListNode* returnNode = <span class="keyword">new</span> ListNode(<span class="number">999</span>);</span><br><span class="line">returnNode-&gt;next = head;</span><br><span class="line"></span><br><span class="line">ListNode* pre = returnNode;</span><br><span class="line">ListNode* <span class="built_in">end</span> = returnNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">end</span> != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k&amp;&amp;<span class="built_in">end</span> != <span class="literal">NULL</span>; i++)<span class="built_in">end</span> = <span class="built_in">end</span>-&gt;next;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">end</span> == <span class="literal">NULL</span>)<span class="keyword">break</span>;</span><br><span class="line"><span class="comment">//保存开始节点、下一开始节点</span></span><br><span class="line">ListNode* tempF = pre-&gt;next;</span><br><span class="line">ListNode* nextStart = <span class="built_in">end</span>-&gt;next;</span><br><span class="line"></span><br><span class="line"><span class="comment">//断开</span></span><br><span class="line"><span class="built_in">end</span>-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">//开始反转</span></span><br><span class="line">pre-&gt;next = reverse(tempF);</span><br><span class="line"><span class="comment">//然后接上</span></span><br><span class="line">tempF-&gt;next = nextStart;</span><br><span class="line"></span><br><span class="line"><span class="comment">//更新数据</span></span><br><span class="line">pre = tempF;</span><br><span class="line"><span class="built_in">end</span> = pre;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> returnNode-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode* <span class="title">reverse</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (head == <span class="literal">NULL</span> &amp;&amp; head-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">ListNode* pre = <span class="literal">NULL</span>;</span><br><span class="line">ListNode* next = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">while</span> (head) &#123;</span><br><span class="line">next = head-&gt;next;</span><br><span class="line">head-&gt;next = pre;</span><br><span class="line">pre = head;</span><br><span class="line">head = next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="LC-61-指定向右移动链表-K"><a href="#LC-61-指定向右移动链表-K" class="headerlink" title="LC_61.指定向右移动链表 K"></a>LC_61.指定向右移动链表 K</h3><ul><li><blockquote><p>给定一个链表，旋转链表，将链表每个节点向右移动 k 个位置，其中 k 是非负数。</p></blockquote></li><li>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, k = 2</li><li>输出: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL</li><li>解释:</li><li>向右旋转 1 步: 5-&gt;1-&gt;2-&gt;3-&gt;4-&gt;NULL</li><li>向右旋转 2 步: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">rotateRight</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!head || !head-&gt;next || k == <span class="number">0</span>) <span class="keyword">return</span> head;</span><br><span class="line">ListNode *vis = head;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">size</span> = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//统计链表长度</span></span><br><span class="line"><span class="keyword">while</span> (vis &amp;&amp; vis-&gt;next) &#123;</span><br><span class="line">vis = vis-&gt;next;</span><br><span class="line"><span class="built_in">size</span>++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//移动为整数倍,直接返回</span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">move</span> = k % <span class="built_in">size</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">move</span> == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line"><span class="comment">//移动不为整数倍,成环再返回</span></span><br><span class="line">ListNode *cut = head;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span> - <span class="built_in">move</span> - <span class="number">1</span>; i++)</span><br><span class="line">cut = cut-&gt;next;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在此断开</span></span><br><span class="line">ListNode *res = cut-&gt;next;</span><br><span class="line"></span><br><span class="line">cut-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">vis-&gt;next = head;<span class="comment">//尾部节点接上头</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="LC-138-J-35-复制带随机指针的链表"><a href="#LC-138-J-35-复制带随机指针的链表" class="headerlink" title="LC_138 / J_35. 复制带随机指针的链表"></a>LC_138 / J_35. 复制带随机指针的链表</h3><ul><li><blockquote><p>输入</p></blockquote></li></ul><p><a href="https://zuizichuan.cn/2020/07/20/jianzhioffer2/#35-%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E6%B7%B1%E6%8B%B7%E8%B4%9D"><font size=5> 剑指Offer_35 </font></a> </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//深拷贝：复制对象 浅拷贝：复制对象的指针</span></span><br><span class="line"><span class="function">Node* <span class="title">copyRandomList</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (head == <span class="literal">NULL</span>)<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">//原地复制链表,且仅将next指针连接起来，例如A-&gt;B-&gt;C变成A-&gt;A'-&gt;B-&gt;B'-&gt;C-&gt;C'</span></span><br><span class="line">Node* cur = head;</span><br><span class="line"><span class="keyword">while</span> (cur) &#123;</span><br><span class="line">Node* newNode = <span class="keyword">new</span> Node(cur-&gt;val);</span><br><span class="line">newNode-&gt;next = cur-&gt;next;</span><br><span class="line">cur-&gt;next = newNode;</span><br><span class="line">cur = newNode-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">cur = head;<span class="comment">//cur指针复位</span></span><br><span class="line"><span class="comment">//第二步复制random指针，A'、B'、C'指到对应的位置</span></span><br><span class="line"><span class="keyword">while</span> (cur) &#123;</span><br><span class="line"><span class="keyword">if</span> (cur-&gt;<span class="built_in">random</span>) cur-&gt;next-&gt;<span class="built_in">random</span> = cur-&gt;<span class="built_in">random</span>-&gt;next;</span><br><span class="line">cur = cur-&gt;next-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//第三步将链表断开，例如A-&gt;A'-&gt;B-&gt;B'-&gt;C-&gt;C'变为A'-&gt;B'-&gt;C',且注意这一步应当将原链表复原。</span></span><br><span class="line">Node* returnhead = head-&gt;next;<span class="comment">//A',返回的节点</span></span><br><span class="line"></span><br><span class="line">Node* copycur = head-&gt;next;   <span class="comment">//A'</span></span><br><span class="line">cur = head; <span class="comment">//A</span></span><br><span class="line"><span class="keyword">while</span> (cur) &#123;</span><br><span class="line">cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">cur = cur-&gt;next;</span><br><span class="line"><span class="keyword">if</span> (copycur-&gt;next) &#123;</span><br><span class="line">copycur-&gt;next = copycur-&gt;next-&gt;next;</span><br><span class="line">copycur = copycur-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> returnhead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span><span class="comment">//这是二叉树的节点</span></span><br><span class="line">Node* left;</span><br><span class="line">Node* right;</span><br><span class="line"><span class="keyword">int</span> value;</span><br><span class="line">Node(<span class="keyword">int</span> val) :value(val), left(<span class="literal">NULL</span>), right(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="1-二叉树的层序、先序、中序、后续"><a href="#1-二叉树的层序、先序、中序、后续" class="headerlink" title="1.二叉树的层序、先序、中序、后续"></a>1.二叉树的层序、先序、中序、后续</h3><h4 id="1-1层序"><a href="#1-1层序" class="headerlink" title="1.1层序"></a>1.1层序</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cal</span><span class="params">(Node* root, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;res)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">queue</span>&lt;Node*&gt;q;</span><br><span class="line">q.push(root);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">size</span> = q.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span>; i++) &#123;</span><br><span class="line">Node* temp = q.front();</span><br><span class="line">q.pop();</span><br><span class="line">res.push_back(temp-&gt;value);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (temp-&gt;left)q.push(temp-&gt;left);</span><br><span class="line"><span class="keyword">if</span> (temp-&gt;right)q.push(temp-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><blockquote><p>第二种序列化时用：加入#</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">cal</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span>  <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> out;</span><br><span class="line"><span class="built_in">queue</span>&lt;Node*&gt;q;</span><br><span class="line">q.push(root);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">size</span> = q.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span>; i++) &#123;</span><br><span class="line">Node* temp = q.front();</span><br><span class="line">q.pop();</span><br><span class="line"><span class="keyword">if</span> (temp) &#123;</span><br><span class="line">out += to_string(temp-&gt;value) + <span class="string">" "</span>;</span><br><span class="line">q.push(temp-&gt;left);</span><br><span class="line">q.push(temp-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">out += <span class="string">"# "</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="1-2先序"><a href="#1-2先序" class="headerlink" title="1.2先序"></a>1.2先序</h4><ul><li><blockquote><p>中、左、右</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; root-&gt;value;</span><br><span class="line">preOrder(root-&gt;left);</span><br><span class="line">preOrder(root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><ul><li><blockquote><p>利用stack特性来做</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">oid <span class="title">preorder</span><span class="params">(Node* head)</span> </span>&#123;<span class="comment">//先序遍历</span></span><br><span class="line"><span class="keyword">if</span> (head == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">stack</span>&lt;Node*&gt;q;</span><br><span class="line">q.push(head);    <span class="comment">//利用栈的特性，先进右孩子   </span></span><br><span class="line"><span class="keyword">while</span> (!q.empty())</span><br><span class="line">&#123;</span><br><span class="line">head = q.top();</span><br><span class="line">q.pop();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; head-&gt;value &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"><span class="comment">//先进右孩子，stack后输出右孩子</span></span><br><span class="line"><span class="keyword">if</span> (head-&gt;right)q.push(head-&gt;right);</span><br><span class="line"><span class="keyword">if</span> (head-&gt;left)q.push(head-&gt;left);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="1-3中序"><a href="#1-3中序" class="headerlink" title="1.3中序"></a>1.3中序</h4><ul><li><blockquote><p>左、中、右</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">inOrder(root-&gt;left);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; root-&gt;value;</span><br><span class="line">inOrder(root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><ul><li><blockquote><p>利用栈特性来做</p></blockquote><ul><li>一直延申指向左孩子，同时存入元素</li><li>当左孩子为空，输出，同时指向右孩子<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inorder</span><span class="params">(Node* head)</span><span class="comment">//中序遍历</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (head == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">stack</span> &lt;Node*&gt;q;</span><br><span class="line"><span class="keyword">while</span> (!q.empty() || head != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (head != <span class="literal">NULL</span>) &#123;</span><br><span class="line">q.push(head);</span><br><span class="line">head = head-&gt;left;<span class="comment">//如果一直不空，就一直指向左孩子 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">head = q.top();</span><br><span class="line">q.pop();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; head-&gt;value &lt;&lt; <span class="string">" "</span>; <span class="comment">//如果为空，输出，同时指针指向右孩子</span></span><br><span class="line">head = head-&gt;right;        </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><hr><h4 id="1-4后序"><a href="#1-4后序" class="headerlink" title="1.4后序"></a>1.4后序</h4><ul><li><blockquote><p>利用先序和两个栈来实现</p></blockquote></li><li><blockquote><p>左、右、中</p></blockquote><ul><li>类似前序，前序：中左右，所以先进右</li><li>后序：左右中，所以先形成<strong>中右左</strong>，然后利用stack反向打印，就变成了<strong>左右中</strong><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterOrder</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">afterOrder(root-&gt;left);</span><br><span class="line">afterOrder(root-&gt;right);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; root-&gt;value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><hr><ul><li><blockquote><p>利用栈特性来做</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (head == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">stack</span>&lt;Node*&gt;arr;</span><br><span class="line"><span class="built_in">stack</span>&lt;Node*&gt;q;</span><br><span class="line">q.push(head);    <span class="comment">//利用栈的特性，先进右孩子   </span></span><br><span class="line"><span class="keyword">while</span> (!q.empty())</span><br><span class="line">&#123;</span><br><span class="line">head = q.top();</span><br><span class="line">arr.push(head);</span><br><span class="line"></span><br><span class="line">q.pop();</span><br><span class="line"><span class="comment">//和先序相反：先进左</span></span><br><span class="line"><span class="keyword">if</span> (head-&gt;left)q.push(head-&gt;left);</span><br><span class="line"><span class="keyword">if</span> (head-&gt;right)q.push(head-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (!arr.empty()) &#123;</span><br><span class="line">Node* tmp = arr.top();</span><br><span class="line">arr.pop();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; tmp-&gt;value &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="2-剑指Offer树相关题型"><a href="#2-剑指Offer树相关题型" class="headerlink" title="2.剑指Offer树相关题型"></a>2.剑指Offer树相关题型</h3><h4 id="J-7-重建二叉树-Rebuild"><a href="#J-7-重建二叉树-Rebuild" class="headerlink" title="J_7.重建二叉树(Rebuild)"></a>J_7.重建二叉树(Rebuild)</h4><ul><li><blockquote><p>前序遍历 preorder = [3,9,20,15,7]</p></blockquote></li><li><blockquote><p>中序遍历 inorder = [9,3,15,20,7]</p></blockquote></li><li><blockquote><p>解：<strong>先序定根</strong>、<strong>中序划分区间</strong></p></blockquote></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> val;</span><br><span class="line">TreeNode *left;</span><br><span class="line">TreeNode *right;</span><br><span class="line">TreeNode(<span class="keyword">int</span> x) : val(x), left(<span class="literal">NULL</span>), right(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> build(preorder, <span class="number">0</span>, inorder, <span class="number">0</span>, inorder.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">&#125;                          <span class="comment">//先序定根:          中序:划分区间</span></span><br><span class="line"><span class="function">TreeNode* <span class="title">build</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder, <span class="keyword">int</span> root, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder, <span class="keyword">int</span> start, <span class="keyword">int</span> <span class="built_in">end</span>)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (start &gt; <span class="built_in">end</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//先序定根,然后其左右树再根据中序确定</span></span><br><span class="line">TreeNode* tree = <span class="keyword">new</span> TreeNode(preorder[root]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//中序定两侧子树,定位到对应root值位置</span></span><br><span class="line"><span class="keyword">int</span> i = start;</span><br><span class="line"><span class="keyword">while</span> (i &lt; <span class="built_in">end</span> &amp;&amp; preorder[root] != inorder[i])</span><br><span class="line">i++;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">tree-&gt;left = build(preorder, root + <span class="number">1</span>, inorder, start, i - <span class="number">1</span>);</span><br><span class="line">tree-&gt;right = build(preorder, root + <span class="number">1</span> + (i - <span class="number">1</span> - start + <span class="number">1</span>), inorder, i + <span class="number">1</span>, <span class="built_in">end</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> tree;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="J-26-判断是不是树的子结构"><a href="#J-26-判断是不是树的子结构" class="headerlink" title="J_26.判断是不是树的子结构"></a>J_26.判断是不是树的子结构</h4><ul><li><blockquote><p>每个节点都有可能是节点</p></blockquote></li><li><blockquote><p>1.判断每个节点</p></blockquote></li><li>2.然后验证每个节点</li></ul><p><img src="/pictures/clipboard132.png" alt="img"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isSubStructure</span><span class="params">(TreeNode* A, TreeNode* B)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (A == <span class="literal">NULL</span> || B == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//验证当前节点  、  判断左孩子节点、  判断右孩子结点</span></span><br><span class="line"><span class="keyword">return</span> dfs(A, B) || isSubStructure(A-&gt;left, B) || isSubStructure(A-&gt;right, B);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(TreeNode* A, TreeNode* B)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (B == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> (A == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (A-&gt;val != B-&gt;val)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="comment">//继续验证剩下的节点</span></span><br><span class="line"><span class="keyword">return</span> dfs(A-&gt;left, B-&gt;left) &amp;&amp; dfs(A-&gt;right, B-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="J-27-二叉树的镜像"><a href="#J-27-二叉树的镜像" class="headerlink" title="J_27.二叉树的镜像"></a>J_27.二叉树的镜像</h4><p><img src="/pictures/clipboard133.png" alt="img"></p><ul><li><blockquote><p>1.递归</p></blockquote></li><li>2.或者队列层序遍历过程，交换节点实现<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归</span></span><br><span class="line"><span class="function">TreeNode* <span class="title">dfs</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">TreeNode* temp = root-&gt;left;</span><br><span class="line">root-&gt;left = root-&gt;right;</span><br><span class="line">root-&gt;right = temp;</span><br><span class="line"></span><br><span class="line">dfs(root-&gt;left);</span><br><span class="line">dfs(root-&gt;right);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//队列，迭代</span></span><br><span class="line"><span class="function">TreeNode* <span class="title">mirrorTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line"><span class="built_in">queue</span>&lt;TreeNode*&gt; que;</span><br><span class="line">que.push(root);</span><br><span class="line"><span class="keyword">while</span> (!que.empty())</span><br><span class="line">&#123;</span><br><span class="line">TreeNode* tmp = que.front();</span><br><span class="line">que.pop();</span><br><span class="line"><span class="keyword">if</span> (tmp == <span class="literal">NULL</span>) <span class="keyword">continue</span>;</span><br><span class="line">swap(tmp-&gt;left, tmp-&gt;right);</span><br><span class="line"><span class="keyword">if</span> (tmp-&gt;left) que.push(tmp-&gt;left);</span><br><span class="line"><span class="keyword">if</span> (tmp-&gt;right) que.push(tmp-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="J-28-对称的二叉树"><a href="#J-28-对称的二叉树" class="headerlink" title="J_28.对称的二叉树"></a>J_28.对称的二叉树</h4><ul><li><blockquote><p>验证每个余下的节点都需要满足，每个节点都要满足，传入<strong>左孩子节点</strong>和<strong>右孩子节点</strong>。</p></blockquote></li></ul><p><img src="/pictures/clipboard134.png" alt="img"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> dfs(root-&gt;left, root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(TreeNode* left, TreeNode* right)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (left == <span class="literal">NULL</span> &amp;&amp; right == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> (left == <span class="literal">NULL</span> || right == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (left-&gt;val != right-&gt;val)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">return</span> dfs(left-&gt;left, right-&gt;right) &amp;&amp; dfs(left-&gt;right, right-&gt;left);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="J-32-1-从上到下打印二叉树—层序遍历"><a href="#J-32-1-从上到下打印二叉树—层序遍历" class="headerlink" title="J_32-1.从上到下打印二叉树—层序遍历"></a>J_32-1.从上到下打印二叉树—层序遍历</h4><ul><li><blockquote><p>典型的层序遍历，按层依次打印节点value值</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">levelOrder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line"><span class="comment">//利用队列层序遍历</span></span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> &#123;&#125;;</span><br><span class="line"><span class="built_in">queue</span>&lt;TreeNode*&gt;q;</span><br><span class="line">q.push(root);</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;res;</span><br><span class="line"><span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">size</span> = q.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span>; i++) &#123;</span><br><span class="line">TreeNode* temp = q.front();</span><br><span class="line"><span class="keyword">int</span> num = temp-&gt;val;</span><br><span class="line">res.push_back(num);</span><br><span class="line">q.pop();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (temp-&gt;left)q.push(temp-&gt;left);</span><br><span class="line"><span class="keyword">if</span> (temp-&gt;right)q.push(temp-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="J-33-二叉搜索树的后序遍历序列（重建二叉树，利用后序遍历的特点）"><a href="#J-33-二叉搜索树的后序遍历序列（重建二叉树，利用后序遍历的特点）" class="headerlink" title="J_33.二叉搜索树的后序遍历序列（重建二叉树，利用后序遍历的特点）"></a>J_33.二叉搜索树的后序遍历序列（重建二叉树，利用后序遍历的特点）</h4><ul><li><blockquote><p>一个数组，判断数组是不是二叉树的后序遍历</p></blockquote></li><li><blockquote><p>输入: [1,6,3,2,5]</p></blockquote></li><li><p>输出: false</p></li></ul><p><img src="/pictures/clipboard135.png" alt="img"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">verifyPostorder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; postorder)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (postorder.<span class="built_in">size</span>() &lt; <span class="number">2</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> root = postorder.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> dfs(postorder, <span class="number">0</span>, root);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//二叉搜索树：左&lt;中&lt;右</span></span><br><span class="line"><span class="comment">//后序遍历：左 右 中</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; postorder, <span class="keyword">int</span> left, <span class="keyword">int</span> root)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (left &gt;= root)<span class="comment">//只剩一个节点时候，之前已经满足了搜索二叉树的条件</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//所以还是满足，返回true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> rootValue = postorder[root];</span><br><span class="line"></span><br><span class="line"><span class="comment">//区分左右区间，先找左右区间的区分节点位置</span></span><br><span class="line"><span class="keyword">int</span> i = left;</span><br><span class="line"><span class="keyword">while</span> (i &lt; root &amp;&amp; postorder[i] &lt; rootValue)</span><br><span class="line">i++;</span><br><span class="line"><span class="comment">//此时i已经是第一个右节点位置</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; root; j++)</span><br><span class="line"><span class="keyword">if</span> (postorder[j] &lt; rootValue)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//继续验证剩下的区间</span></span><br><span class="line"><span class="keyword">return</span> dfs(postorder, left, i - <span class="number">1</span>) &amp;&amp; dfs(postorder, i, root - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="J-34-二叉树中的路径和Sum（所有可能：回溯）"><a href="#J-34-二叉树中的路径和Sum（所有可能：回溯）" class="headerlink" title="J_34.二叉树中的路径和Sum（所有可能：回溯）"></a>J_34.二叉树中的路径和Sum（所有可能：回溯）</h4><ul><li><blockquote><p>需要遍历到底部：每条路都是有可能的，所以用回溯</p></blockquote></li></ul><p><img src="/pictures/clipboard136.png" alt="img"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//找到所有路</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;res;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">pathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;temp;</span><br><span class="line">dfs(root, sum, temp);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line"><span class="comment">//if(root == NULL || sum &lt; 0)</span></span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">arr.push_back(root-&gt;val);</span><br><span class="line">sum -= root-&gt;val;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (sum == <span class="number">0</span> &amp;&amp; root-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;right == <span class="literal">NULL</span>)</span><br><span class="line">res.push_back(arr);</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">dfs(root-&gt;left, sum, arr);</span><br><span class="line">dfs(root-&gt;right, sum, arr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">arr.pop_back();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="J-34-拓展-二叉树中的路径和Sum（是否可能：迭代）"><a href="#J-34-拓展-二叉树中的路径和Sum（是否可能：迭代）" class="headerlink" title="J_34.拓展.二叉树中的路径和Sum（是否可能：迭代）"></a>J_34.拓展.二叉树中的路径和Sum（是否可能：迭代）</h4><p><img src="/pictures/clipboard69.png" alt="img1"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (root-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;right == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> sum - root-&gt;val == <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> hasPathSum(root-&gt;left, sum - root-&gt;val) || hasPathSum(root-&gt;right, sum - root-&gt;val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="J-37-序列化二叉树（先序遍历构建）"><a href="#J-37-序列化二叉树（先序遍历构建）" class="headerlink" title="J_37.序列化二叉树（先序遍历构建）"></a>J_37.序列化二叉树（先序遍历构建）</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> val;</span><br><span class="line">TreeNode *left;</span><br><span class="line">TreeNode *right;</span><br><span class="line">TreeNode(<span class="keyword">int</span> x) : val(x), left(<span class="literal">NULL</span>), right(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">serialize</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="string">"#,"</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> res = to_string(root-&gt;val) + <span class="string">","</span>;</span><br><span class="line">res += serialize(root-&gt;left);</span><br><span class="line">res += serialize(root-&gt;right);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//先序</span></span><br><span class="line"><span class="comment">//反序列化</span></span><br><span class="line"><span class="function">TreeNode* <span class="title">deserialize</span><span class="params">(<span class="built_in">string</span> data)</span> </span>&#123;</span><br><span class="line"><span class="comment">//利用getline来截取string</span></span><br><span class="line"><span class="function"><span class="built_in">stringstream</span> <span class="title">arr</span><span class="params">(data)</span></span>;</span><br><span class="line"><span class="built_in">string</span> temp;</span><br><span class="line"></span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="built_in">string</span>&gt;q;</span><br><span class="line"><span class="keyword">while</span> (getline(arr, temp, <span class="string">','</span>)) &#123;</span><br><span class="line">q.push(temp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> dfs(q);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">TreeNode* <span class="title">dfs</span><span class="params">(<span class="built_in">queue</span>&lt;<span class="built_in">string</span>&gt;&amp;q)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (q.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> temp = q.front();</span><br><span class="line">q.pop();</span><br><span class="line"><span class="keyword">if</span> (temp == <span class="string">"#"</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">TreeNode* root = <span class="keyword">new</span> TreeNode(stoi(temp));</span><br><span class="line">root-&gt;left = dfs(q);</span><br><span class="line">root-&gt;right = dfs(q);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="J-55-1-计算二叉树的高度"><a href="#J-55-1-计算二叉树的高度" class="headerlink" title="J_55-1.计算二叉树的高度"></a>J_55-1.计算二叉树的高度</h4><ul><li><blockquote><p>递归下去</p></blockquote></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">max</span>(maxDepth(root-&gt;left), maxDepth(root-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="J-55-2-判断是否平衡二叉树（仅高度）"><a href="#J-55-2-判断是否平衡二叉树（仅高度）" class="headerlink" title="J_55-2.判断是否平衡二叉树（仅高度）"></a>J_55-2.判断是否平衡二叉树（仅高度）</h4><ul><li><blockquote><p>平衡二叉树：高度差小于等于1即可。</p></blockquote></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当前节点满足</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">abs</span>(depth(root-&gt;left) - depth(root-&gt;right)) &gt; <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//余下节点满足</span></span><br><span class="line"><span class="keyword">return</span> dfs(root-&gt;left) &amp;&amp; dfs(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">depth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">max</span>(depth(root-&gt;left), depth(root-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="J-55-拓展1-求二叉树的最大直径"><a href="#J-55-拓展1-求二叉树的最大直径" class="headerlink" title="J_55.拓展1.求二叉树的最大直径"></a>J_55.拓展1.求二叉树的最大直径</h4><p><img src="/pictures/clipboard70.png" alt="img1"></p><ul><li><blockquote><p>利用上一题的求节点的最大深度</p></blockquote></li><li><p>在求数深度的过程中，不单单只是MAX（left，right）+1</p><ul><li>而是比较max（res，L+R）; </li></ul></li><li><blockquote><p>在求数的深度的过程中，比较maxLength</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">int</span> length;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">diameterOfBinaryTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">length = <span class="number">0</span>;</span><br><span class="line">dfs(root);</span><br><span class="line"><span class="keyword">return</span> length;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">int</span> L = dfs(root-&gt;left);</span><br><span class="line"><span class="keyword">int</span> R = dfs(root-&gt;right);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> curlength = L + R;</span><br><span class="line">length = <span class="built_in">max</span>(length, curlength); <span class="comment">//这个节点的最大值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">max</span>(L, R) + <span class="number">1</span>;            <span class="comment">//返回该子节点的最大分治</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="J-68-1-二叉搜索树的最近公共祖先"><a href="#J-68-1-二叉搜索树的最近公共祖先" class="headerlink" title="J_68-1.二叉搜索树的最近公共祖先"></a>J_68-1.二叉搜索树的最近公共祖先</h4><ul><li><blockquote><p>利用二叉搜索树的特性</p></blockquote></li><li>左 &lt; 中 &lt; 右</li><li>利用节点的值，来进行计算，只有当的Value值一个大于，一个小于：找到节点<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (root-&gt;val &gt; p-&gt;val &amp;&amp; root-&gt;val &gt; q-&gt;val)</span><br><span class="line"><span class="keyword">return</span> lowestCommonAncestor(root-&gt;left, p, q);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (root-&gt;val &lt; p-&gt;val &amp;&amp;root-&gt;val &lt; q-&gt;val)</span><br><span class="line"><span class="keyword">return</span> lowestCommonAncestor(root-&gt;right, p, q);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="J-68-2-二叉树的最近公共祖先"><a href="#J-68-2-二叉树的最近公共祖先" class="headerlink" title="J_68-2.二叉树的最近公共祖先"></a>J_68-2.二叉树的最近公共祖先</h4><ul><li><blockquote><p>依次往下遍历节点</p></blockquote></li><li><blockquote><p>如果找到了：q、p返回</p></blockquote></li><li>否则：继续往下遍历，查看左树和右树的查询结果。<br><img src="/pictures/clipboard62.png" alt="img"></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">if</span> (root == p || root == q)</span><br><span class="line"><span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">TreeNode* L = lowestCommonAncestor(root-&gt;left, p, q);</span><br><span class="line">TreeNode* R = lowestCommonAncestor(root-&gt;right, p, q);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (L != <span class="literal">NULL</span> &amp;&amp; R != <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> root;</span><br><span class="line"><span class="keyword">if</span> (L == <span class="literal">NULL</span> &amp;&amp; R != <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> R;</span><br><span class="line"><span class="keyword">if</span> (R == <span class="literal">NULL</span> &amp;&amp; L != <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> L;</span><br><span class="line"><span class="keyword">if</span> (R == <span class="literal">NULL</span> &amp;&amp; L == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
          <category> 树、链表专题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>生活 / yqz面经</title>
      <link href="/2020/08/06/yqz%E9%9D%A2%E7%BB%8F/"/>
      <url>/2020/08/06/yqz%E9%9D%A2%E7%BB%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="面试问题"><a href="#面试问题" class="headerlink" title="面试问题"></a>面试问题</h2><h3 id="1-说一下你的职业规划？"><a href="#1-说一下你的职业规划？" class="headerlink" title="1.说一下你的职业规划？"></a>1.说一下你的职业规划？</h3><ul><li><blockquote><p>首先第一年，我觉得实践是检验真理的唯一标准。虽然，我们在学校里学习了很多东西，很多方法。但是，在实际的运用在肯定是存在一定偏差的，我的短期目标是能够快速的融入到面试的岗位上来，跳出学校舒适圈，从而能够胜任这份工作。</p></blockquote></li><li><blockquote><p>第二第三年：在完成工作的基础上，丰富自己的知识，争取在本领域能有所突破。</p></blockquote></li><li><blockquote><p>第四、五年：有了前些年的沉淀，希望可以更上一层楼，重新规划一下自己的目标，确定下一阶段的目标。</p></blockquote></li></ul><hr><h3 id="2-说一下你的项目？"><a href="#2-说一下你的项目？" class="headerlink" title="2.说一下你的项目？"></a>2.说一下你的项目？</h3><ul><li><blockquote><p>我们的项目的全称为：<strong>深海的生物数字化原位观测系统</strong>。是搭载在深海潜水器的<strong>视觉测量工具</strong>。主要是为了获取水下生物和地貌的三维信息而设计的。</p></blockquote><ul><li>是基于线激光的双目立体成像系统。工作流程大约是：线激光扫描物体表面的同时，左右相机同时拍摄物体，通过左右图像的对应像点求出物体的实际三维信息。</li><li>项目的难点是在于：<ul><li>水下相机成像光线不是直线传播，而是经过了多层折射，导致相机的透视投影和极线约束都失效了。</li></ul></li></ul></li></ul><hr><ul><li><blockquote><p>针对上述问题，我们提出了基于光场的多层平面折射模型。将光线转化为光场来表示，完美的展示了水下光线的折射传播过程，从而根据水下光线共面的特性来求取水下像点的三维信息。</p></blockquote></li><li>最后，通过点云拼接技术，得到完整的整幅图像的点云图。</li></ul><hr><h3 id="3-你在项目中主要做了哪些工作？"><a href="#3-你在项目中主要做了哪些工作？" class="headerlink" title="3.你在项目中主要做了哪些工作？"></a>3.你在项目中主要做了哪些工作？</h3><ul><li><blockquote><p>针对一代<strong>基于线激光的系统</strong>我的工作主要是：硬件调试和软件维护工作。多次，前往青岛国家深海基地，进行我们样机的水池实验，打压实验和蛟龙号联调实验。同时，也针对系统的软件进行了一定的优化和改进。（ROI区域 / 上下位机的通讯，修复了卡顿问题）</p></blockquote></li></ul><hr><ul><li><blockquote><p>我主要的工作是针对二代系统来做的，一代系统是基于线激光的水下三维重建，高精度，但是最终是通过点云拼接来完成整幅图像的重建，但是速度很慢。</p></blockquote></li><li><blockquote><p>所以我们进一步，提出了利用面激光来进行水下三维重建的工作。虽然，损失了部分精度，但是速度明显加快，我们的目标是做到实时显示。</p></blockquote><ul><li>我的工作主要如下：</li><li>1.编写相机模块的C++代码，将大恒相机的库文件整合成一个类，支持各种功能。</li><li>2.使用Matlab对二代系统原理的仿真，及C++代码实现。同时在仪器仪表学报发表了一篇水下图像校正的论文。</li><li>3.整合整个水下系统，包含了相机模块，计算模块，传输模块等。三台TX2电脑，上下位机功能和软件的实现。</li></ul></li></ul><hr><h3 id="4-说一下你的实习项目？"><a href="#4-说一下你的实习项目？" class="headerlink" title="4.说一下你的实习项目？"></a>4.说一下你的实习项目？</h3><ul><li>实习项目都是在树莓派上的C++集成开发，都是利用视觉测量技术实现动态测量。</li></ul><ol><li>我就说说我近期做的一次性棉签采集器的项目吧。</li><li>项目的需求是：能够检测出试管中液体的高度和棉签的位姿。从而它控制的云台能够正确的下针将待测液体吸走。</li></ol><ul><li><blockquote><p>考虑成本和功能实现问题，我们就用到了树莓派4B和它自带的modle v2相机。</p></blockquote></li><li>首先利用OTSU前景后景图像分割，分离出前景和后景。然后再分割出来的图像上进行操作。</li></ul><hr><h2 id="8-6-上海农商行"><a href="#8-6-上海农商行" class="headerlink" title="8/6.上海农商行"></a>8/6.上海农商行</h2><h3 id="1-形式-群面"><a href="#1-形式-群面" class="headerlink" title="1.形式(群面)"></a>1.形式(群面)</h3><ol><li>每个人开始自我介绍。然后面试官提问。</li></ol><h3 id="2-结果-gg"><a href="#2-结果-gg" class="headerlink" title="2.结果(gg)"></a>2.结果(gg)</h3><ol><li>说话的逻辑太差了，让人感觉很难受！</li><li>说话没有主次，目的性，项目介绍也没没头没尾。</li><li>没有学历就拼能力。可是你什么都没有！！（人家南理、东南、中科所）</li></ol><hr><h2 id="8-8三一重工"><a href="#8-8三一重工" class="headerlink" title="8/8三一重工"></a>8/8三一重工</h2><h3 id="1-形式-技术面一面"><a href="#1-形式-技术面一面" class="headerlink" title="1.形式(技术面一面)"></a>1.形式(技术面一面)</h3><ol><li>开始自我介绍。然后问了一些问题</li></ol><h3 id="2-结果-还可"><a href="#2-结果-还可" class="headerlink" title="2.结果(还可)"></a>2.结果(还可)</h3><ol><li>问的不是很多，很深，让我感觉有点飘了！！！你还是很菜的！！！</li></ol><hr><h2 id="8-8猿辅导"><a href="#8-8猿辅导" class="headerlink" title="8/8猿辅导"></a>8/8猿辅导</h2><h3 id="1-形式-技术面一面-1"><a href="#1-形式-技术面一面-1" class="headerlink" title="1.形式(技术面一面)"></a>1.形式(技术面一面)</h3><ol><li>开始自我介绍。然后面试官说不想听了，直接进入技术环节。</li><li>两道编程题目<ul><li>1.无序链表排成有序。 时间复杂度O(n * logn)<ul><li><a href="https://leetcode-cn.com/problems/sort-list/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/sort-list/</a></li></ul></li><li>2.两个有序数组，第K大的数。时间复杂度O(log(x+y))<ul><li><a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/median-of-two-sorted-arrays/</a> </li></ul></li></ul></li></ol><h3 id="2-结果-gg-1"><a href="#2-结果-gg-1" class="headerlink" title="2.结果(gg)"></a>2.结果(gg)</h3><ol><li>算法编程能力太差了，一道题目都没做出来。一般面试做的都是树、链表的题目。</li></ol><hr><h2 id="8-9诺瓦科技"><a href="#8-9诺瓦科技" class="headerlink" title="8/9诺瓦科技"></a>8/9诺瓦科技</h2><h3 id="1-形式-技术面一面-2"><a href="#1-形式-技术面一面-2" class="headerlink" title="1.形式(技术面一面)"></a>1.形式(技术面一面)</h3><ol><li>开始自我介绍。然后面进入技术提问环节。</li><li>问题？</li></ol><ul><li><blockquote><p>1.vector容器头部插入数据的具体过程？</p><pre><code>- vector&lt;int&gt;temp;//在元素前- temp.insert(temp.begin(),Value);- temp.insert(temp.begin(),Value);</code></pre></blockquote></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在迭代器前插入元素</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;temp;</span><br><span class="line">temp.insert(temp.<span class="built_in">begin</span>(),Value);</span><br><span class="line">temp.insert(temp.<span class="built_in">begin</span>(),n ,Value);</span><br><span class="line"></span><br><span class="line"><span class="comment">//在指定位置loc前插入区间[start, end)的所有元素 . </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">( iterator loc, input_iterator start, input_iterator <span class="built_in">end</span> )</span></span>;</span><br></pre></td></tr></table></figure><ul><li><blockquote><p>2.初始化成员列表，哪些必须用它？</p></blockquote></li></ul><ol><li>const成员变量 / reference成员变量</li><li>子类初始化<strong>父类私有成员</strong></li><li></li></ol><ul><li><blockquote><p>3.多线程加锁的危害？</p><pre><code>- 四种具体情况举例说明，到底是什么情况？</code></pre></blockquote></li><li><blockquote><p>4.UDP不可靠，怎么让他能够可靠起来？</p></blockquote></li><li><blockquote><p>5.四种共享指针？独占型指针可以给其他变量赋值吗？</p></blockquote></li><li><blockquote><p>6.客户端和服务器连接时，端口有什么特殊要求吗？</p></blockquote></li><li><blockquote><p>7.脏读、可重读、幻读到底是怎么引起的？</p></blockquote></li></ul><h3 id="2-结果-gg-2"><a href="#2-结果-gg-2" class="headerlink" title="2.结果(gg)"></a>2.结果(gg)</h3><ol><li>底层概念还是不清楚。</li></ol><hr><h2 id="8-11京东一面"><a href="#8-11京东一面" class="headerlink" title="8/11京东一面"></a>8/11京东一面</h2><h3 id="1-形式-技术面一面-3"><a href="#1-形式-技术面一面-3" class="headerlink" title="1.形式(技术面一面)"></a>1.形式(技术面一面)</h3><ol><li>直接进入技术提问环节。</li><li>不会的问题，答的不好的问题？<ul><li>1.volatile关键字</li><li>2.一个空类大小多少，类中static变量占类中空间大小<ul><li>3.brk(）和sbrk()函数，堆上资源往上拓展</li><li>4.如何判断内存泄漏。防止内存泄漏</li><li>5.多线程：一个读，一个写如何防止事件之间发生错误<ul><li>线程这块需要好好看看 </li></ul></li><li>6.一个类中默认包含的构造函数、析构函数还有哪些</li><li>7.一个对象new出来，具体的整个类中过程</li></ul></li></ul></li></ol><h3 id="2-结果-gg-3"><a href="#2-结果-gg-3" class="headerlink" title="2.结果(gg)"></a>2.结果(gg)</h3><ol><li>多线程那一块需要好好看看。</li></ol><hr><h2 id="8-20拼多多二面"><a href="#8-20拼多多二面" class="headerlink" title="8/20拼多多二面"></a>8/20拼多多二面</h2><h3 id="1-形式-技术面二面"><a href="#1-形式-技术面二面" class="headerlink" title="1.形式(技术面二面)"></a>1.形式(技术面二面)</h3><ol><li>直接进入技术提问环节。</li><li>不会的问题，答的不好的问题？<ul><li>1.队列实现栈</li><li>2.实现最小栈<ul><li>3.四次握手具体FIN_WAIT、CLOSE_WAIT、TIME_WAIT在什么时间段</li></ul></li></ul></li></ol><ul><li>7.算法题：时间段包含问题，源（2.8，9.8）,目标（1，2）（3，7.5）（8，9）（10.11），能否包含源目标段。</li></ul><h3 id="2-结果-gg-4"><a href="#2-结果-gg-4" class="headerlink" title="2.结果(gg)"></a>2.结果(gg)</h3><ol><li>撕代码彩笔</li></ol><hr><h2 id="8-21字节跳动一面"><a href="#8-21字节跳动一面" class="headerlink" title="8/21字节跳动一面"></a>8/21字节跳动一面</h2><h3 id="1-形式-技术面一面-4"><a href="#1-形式-技术面一面-4" class="headerlink" title="1.形式(技术面一面)"></a>1.形式(技术面一面)</h3><ol><li><p>直接进入技术提问环节。</p></li><li><p>不会的问题，答的不好的问题？</p><ul><li>1.static函数和一般函数的具体区别</li><li>2.shared_ptr共享指针具体使用方法，weak弱指针的具体具体实现方式</li><li>3.new一个对象的具体实现过程</li><li>4.new / malloc的具体区别</li><li>5.char a[5] = {0x01,0x02,0x03,0x04,0x05}<ul><li>int * p = (int * )a;</li><li>cout&lt;&lt; * p;</li></ul></li></ul><ul><li>7.算法题：<ul><li>1.反转链表 </li><li>1.反转链表，相邻元素 </li></ul></li></ul></li></ol><h3 id="2-结果-gg-5"><a href="#2-结果-gg-5" class="headerlink" title="2.结果(gg)"></a>2.结果(gg)</h3><ol><li>基础不行</li></ol><hr>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
          <category> 面试感悟 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>生活 / 23:30睡觉、多喝白开水 </title>
      <link href="/2020/07/31/%E6%97%A9%E7%82%B9%E7%9D%A1%E8%A7%89%EF%BC%8C%E6%88%91%E7%9A%84%E5%93%A5%EF%BC%81%EF%BC%81%EF%BC%81-1/"/>
      <url>/2020/07/31/%E6%97%A9%E7%82%B9%E7%9D%A1%E8%A7%89%EF%BC%8C%E6%88%91%E7%9A%84%E5%93%A5%EF%BC%81%EF%BC%81%EF%BC%81-1/</url>
      
        <content type="html"><![CDATA[<p><img src="/pictures/clipboard84.jpg" alt="sleep"></p><hr><p><img src="/pictures/clipboard83.png" alt="NoPhone"></p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
          <category> 注意事项 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode / 其他算法</title>
      <link href="/2020/07/30/LeetCode-%E5%85%B6%E4%BB%96%E7%AE%97%E6%B3%95/"/>
      <url>/2020/07/30/LeetCode-%E5%85%B6%E4%BB%96%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h2><h3 id="1-访问链表中倒数第K个数"><a href="#1-访问链表中倒数第K个数" class="headerlink" title="1.访问链表中倒数第K个数"></a>1.访问链表中倒数第K个数</h3><ul><li><blockquote><p>快指针先走k，然后快慢同时走，快==NULL，到达目的地。</p></blockquote></li></ul><h3 id="2-环形链表的判断（leetcode-141）"><a href="#2-环形链表的判断（leetcode-141）" class="headerlink" title="2.环形链表的判断（leetcode_141）"></a>2.环形链表的判断（leetcode_141）</h3><ul><li><blockquote><p>当存在环形链表，快指针肯定能够追上慢指针，此时return true;</p></blockquote></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>)  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">ListNode* fast = head;</span><br><span class="line">ListNode* slow = head;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (fast-&gt;next != <span class="literal">NULL</span> &amp;&amp; fast-&gt;next-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">fast = fast-&gt;next-&gt;next;</span><br><span class="line">slow = slow-&gt;next;</span><br><span class="line"><span class="keyword">if</span> (fast == slow)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-环形链表的入口（leetcode-142）"><a href="#3-环形链表的入口（leetcode-142）" class="headerlink" title="3.环形链表的入口（leetcode_142）"></a>3.环形链表的入口（leetcode_142）</h3><p><img src="/pictures/clipboard71.png" alt="img"></p><ol><li>slow和fast相遇，slow = nb</li><li>slow再走a就能到达入口节点，所以当slow = temp就是入口节点</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line"><span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line"><span class="comment">//判断是否为环形链表</span></span><br><span class="line"><span class="keyword">if</span> (head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>)  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">ListNode* fast = head;</span><br><span class="line">ListNode* slow = head;</span><br><span class="line"><span class="keyword">while</span> (fast-&gt;next != <span class="literal">NULL</span> &amp;&amp; fast-&gt;next-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">fast = fast-&gt;next-&gt;next;</span><br><span class="line">slow = slow-&gt;next;</span><br><span class="line"><span class="keyword">if</span> (fast == slow) &#123;</span><br><span class="line">flag = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (flag) &#123;</span><br><span class="line">ListNode* q = head;</span><br><span class="line"><span class="keyword">while</span> (q != slow)</span><br><span class="line">&#123;</span><br><span class="line">q = q-&gt;next;</span><br><span class="line">slow = slow-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-寻找重复数（leetcode-287）"><a href="#4-寻找重复数（leetcode-287）" class="headerlink" title="4. 寻找重复数（leetcode_287）"></a>4. 寻找重复数（leetcode_287）</h3><ul><li><blockquote><p>给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。</p></blockquote></li><li><blockquote><p>输入: [1,3,4,2,2]</p></blockquote></li><li><p>输出: 2</p></li><li><blockquote><p>输入: [3,1,3,4,2]</p></blockquote></li><li><p>输出: 3</p></li><li><blockquote><p>解：运用环形链表来求解问题<br><img src="/pictures/clipboard72.png" alt="img"></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> fast = <span class="number">0</span>, slow = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"><span class="comment">//根据索引自动成环</span></span><br><span class="line">slow = nums[slow];</span><br><span class="line">fast = nums[fast];</span><br><span class="line">fast = nums[fast];</span><br><span class="line"><span class="comment">// 快指针index = 慢指针index</span></span><br><span class="line"><span class="keyword">if</span> (slow == fast) &#123;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">begin</span> = <span class="number">0</span>;<span class="comment">//头节点从0开始走,慢指针走,两者再相等，就是入环的第一个index</span></span><br><span class="line"><span class="keyword">while</span> (nums[slow] != nums[<span class="built_in">begin</span>]) &#123;</span><br><span class="line"><span class="built_in">begin</span> = nums[<span class="built_in">begin</span>];</span><br><span class="line">slow = nums[slow];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> nums[slow];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="欧几里得算法（辗转相除法）"><a href="#欧几里得算法（辗转相除法）" class="headerlink" title="欧几里得算法（辗转相除法）"></a>欧几里得算法（辗转相除法）</h2><ul><li><blockquote><p>求取最大公约数</p></blockquote></li><li>输入：（a &gt;= b）</li><li>具体算法：gcd（a，b）=gcd（b，a%b）<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> b==<span class="number">0</span>?a:gcd(b,a%b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="字符串的最大公因子-leetcode-1071"><a href="#字符串的最大公因子-leetcode-1071" class="headerlink" title="字符串的最大公因子(leetcode_1071)"></a>字符串的最大公因子(leetcode_1071)</h3><p><img src="/pictures/clipboard73.png" alt="img"></p><ul><li><blockquote><p>解</p></blockquote></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> b == <span class="number">0</span> ? a : gcd(b, a%b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">gcdOfStrings</span><span class="params">(<span class="built_in">string</span> str1, <span class="built_in">string</span> str2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (str1 + str2 != str2 + str1)</span><br><span class="line"><span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line"><span class="keyword">return</span> str1.substr(<span class="number">0</span>, gcd(str1.<span class="built_in">size</span>(), str2.<span class="built_in">size</span>()));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="水壶倒水问题-leetcode-365"><a href="#水壶倒水问题-leetcode-365" class="headerlink" title="水壶倒水问题(leetcode_365)"></a>水壶倒水问题(leetcode_365)</h3><ul><li><p>有两个容量分别为 x升 和 y升 的水壶以及无限多的水。请判断能否通过使用这两个水壶，从而可以得到恰好 z升 的水？</p></li><li><p>如果可以，最后请用以上水壶中的一或两个来盛放取得的 z升水。</p></li><li><p>你允许：</p></li><li><p>1.装满任意一个水壶</p></li><li><p>2.清空任意一个水壶</p></li><li><p>3.从一个水壶向另外一个水壶倒水，直到装满或者倒空</p></li><li><blockquote><p>原理是ax+by=z 求二元一次方程的整数解 有整数解的前提是 x与y的最大公约数 能被z整除</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> b == <span class="number">0</span> ? a : gcd(b, a%b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canMeasureWater</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (x + y &lt; z)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (x == z || y == z || x + y == z || z == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">return</span> z % gcd(x, y) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="约瑟夫环问题"><a href="#约瑟夫环问题" class="headerlink" title="约瑟夫环问题"></a>约瑟夫环问题</h2><ul><li><blockquote><p>0,1,,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字。求出这个圆圈里剩下的最后一个数字。</p></blockquote></li><li><p>例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。</p></li></ul><ul><li><blockquote><p>输出</p></blockquote></li><li><blockquote><p>输入: n = 5, m = 3</p></blockquote></li><li><p>输出: 3</p></li><li><blockquote><p>输入: n = 10, m = 17</p></blockquote></li><li><p>输出: 2</p></li><li><blockquote><p>方法：约瑟夫环问题<br><img src="/pictures/clipboard59.png" alt="img"><br><img src="/pictures/clipboard60.png" alt="img"></p></blockquote></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lastRemaining</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line"><span class="comment">//约瑟夫环的问题</span></span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n ; i++) &#123;</span><br><span class="line">res = (res + m) % i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="中心扩展法-回文串相关"><a href="#中心扩展法-回文串相关" class="headerlink" title="中心扩展法(回文串相关)"></a>中心扩展法(回文串相关)</h2><ul><li><blockquote><p>求取最长回文串</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//中心扩展发</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (s.<span class="built_in">size</span>() &lt;= <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> L = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> R = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//记录当前最大回文串地址下标</span></span><br><span class="line"><span class="keyword">int</span> len = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line"><span class="keyword">int</span> len1 = calcuNum(s, i, i);</span><br><span class="line"><span class="keyword">int</span> len2 = calcuNum(s, i, i + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> lentemp = <span class="built_in">max</span>(len1, len2);</span><br><span class="line"></span><br><span class="line"><span class="comment">//当当前回文子串大于之前的，统计当前下标</span></span><br><span class="line"><span class="keyword">if</span> (lentemp &gt; R - L + <span class="number">1</span>) &#123;</span><br><span class="line">L = i - (lentemp - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">R = i + lentemp / <span class="number">2</span>; <span class="comment">//起点是 i i的后面一个，所以L需要len长度-1再除以2</span></span><br><span class="line">len = lentemp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> s.substr(L, len);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//从这点出发的回文子串</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calcuNum</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (L &gt;= <span class="number">0</span> &amp;&amp; R &lt; s.<span class="built_in">size</span>() &amp;&amp; s[L] == s[R]) &#123;</span><br><span class="line">L--;</span><br><span class="line">R++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>  R - L - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><ul><li><blockquote><p>头部加入最少字符，变成回文串</p></blockquote></li><li><blockquote><p>尾部加入最少字符，变成回文串<br><img src="/pictures/clipboard106.png" alt="img"></p></blockquote></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//头部加入字符，变成回文串</span></span><br><span class="line"><span class="comment">//解题：</span></span><br><span class="line"><span class="comment">//找寻以头节点为中心，是否存在回文串</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">shortestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">rev</span><span class="params">(s)</span></span>;</span><br><span class="line">reverse(rev.<span class="built_in">begin</span>(), rev.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> len = s.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (s.substr(<span class="number">0</span> , len - i) == rev.substr(i)) &#123;</span><br><span class="line"><span class="keyword">return</span> rev.substr(<span class="number">0</span> , i) + s;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//尾部加入字符，变成回文串</span></span><br><span class="line"><span class="comment">//解题：</span></span><br><span class="line"><span class="comment">//找寻以尾节点为中心，是否存在回文串</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">shortestPalindromePop</span><span class="params">(<span class="built_in">string</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">rev</span><span class="params">(s)</span></span>;</span><br><span class="line">reverse(rev.<span class="built_in">begin</span>(), rev.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> len = s.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (s.substr(i) == rev.substr(<span class="number">0</span>,len - i)) &#123;</span><br><span class="line"><span class="keyword">return</span> s + rev.substr(len - i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="前缀和Sum-K"><a href="#前缀和Sum-K" class="headerlink" title="前缀和Sum_K"></a>前缀和Sum_K</h2><ul><li><blockquote><p><strong>解决连续数组中，可能性的问题。</strong></p></blockquote></li><li><blockquote></blockquote></li></ul><ol><li>unordered_map&lt;int, int&gt;dp;</li><li>sum += arr[i]</li><li><strong>对sum处理</strong></li><li>res += dp[sum]</li><li>dp[sum]++</li></ol><h3 id="1-求取和为-K-的连续子数组-leetcode-560"><a href="#1-求取和为-K-的连续子数组-leetcode-560" class="headerlink" title="1.求取和为 K 的连续子数组(leetcode_560)"></a>1.求取和为 K 的连续子数组(leetcode_560)</h3><ul><li><blockquote><p>给定一个整数数组和一个整数 k，你需要找到该数组中和为 k 的连续的子数组的个数。</p></blockquote></li><li><blockquote><p>输入：[1,1,1] \ k=2</p></blockquote></li><li><blockquote><p>输出：[1,1]、[1,1]</p></blockquote></li><li><blockquote><p>思路：SumK的方法，利用哈希表来快速统计Sum是否出现过，然后进行对应计算</p></blockquote></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//Sum  K</span></span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;arr;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">sum += nums[i];</span><br><span class="line">count += arr[sum - k];</span><br><span class="line">arr[sum]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-和可被-K-整除的子数组-leetcode-974"><a href="#2-和可被-K-整除的子数组-leetcode-974" class="headerlink" title="2.和可被 K 整除的子数组(leetcode_974)"></a>2.和可被 K 整除的子数组(leetcode_974)</h3><ul><li><blockquote><p>给定一个整数数组 A，返回其中元素之和可被 K 整除的（连续、非空）子数组的数目。</p></blockquote></li><li><p>输入：A = [4,5,0,-2,-3,1], K = 5</p></li><li><p>输出：7</p></li><li><p>解释：</p></li><li><p>有 7 个子数组满足其元素之和可被 K = 5 整除：</p></li><li><p>[4, 5, 0, -2, -3, 1], [5], [5, 0], [5, 0, -2, -3], [0], [0, -2, -3], [-2, -3]</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">subarraysDivByK</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;dp;</span><br><span class="line">dp[<span class="number">0</span>] = <span class="number">1</span>;<span class="comment">//余数为0，空直接满足就是1</span></span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">sum += A[i];</span><br><span class="line"><span class="comment">// 通用方式: (num % K + K) % K 【不用区分正负数】</span></span><br><span class="line"><span class="keyword">if</span> (sum%K &lt; <span class="number">0</span>)  <span class="comment">//当K = 5,-2和2满足要求，所以我都将负数转换为正数来方便计算</span></span><br><span class="line">sum = sum % K + K;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">sum = sum % K;</span><br><span class="line"></span><br><span class="line">res += dp[sum];<span class="comment">//相同余数的情况</span></span><br><span class="line">dp[sum]++;<span class="comment">//余数情况添加</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-判断是否存在Sum为-K-的连续子数组-leetcode-523"><a href="#3-判断是否存在Sum为-K-的连续子数组-leetcode-523" class="headerlink" title="3.判断是否存在Sum为 K 的连续子数组(leetcode_523)"></a>3.判断是否存在Sum为 K 的连续子数组(leetcode_523)</h3><ul><li><blockquote><p>给定一个包含 非负数 的数组和一个目标 整数 k，编写一个函数来判断该数组是否含有连续的子数组，其大小至少为 2，且总和为 k 的倍数，即总和为 n*k，其中 n 也是一个整数。</p></blockquote></li><li><blockquote><p>输入：[23,2,4,6,7], k = 6</p></blockquote></li><li><blockquote><p>输出：True</p></blockquote></li><li><blockquote><p>解释：[2,4] 是一个大小为 2 的子数组，并且和为 6。</p></blockquote></li><li><blockquote><p>输入：[23,2,6,4,7], k = 6</p></blockquote></li><li><blockquote><p>输出：True</p></blockquote></li><li><blockquote><p>解释：[23,2,6,4,7]是大小为 5 的子数组，并且和为 42。</p></blockquote></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">checkSubarraySum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//map&lt;sum % K,index&gt;</span></span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; <span class="built_in">map</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//防止第一个数满足，条件是连续2个，这样 0 -(-1),不满足</span></span><br><span class="line"><span class="built_in">map</span>[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">sum += nums[i];</span><br><span class="line"><span class="keyword">if</span> (k != <span class="number">0</span>)</span><br><span class="line">sum = sum % k;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">map</span>.<span class="built_in">find</span>(sum) == <span class="built_in">map</span>.<span class="built_in">end</span>()) &#123;</span><br><span class="line"><span class="built_in">map</span>[sum] = i;<span class="comment">//保存其节点下标</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;   <span class="comment">//找到了相同余数，表示这区间两数相加位K的整数倍</span></span><br><span class="line"><span class="keyword">if</span> (i - <span class="built_in">map</span>[sum] &gt; <span class="number">1</span>)<span class="comment">//其大小至少为2     </span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="筛漏法"><a href="#筛漏法" class="headerlink" title="筛漏法"></a>筛漏法</h2><ul><li><blockquote><p>统计所有小于非负整数 n 的质数的数量。</p></blockquote></li><li><p>输入: 10</p></li><li><p>输出: 4</p></li><li><p>解释: 小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countPrimes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">isPrime</span><span class="params">(n, <span class="literal">true</span>)</span></span>;</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> len = isPrime.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; len; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (isPrime[i]) &#123;</span><br><span class="line">cnt++;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>; j*i &lt; len; j++)</span><br><span class="line">isPrime[j*i] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
          <category> 其他算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode  / 十大排序</title>
      <link href="/2020/07/29/LeetCode-%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F-1/"/>
      <url>/2020/07/29/LeetCode-%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F-1/</url>
      
        <content type="html"><![CDATA[<p><code>优质资源</code>：<a href="https://www.cnblogs.com/onepixel/p/7674659.html" target="_blank" rel="noopener">https://www.cnblogs.com/onepixel/p/7674659.html</a></p><hr><p><img src="/pictures/%E6%8E%92%E5%BA%8F.png" alt="img"></p><h2 id="比较类排序"><a href="#比较类排序" class="headerlink" title="比较类排序"></a>比较类排序</h2><ul><li><blockquote><p>排序算法稳定：稳不稳定看交换过程中，相同的元素会不会改变前后顺序</p></blockquote></li></ul><h3 id="1-冒泡排序"><a href="#1-冒泡排序" class="headerlink" title="1.冒泡排序"></a>1.冒泡排序</h3><ul><li><blockquote><p>直接两两比较，n次遍历，进行进行交换，将最大的元素移至最后。<br><font size=6> 时间复杂度O(n^2)、空间O(1)</font> </p></blockquote></li></ul><p><img src="/pictures/clipboard63.png" alt="img"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.冒泡------------逐步把最大的放后面去</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.<span class="built_in">size</span>() ; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; arr.<span class="built_in">size</span>() - i; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (arr[j<span class="number">-1</span>]  &gt;  arr[j]) &#123;</span><br><span class="line"><span class="keyword">int</span> temp = arr[j];</span><br><span class="line">arr[j] = arr[j - <span class="number">1</span>];</span><br><span class="line">arr[j - <span class="number">1</span>] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="2-选择排序"><a href="#2-选择排序" class="headerlink" title="2.选择排序"></a>2.选择排序</h3><ul><li><blockquote><p>不直接交换，两两比较，进行下标的交换，<strong>记录最小元素下标</strong></p></blockquote></li></ul><p><font size=6> 时间复杂度O(n^2)、空间O(1)</font> </p><p><img src="/pictures/clipboard64.png" alt="img"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//2选择--------------记录最小元素下标、然后进行元素交换</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line"><span class="keyword">int</span> tempIndex = i;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i;j &lt; arr.<span class="built_in">size</span>(); j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> ( arr[j] &lt; arr[tempIndex])&#123;</span><br><span class="line">tempIndex = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> temp = arr[i];</span><br><span class="line">arr[i] = arr[tempIndex];</span><br><span class="line">arr[tempIndex] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="3-插入排序"><a href="#3-插入排序" class="headerlink" title="3.插入排序"></a>3.插入排序</h3><ul><li><blockquote><p>增量为1，选取一个元素，将他元素插入到合适的位置。</p></blockquote></li></ul><p><font size=6> 时间复杂度O(n^2)、空间O(1)</font> </p><p><img src="/pictures/clipboard65.png" alt="img"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//3插入排序--------------增量为1的希尔排序</span></span><br><span class="line"><span class="comment">//逐渐交换    总数比较：2   3   4</span></span><br><span class="line"><span class="comment">//int cur  = index[i]</span></span><br><span class="line"><span class="comment">//index = i - 1;</span></span><br><span class="line"><span class="comment">//然后逐渐往前进行比较：之前的数组已经排序好了，所以把cur放在合适它的位置即可</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//将cur放在它的合适位置即可</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort3</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;arr.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line"><span class="keyword">int</span> cur = arr[i];<span class="comment">//当前元素</span></span><br><span class="line"><span class="keyword">int</span> index = i - <span class="number">1</span>;  <span class="comment">//当前元素的前一下标</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(index &gt;=<span class="number">0</span> &amp;&amp; arr[index] &gt; cur)</span><br><span class="line">&#123;</span><br><span class="line">arr[index + <span class="number">1</span>] = arr[index];</span><br><span class="line">index--;</span><br><span class="line">&#125;</span><br><span class="line">arr[index + <span class="number">1</span>] = cur;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="4-希尔排序"><a href="#4-希尔排序" class="headerlink" title="4.希尔排序"></a>4.希尔排序</h3><ul><li><blockquote><p>增量为n的插入排序，当元素总体上有序时，插入排序很高效，所以先大致排序整齐。</p></blockquote></li></ul><p><font size=6> 时间复杂度O(n * logN)、空间O(1)</font> </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//4.希尔排序，增量为gap的插入排序，先使其大致有序，然后再以增量减小的方式排序</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//插入排序在数组基本有序的情况下，效率是很高的。所以缩小增量排序--希尔排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort4</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> len = arr.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> gap = len / <span class="number">2</span>; gap &gt;= <span class="number">1</span>; gap /= <span class="number">2</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = gap; i &lt; arr.<span class="built_in">size</span>(); i += gap) &#123;</span><br><span class="line"><span class="keyword">int</span> cur = arr[i];</span><br><span class="line"><span class="keyword">int</span> index = i - gap;</span><br><span class="line"><span class="keyword">while</span> (index&gt;=<span class="number">0</span> &amp;&amp; cur&lt;=arr[index])</span><br><span class="line">&#123;</span><br><span class="line">arr[index + gap] = arr[index];</span><br><span class="line">index -= gap;</span><br><span class="line">&#125;</span><br><span class="line">arr[index + gap] = cur;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="5-归并排序"><a href="#5-归并排序" class="headerlink" title="5.归并排序"></a>5.归并排序</h3><ul><li><blockquote><p>先分再和，先将元素分成单个个体，然后两两组合，最后合并成一个有序数组</p></blockquote></li><li>先分再和，双指针一次将元素填入位置</li></ul><p><font size=6> 时间复杂度O(n * logN)、空间O(N)</font> </p><p><img src="/pictures/clipboard66.png" alt="img"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//5.归并排序---分而治之的思想，先将元素分组，然后22相结合排序</span></span><br><span class="line"><span class="comment">//先分，然后组合</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;arr, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;temp, <span class="keyword">int</span> L, <span class="keyword">int</span> mid, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> p1 = L;</span><br><span class="line"><span class="keyword">int</span> p2 = mid + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> p = L;</span><br><span class="line"><span class="keyword">while</span> (p1 &lt;= mid &amp;&amp; p2 &lt;= R) &#123;</span><br><span class="line"><span class="keyword">if</span> (arr[p1] &lt;= arr[p2]) </span><br><span class="line">temp[p++] = arr[p1++];</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">temp[p++] = arr[p2++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (p1 &lt;= mid) temp[p++] = arr[p1++];</span><br><span class="line"><span class="keyword">while</span> (p2 &lt;= R)   temp[p++] = arr[p2++];</span><br><span class="line"></span><br><span class="line">copy(temp.<span class="built_in">begin</span>() + L, temp.<span class="built_in">begin</span>() + R + <span class="number">1</span>, arr.<span class="built_in">begin</span>() + L);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//额外空间传入vector&lt;int&gt;&amp;tmp</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;arr, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;tmp, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (L &gt;= R)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> mid = (L + R) / <span class="number">2</span>;</span><br><span class="line">sort(arr, tmp, L,  mid);</span><br><span class="line">sort(arr, tmp, mid + <span class="number">1</span>, R);</span><br><span class="line"></span><br><span class="line">merge(arr, tmp, L, mid, R);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="6-快速排序"><a href="#6-快速排序" class="headerlink" title="6.快速排序"></a>6.快速排序</h3><ul><li><blockquote><p>先和再分，以第一个元素为基准数，大的放右，小的放左，然后依次再以基准数排序</p></blockquote></li><li><blockquote><p>注意：这里包含往下取整还是往上，注意</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(arr[p2] &gt;temp &amp;&amp; p1 &lt; p2)</span><br><span class="line">p2--;</span><br><span class="line"><span class="keyword">while</span> (arr[p1] &lt;temp &amp;&amp; p1 &lt; p2)</span><br><span class="line">p1++;</span><br></pre></td></tr></table></figure><font size=6> 时间复杂度O(n * logN)、空间O(logN)</font> </li></ul><p><img src="/pictures/clipboard67.png" alt="img"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//6.快速排序---以不同的基数，将其分组，分别排序</span></span><br><span class="line"><span class="comment">//一开始以第一个数，作为基数，大于放在右边小于放在左边</span></span><br><span class="line"><span class="comment">//然后继续左右两组在此快速排序</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort6</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;arr, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (L &gt;= R)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cur = arr[L];</span><br><span class="line"><span class="keyword">int</span> p1 = L, p2 = R;</span><br><span class="line"><span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (p1 &lt; p2) &#123;</span><br><span class="line"><span class="keyword">while</span> (arr[p2] &gt;= cur &amp;&amp;p1 &lt; p2)</span><br><span class="line">p2--;</span><br><span class="line"><span class="keyword">while</span> (arr[p1] &lt;= cur &amp;&amp;p1 &lt; p2)</span><br><span class="line">p1++;</span><br><span class="line"><span class="keyword">if</span> (p1 &lt; p2) &#123;</span><br><span class="line"><span class="keyword">int</span> temp = arr[p1];</span><br><span class="line">arr[p1] = arr[p2];</span><br><span class="line">arr[p2] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">arr[L] = arr[p1];</span><br><span class="line">arr[p1] = cur;</span><br><span class="line">sort6(arr, L, p1 - <span class="number">1</span>);</span><br><span class="line">sort6(arr, p1 + <span class="number">1</span>, R);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="7-堆排序"><a href="#7-堆排序" class="headerlink" title="7.堆排序"></a>7.堆排序</h3><ul><li><blockquote><p>利用完全二叉树的特点，构造大根堆，然后首位元素交换</p></blockquote></li><li>父节点：（i - 1）/ 2 （节点从0开始）   </li><li>左孩子：i*2 + 1     </li><li>右孩子：i*2 + 2<br><font size=6> 时间复杂度O(n * logN)、空间O(1)</font> </li></ul><p><img src="/pictures/clipboard68.png" alt="img"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//堆是完全二叉树，满的二叉树，构造成大根堆，然后将上方最大的数和子节点交换</span></span><br><span class="line"><span class="comment">//一个节点的：父节点--(i-1) /2</span></span><br><span class="line"><span class="comment">//            父节点-- i*2 + 1</span></span><br><span class="line"><span class="comment">//            父节点-- i*2 + 2</span></span><br><span class="line"><span class="comment">//将数组构造成大根堆，然后以此往复</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;arr, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line"><span class="comment">//father需要是最大节点</span></span><br><span class="line"><span class="keyword">int</span> index = i;</span><br><span class="line"><span class="keyword">int</span> fatherindex = (index - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (arr[index] &gt; arr[fatherindex]) &#123;</span><br><span class="line"><span class="keyword">int</span> temp = arr[index];</span><br><span class="line">arr[index] = arr[fatherindex];</span><br><span class="line">arr[fatherindex] = temp;</span><br><span class="line"></span><br><span class="line"><span class="comment">//index重新赋值</span></span><br><span class="line">index = fatherindex;</span><br><span class="line">fatherindex = (index - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort7</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;arr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> len = arr.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = len; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">heapSort(arr, i);</span><br><span class="line"></span><br><span class="line"><span class="comment">//交换元素</span></span><br><span class="line"><span class="keyword">int</span> temp = arr[<span class="number">0</span>];</span><br><span class="line">arr[<span class="number">0</span>] = arr[i - <span class="number">1</span>];</span><br><span class="line">arr[i - <span class="number">1</span>] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="非比较类排序"><a href="#非比较类排序" class="headerlink" title="非比较类排序"></a>非比较类排序</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minimumTotal</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; triangle)</span> </span>&#123;</span><br></pre></td></tr></table></figure><hr><h3 id="8-计数"><a href="#8-计数" class="headerlink" title="8.计数"></a>8.计数</h3><ul><li><blockquote><p>1-100最快的排数，适用于数字范围不大地数字段。</p></blockquote><ul><li>1.找到数组最大值和最小值</li><li>2.count_arr[arr[i] ]++</li><li>3.依次将数组填入</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//8.计数排序，输入的数据值转化为键值存在于新开辟的数组空间中</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort8</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;arr)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">max</span> = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">min</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (arr[i] &gt; <span class="built_in">max</span>)</span><br><span class="line"><span class="built_in">max</span> = arr[i];</span><br><span class="line"><span class="keyword">if</span> (arr[i] &lt; <span class="built_in">min</span>)</span><br><span class="line"><span class="built_in">min</span> = arr[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;count(<span class="built_in">max</span> + <span class="number">1</span>, <span class="number">0</span>);<span class="comment">//辅助数组1--存放元素出现统计次数</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;tmp(arr);         <span class="comment">//辅助数组2--原数组</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it : arr) &#123;        <span class="comment">//记录下标</span></span><br><span class="line">count[it]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="built_in">max</span>; i++) &#123;   <span class="comment">//记录当前元素比他大数的数量</span></span><br><span class="line">count[i] = count[i] + count[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = arr.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">arr[count[tmp[i]]<span class="number">-1</span>] = tmp[i];</span><br><span class="line"><span class="comment">//tmp[i] 数组的一个数，count[ tmp[i] ]大于这个数出现的次数 </span></span><br><span class="line"><span class="comment">//arr[count[tmp[i]]]  相应的位置就应该是那个数  tmp[i]</span></span><br><span class="line">count[tmp[i]]--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="9-基数"><a href="#9-基数" class="headerlink" title="9.基数"></a>9.基数</h3><ul><li><blockquote><p>按照个位、十位、百位依次顺序排序。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minimumTotal</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; triangle)</span> </span>&#123;</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="10-桶排序"><a href="#10-桶排序" class="headerlink" title="10.桶排序"></a>10.桶排序</h3><ul><li><blockquote><p>1.首先对元素进行分组 2.组内元素快速排序 3.依次将元素填充</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//9.桶排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort9</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;arr)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">max</span> = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (arr[i] &gt; <span class="built_in">max</span>)</span><br><span class="line"><span class="built_in">max</span> = arr[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;temp(<span class="built_in">max</span> + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">temp[arr[i]]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="built_in">max</span>; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (temp[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; temp[i]; j++) &#123;</span><br><span class="line">arr[count] = i;</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
          <category> 十大排序算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++ / 数据结构</title>
      <link href="/2020/07/28/C-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-1/"/>
      <url>/2020/07/28/C-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-1/</url>
      
        <content type="html"><![CDATA[<h2 id="哈希表（散列表）"><a href="#哈希表（散列表）" class="headerlink" title="哈希表（散列表）"></a>哈希表（散列表）</h2><h3 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h3><ul><li><blockquote><p>哈希表是一种数据结构。一种<strong>Value数据内容</strong>和<strong>Key数据存放地址</strong>之间的<strong>映射关系</strong>。</p></blockquote></li><li><p>关键是Key和value值，我们通过Key值直接访问Value值</p></li><li><p>这种<strong>反应映射关系</strong>的函数称为：<strong>散列函数</strong> 。存放数据的数组称为散列表。</p></li></ul><p><img src="/pictures/clipboard74.png" alt="img"></p><h3 id="2-作用以及优点和缺点"><a href="#2-作用以及优点和缺点" class="headerlink" title="2.作用以及优点和缺点"></a>2.作用以及优点和缺点</h3><ul><li><blockquote><p>我们需要一种<strong>快速寻址</strong>，<strong>插入删除方便</strong>的数据结构。</p></blockquote></li><li>数组是内存中的连续空间，<strong>寻址快速，插入删除困难</strong>。</li><li>链表是内存中不连续的空间，<strong>寻址困难，插入删除快速</strong>。</li><li><strong>而哈希表是一种快速寻址，插入删除容易的数据结构。</strong></li></ul><h4 id="优点和缺点"><a href="#优点和缺点" class="headerlink" title="优点和缺点"></a>优点和缺点</h4><ul><li>优点：一对一查找高效 O(1)</li><li>缺点：散列函数定义困难，散列冲突</li><li>散列冲突：不同关键字，返回同个散列地址，散列函数定义困难<ul><li>优秀的散列函数  =   计算简单  + 分布均匀</li></ul></li></ul><ul><li><blockquote><p>散列冲突的解决方案：</p></blockquote></li></ul><ol><li><strong>开放寻址法</strong>：当发现散列冲突后，按着顺序往下查找空余位置存放数据。简单来说就是进行<strong>二次探测</strong>。</li><li><strong>链表法</strong>：在同一个Key对应的位置使用链表，从而达到存放多个数据的目的</li></ol><h3 id="3-应用"><a href="#3-应用" class="headerlink" title="3.应用"></a>3.应用</h3><ol><li><strong>安全领域的加密算法</strong>：把一些不同长度的信息转化为杂乱128位的编码，编码值叫Hash值。</li><li><strong>数据的快速查找</strong>：哈希表，又称散列，快捷的查找技术。原查找：A去和{532415646541A}比较  哈希查找：我知道了key值，直接去找对应位置的value值。</li><li><strong>大数据处理</strong>中有着广泛的应用，提高查找的效率</li></ol><h3 id="4-常见的散列函数"><a href="#4-常见的散列函数" class="headerlink" title="4.常见的散列函数"></a>4.常见的散列函数</h3><ul><li><blockquote><p>1.除法散列法<br>index = value % 16 上表即是</p></blockquote></li><li><blockquote><p>2.平方散列法</p></blockquote></li><li><p>index = (value * value) &gt;&gt; 28     右移—转换为除法为2^28次</p></li><li><p>数值分配均匀是可以的，但是value很大会溢出</p></li><li><blockquote><p>3.斐波那契散列法    /   （黄金分割法）</p></blockquote></li><li><p>找到一个合理的乘数</p></li><li><p>1，对于16位整数而言，这个乘数是40503 </p></li><li><p>2，对于32位整数而言，这个乘数是2654435769 </p></li><li><p>3，对于64位整数而言，这个乘数是11400714819323198485</p></li><li><p>对于32位整数：</p><ul><li>index = (value * 2654435769) &gt;&gt; 28</li></ul></li><li><p>散列表分布更加均匀</p></li></ul><hr><h2 id="二叉搜索树（根本）"><a href="#二叉搜索树（根本）" class="headerlink" title="二叉搜索树（根本）"></a>二叉搜索树（根本）</h2><ul><li><blockquote><p>左中右 / 左 &lt; 中 &lt; 右</p></blockquote></li></ul><hr><h2 id="平衡二叉树（AVL树）-O-logN"><a href="#平衡二叉树（AVL树）-O-logN" class="headerlink" title="平衡二叉树（AVL树）_O(logN)"></a>平衡二叉树（AVL树）_O(logN)</h2><h3 id="1-作用"><a href="#1-作用" class="headerlink" title="1.作用"></a>1.作用</h3><ul><li><blockquote><p>平衡二叉树是基于<strong>二分法</strong>来提高数据查找速度的二叉树结构。</p></blockquote></li></ul><h3 id="2-定义"><a href="#2-定义" class="headerlink" title="2.定义"></a>2.定义</h3><ol><li>二叉搜索树，遵循高度差原则（左右子树高度差不大于1）<ul><li>平衡因子：左子树高度 - 右子树高度，取值范围[-1，1]</li><li>最小不平衡子树：距离插入节点最近的，打破平衡的子树。</li></ul></li></ol><h3 id="3-平衡二叉树的元素插入"><a href="#3-平衡二叉树的元素插入" class="headerlink" title="3.平衡二叉树的元素插入"></a>3.平衡二叉树的元素插入</h3><ul><li><blockquote><p>当插入元素打破平衡二叉树平衡时（平衡因子变2），需要进行节点的调整。</p></blockquote></li></ul><ol><li>LL型——root节点左孩子的左孩子+新节点——打破平衡</li><li>RR型</li><li>LR型</li><li>RL型</li></ol><hr><ul><li><blockquote><p><strong>LL型</strong>（和RR型都是断开两个节点，然后平衡子树）<br><img src="/pictures/clipboard75.png" alt="img"><br><img src="/pictures/clipboard76.png" alt="img"><br><img src="/pictures/clipboard77.png" alt="img"></p></blockquote></li><li><strong>和左孩子连接的两处，断开</strong></li><li><strong>左孩子变成新根节点</strong></li><li><strong>依次连接到左孩子上</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BTNode *<span class="title">LL_rotate</span><span class="params">(BTNode *y)</span> </span>&#123;</span><br><span class="line">BTNode *x = y-&gt;left;<span class="comment">//保存临时左孩子</span></span><br><span class="line">y-&gt;left = x-&gt;right;<span class="comment">//老根加新L</span></span><br><span class="line">x-&gt;right = y; <span class="comment">//老根连到新根</span></span><br><span class="line"></span><br><span class="line">y-&gt;<span class="built_in">height</span> = <span class="built_in">max</span>(<span class="built_in">height</span>(y-&gt;left), <span class="built_in">height</span>(y-&gt;right)) + <span class="number">1</span>;  <span class="comment">//计算变更后树的高度</span></span><br><span class="line">x-&gt;<span class="built_in">height</span> = <span class="built_in">max</span>(<span class="built_in">height</span>(x-&gt;left), <span class="built_in">height</span>(x-&gt;right)) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><ul><li><blockquote><p><strong>RR型</strong>（和LL型类似）<br><img src="/pictures/clipboard78.png" alt="img"></p></blockquote></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BTNode *<span class="title">rr_rotate</span><span class="params">(struct Node *y)</span> </span>&#123;</span><br><span class="line">BTNode *x = y-&gt;right;<span class="comment">//保存临时右孩子</span></span><br><span class="line">y-&gt;right = x-&gt;left;<span class="comment">//老根加新R</span></span><br><span class="line">x-&gt;left = y;<span class="comment">//老根连到新根</span></span><br><span class="line"></span><br><span class="line">y-&gt;<span class="built_in">height</span> = <span class="built_in">max</span>(<span class="built_in">height</span>(y-&gt;left), <span class="built_in">height</span>(y-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">x-&gt;<span class="built_in">height</span> = <span class="built_in">max</span>(<span class="built_in">height</span>(x-&gt;left), <span class="built_in">height</span>(x-&gt;right)) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><ul><li><blockquote><p><strong>LR型</strong>（利用LL型和RR型）<br><img src="/pictures/clipboard79.png" alt="img"><br><img src="/pictures/clipboard80.png" alt="img"></p></blockquote></li><li><strong>断开三个节点，然后平衡子树，可以利用LL和RR来实现</strong></li></ul><ol><li><strong>先对左孩子RR旋转</strong></li><li><strong>再对整体LL旋转</strong></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BTNode* <span class="title">lr_rotate</span><span class="params">(BTNode* y)</span> </span>&#123;</span><br><span class="line">BTNode* x = y-&gt;left;<span class="comment">//临时变量L节点</span></span><br><span class="line">y-&gt;left = rr_rotate(x);<span class="comment">//对根节点的左节点进行RR变换</span></span><br><span class="line"><span class="keyword">return</span> ll_rotate(y);<span class="comment">//再对根节点进行LL变换</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><ul><li><blockquote><p><strong>RL型</strong>（类似）<br><img src="/pictures/clipboard81.png" alt="img"></p></blockquote></li></ul><ol><li><strong>先对右孩子LL旋转</strong></li><li><strong>再对整体RR旋转</strong></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BTNode* <span class="title">rl_rotate</span><span class="params">(BTNode* y)</span> </span>&#123;</span><br><span class="line">BTNode* x = y-&gt;right;<span class="comment">//临时变量R节点</span></span><br><span class="line">y-&gt;right = ll_rotate(x);<span class="comment">//对根节点的右节点的R节点进行LL变换</span></span><br><span class="line"><span class="keyword">return</span> rr_rotate(y);<span class="comment">//对根节点进行RR变换</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-平衡二叉树的特点"><a href="#4-平衡二叉树的特点" class="headerlink" title="4.平衡二叉树的特点"></a>4.平衡二叉树的特点</h3><ol><li>查找元素所花时间不固定，平均log2n。</li><li>高度平衡，维护代价比较高，需要不断的旋转二叉树保持稳定。</li></ol><hr><h2 id="红黑树-O-logN"><a href="#红黑树-O-logN" class="headerlink" title="红黑树_O(logN)"></a>红黑树_O(logN)</h2><h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><ul><li><blockquote><p>关键性质：从根结点出发，每条路径最大差异为一倍，所以保证了红黑树大致的平衡</p></blockquote></li><li>极限情况：max = 2 * min</li></ul><h3 id="1-定义-1"><a href="#1-定义-1" class="headerlink" title="1.定义"></a>1.定义</h3><ul><li><blockquote><p>二叉搜索树，同时遵循<strong>红定理</strong>和<strong>黑定理</strong></p></blockquote><ul><li>没有连续的红色节点</li><li>所有路径上黑色节点个数相同Sum（根节点为黑色）</li></ul></li></ul><p><img src="/pictures/clipboard82.png" alt="img"></p><h3 id="2-红黑树的旋转后、重新着色（插入）"><a href="#2-红黑树的旋转后、重新着色（插入）" class="headerlink" title="2.红黑树的旋转后、重新着色（插入）"></a>2.红黑树的旋转后、重新着色（插入）</h3><ul><li><blockquote><p>旋转较少，维护比较容易</p></blockquote></li><li><blockquote><p>我们默认插入的是<strong>红色节点</strong>，因为默认插入黑色节点时，开销太大。</p></blockquote></li></ul><ol><li>当父节点为<strong>黑色</strong>，直接插入</li><li>当父节点为<strong>红色</strong>，祖父节点必为黑色。<ol><li><strong>叔叔存在且红</strong>——父亲变黑色节点，然后根据颜色变化继续向上调整，左旋 / 右旋。</li><li><strong>叔叔存在且黑</strong>——和叔叔交换，并调整位置满足二叉搜索树</li><li><strong>叔叔不存在</strong>——占据叔叔位置，并调整位置满足二叉搜索树</li></ol></li></ol><h3 id="3-红黑树的左旋和右旋（需要指定父节点）"><a href="#3-红黑树的左旋和右旋（需要指定父节点）" class="headerlink" title="3.红黑树的左旋和右旋（需要指定父节点）"></a>3.红黑树的左旋和右旋（需要指定父节点）</h3><ul><li><blockquote><p>左旋</p></blockquote></li><li>类似平衡二叉树的RR旋转，<strong>加上每个节点还有指向父节点指针</strong>。<br><img src="/pictures/L.gif" alt="img"><br><img src="/pictures/clipboard91.png" alt="img"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Left_Rotate</span><span class="params">(BiTreeNode* root, BiTreeNode* x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//1</span></span><br><span class="line">BiTreeNode* y = x-&gt;rightChild;</span><br><span class="line"><span class="comment">//2</span></span><br><span class="line">x-&gt;rightChild = y-&gt;leftChild;</span><br><span class="line"></span><br><span class="line"><span class="comment">//指定父节点</span></span><br><span class="line">y-&gt;leftChild-&gt;p = x;</span><br><span class="line">y-&gt;p = x-&gt;p;</span><br><span class="line"></span><br><span class="line"><span class="comment">//指定新root的根节点</span></span><br><span class="line"><span class="keyword">if</span> (x-&gt;p == <span class="literal">NULL</span>)</span><br><span class="line">root = y;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (x-&gt;p-&gt;leftChild == x)</span><br><span class="line">x-&gt;p-&gt;leftChild = y;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">x-&gt;p-&gt;rightChild = y;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3</span></span><br><span class="line">y-&gt;leftChild = x;</span><br><span class="line"><span class="comment">//指定父节点</span></span><br><span class="line">x-&gt;p = y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><blockquote><p>右旋</p></blockquote></li><li>类似平衡二叉树的LL旋转，加上每个节点还有指向父节点指针<br><img src="/pictures/R.gif" alt="img"><br><img src="/pictures/clipboard92.png" alt="img"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Right_Rotate</span><span class="params">(BiTreeNode* root, BiTreeNode* y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//1</span></span><br><span class="line">BiTreeNode* x = y-&gt;leftChild;</span><br><span class="line"><span class="comment">//2</span></span><br><span class="line">y-&gt;leftChild = x-&gt;rightChild;</span><br><span class="line"><span class="comment">//指定父节点</span></span><br><span class="line">x-&gt;rightChild-&gt;p = y;</span><br><span class="line">x-&gt;p = y-&gt;p;</span><br><span class="line"></span><br><span class="line"><span class="comment">//指定新root的根节点</span></span><br><span class="line"><span class="keyword">if</span> (y-&gt;p == <span class="literal">NULL</span>)</span><br><span class="line">root = x;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (y-&gt;p-&gt;rightChild == y)</span><br><span class="line">y-&gt;p-&gt;rightChild = x;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">y-&gt;p-&gt;leftChild = x;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3</span></span><br><span class="line">x-&gt;rightChild = y;</span><br><span class="line"><span class="comment">//指定父节点</span></span><br><span class="line">y-&gt;p = x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="B树-B-树-B-树特点（单节点多Value）"><a href="#B树-B-树-B-树特点（单节点多Value）" class="headerlink" title="B树 / B+树 / B*树特点（单节点多Value）"></a>B树 / B+树 / B*树特点（单节点多Value）</h2><ol><li>B树 = 单节点多Value</li><li>B+树 = <strong>仅叶子节点保存Value值</strong>，底层<strong>有序链表相连</strong>。</li><li>B* 树 = B+树 + 再在其枝节点加上<strong>兄弟节点指针</strong>。</li></ol><h2 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h2><h3 id="1-特点：单节点多Value，树的层数更低"><a href="#1-特点：单节点多Value，树的层数更低" class="headerlink" title="1.特点：单节点多Value，树的层数更低"></a>1.特点：单节点多Value，树的层数更低</h3><h3 id="2-定义——H树的阶数"><a href="#2-定义——H树的阶数" class="headerlink" title="2.定义——H树的阶数"></a>2.定义——H树的阶数</h3><p><font size=6> 根据阶数H定义</font> </p><ol><li>满足二叉搜索树</li><li><strong>叶子节点同层</strong></li><li><strong>节点的关键字数量</strong>（Value）：【ceil(H/2) - 1，H - 1】(叶子无限制)</li><li><strong>节点的索引指针数量</strong>（left、right） 【2 ， H】，即<strong>索引指针</strong></li></ol><ul><li><p>子节点：除了叶子的（left、right）</p></li><li><p>枝节点：除了根和叶子的（value）</p></li><li><blockquote><p>简单来说</p></blockquote></li></ul><ol><li>满足二叉搜索树</li><li>节点的<strong>Value值</strong>和<strong>left、right指针</strong>发生了变化，一个节点不单单包含一个Value值。</li></ol><p><img src="/pictures/clipboard84.png" alt="img"></p><h3 id="3-元素的插入和删除"><a href="#3-元素的插入和删除" class="headerlink" title="3.元素的插入和删除"></a>3.元素的插入和删除</h3><ul><li><blockquote><p>当我们树的高度H = 5时</p></blockquote></li><li><p>left/right数量——[2,5]——索引指针（肯定比Value数量+1）</p></li><li><p>value数量——[2,4]——枝节点</p></li><li><blockquote><p>插入构造图示：</p></blockquote></li><li><p>A：先插入4个数，当插入地5个时，不满足了关键字数，所以需要拆分</p><ul><li><img src="/pictures/clipboard85.png" alt="img"></li></ul></li><li><p>B：再插入23、29，此时区中间元素，将元素分为左中右三块</p><ul><li><img src="/pictures/clipboard86.png" alt="img"></li></ul></li><li><p>C：再插入50、28，此时区中间元素，将元素分为左中右三块</p><ul><li><img src="/pictures/clipboard87.png" alt="img"></li></ul></li><li><blockquote><p>删除构造图示：为了满足value树[2,4]</p></blockquote></li><li><p><img src="/pictures/clipboard88.png" alt="img"></p></li></ul><h3 id="4-特点"><a href="#4-特点" class="headerlink" title="4.特点"></a>4.特点</h3><ul><li><blockquote><p>相比于平衡二叉树，每个节点的关键字增加了，树的层级变少了，减少了数据查找的次数和复杂度。</p></blockquote></li></ul><hr><h2 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h2><h3 id="1-特点"><a href="#1-特点" class="headerlink" title="1.特点"></a>1.特点</h3><ul><li>B树的升级版本，更加充分的利用节点的空间</li></ul><h3 id="2-定义-1"><a href="#2-定义-1" class="headerlink" title="2.定义"></a>2.定义</h3><ol><li>叶子节点保存Value值，其他节点只进行数据索引<ul><li>非叶子节点可保存的数据量大大增加</li><li>所有查询时间相同</li></ul></li><li>叶子节点Value值按顺序保存，同时底层叶子节点保存右边节点指针<ul><li>类似顺序链表，首尾相连，便于区域数据的查询</li></ul></li><li>Value值和索引指针数量相同，而B树索引指针数量 = Value值数量 + 1</li></ol><ul><li><blockquote><p>定义图示<br><img src="/pictures/clipboard89.png" alt="img"></p></blockquote></li></ul><h3 id="3-特点"><a href="#3-特点" class="headerlink" title="3.特点"></a>3.特点</h3><ol><li>枝节点只进行数据索引，不保存关键字的指针。<ul><li>枝节点存放的信息越多，层级更少。</li></ul></li><li>所有Value值都在叶子节点上，查询更稳定。</li><li>底部数据构成了一个有序链表，<strong>查询区间数据</strong>更加方便。</li></ol><hr><h2 id="B-树-1"><a href="#B-树-1" class="headerlink" title="B*树"></a>B*树</h2><h3 id="和B-树的区别"><a href="#和B-树的区别" class="headerlink" title="和B+树的区别"></a>和B+树的区别</h3><ul><li><blockquote><p>B* 树是B+树的升级版本，<strong>枝节点增加增加指向兄弟节点的指针</strong>。<br><img src="/pictures/clipboard90.png" alt="img"></p></blockquote></li></ul><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li>节点的分裂不同<ul><li>B+树：一半元素放置到新节点上，父节点增加新节点的索引指针。</li><li>B* 树：<ul><li>1.首先查询兄弟节点是否空余，空余直接移至兄弟节点。</li><li>2.兄弟不空余，原节点和兄弟节点插入新节点，移动1 / 3元素至新节点，改变对应关键字。</li></ul></li></ul></li></ul><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li><blockquote><p>将<strong>节点的最低利用率从1/2提升到2/3</strong>，B* 树比B+树分配新节点的概率要低，空间使用率更高。</p></blockquote></li><li><blockquote><p>节点的利用率更高，从1/2变成2/3，新节点的分配概率更低。</p></blockquote></li></ul><hr><h2 id="所有树的总结"><a href="#所有树的总结" class="headerlink" title="所有树的总结"></a>所有树的总结</h2><h3 id="1-All树"><a href="#1-All树" class="headerlink" title="1.All树"></a>1.All树</h3><ul><li><blockquote><p>二叉树搜索树</p></blockquote></li><li>左&lt;中&lt;右的顺序关系</li></ul><hr><ul><li><blockquote><p>平衡二叉树</p></blockquote></li><li>满足二叉搜索树</li><li>子树的高度差不大于1</li><li><strong>特点：</strong>平衡二叉树是基于<strong>二分法</strong>来提高数据查找速度的二叉树结构，维护成本高。</li></ul><hr><ul><li><blockquote><p>红黑树</p></blockquote></li><li>满足二叉搜索树</li><li>满足红定理和黑定理（无连续红、路径黑Sum相同、根节点黑）</li><li><strong>特点：</strong>黑定理保证了红黑树大致的平衡，同时无需高强度的旋转，维护成本较低。</li></ul><hr><ul><li><blockquote><p>B树（单节点多Value）</p></blockquote></li><li><p>满足二叉搜索树</p></li><li><p>每个节点的Value值和索引指针不再局限于1个和2个，每个节点可以存放更多的数据，<strong>层数更低</strong>，<strong>查找时间更短</strong>。</p></li><li><p>索引指针【2 ， H】，Value【 ceil(H) - 1，H - 1 】向上取整</p></li><li><p><strong>特点</strong>：每个节点的Value值和索引指针不再局限于1个和2个，每个节点可以存放更多的数据，<strong>层数更低</strong>，<strong>查找时间更短</strong>。</p></li></ul><hr><ul><li><blockquote><p>B+树（Value全在叶子节点 + 底层顺序链表）</p></blockquote></li><li>B树的升级版本，只有叶子节点保存Value值，其他节点只进行数据索引</li><li>底层链表相连，枝节点Value值和索引指针一一对应。</li><li><strong>特点</strong>：查询时间稳定，同时<strong>枝节点可以保存更多的节点信息</strong>，层数降低。<strong>底层有序链表，查询区间数据更便捷</strong>。</li></ul><hr><ul><li><blockquote><p>B* 树</p></blockquote></li><li>B+树的基础上增加<strong>枝节点的兄弟指针</strong>，节点利用率1/2，变成2/3，分配新节点的概率更低。</li></ul><hr><h3 id="2-B树三种树的优劣-Important"><a href="#2-B树三种树的优劣-Important" class="headerlink" title="2.B树三种树的优劣 / Important"></a>2.B树三种树的优劣 / Important</h3><ul><li>B树：单节点多value值和多索引指针，当经常访问的关键字靠经根节点时，B树查询速度较快。</li><li>而B+树只有叶子节点保存Value值，其他节点只作数据索引：更加稳定，层级较少，每次查询的时间相同。同时底部数据是连续链表，适合查询一段区间的数。</li><li>而B* 树在B+树的基础上增加了非叶子节点的兄弟节点指针，分配新节点的概率低，在元素分裂的时候移动元素为1/3，比B+的1/2空间利用率更高。</li></ul><hr><h3 id="3-拓展：Trie字典树（前缀树-空间换时间）"><a href="#3-拓展：Trie字典树（前缀树-空间换时间）" class="headerlink" title="3.拓展：Trie字典树（前缀树 / 空间换时间）"></a>3.拓展：Trie字典树（前缀树 / 空间换时间）</h3><ul><li>Trie字典树：又称前缀树，利用公共前缀来提高降低查询所需的时间。典型的空间换时间。</li><li>主要用于排序和统计大量的字符串，经常被搜索引擎用于频繁词的统计。</li><li>优点：最大限度地减少无谓的字符串比较，查询效率比哈希表高。</li><li>Trie的核心思想是空间换时间。利用字符串的公共前缀来降低查询时间的开销以达到提高效率的目的。</li></ul><hr><h2 id="问题问题"><a href="#问题问题" class="headerlink" title="问题问题"></a>问题问题</h2><h3 id="1-说一下平衡二叉树和红黑树的定义、特定、区别"><a href="#1-说一下平衡二叉树和红黑树的定义、特定、区别" class="headerlink" title="1.说一下平衡二叉树和红黑树的定义、特定、区别"></a>1.说一下平衡二叉树和红黑树的定义、特定、区别</h3><ul><li><blockquote><p>平衡二叉树,又名AVL树，是基于<strong>二分法</strong>的而创立的便于数据查找的数据结构。</p></blockquote></li></ul><ol><li>他是一棵二叉搜索树，同时满足高度定理。就是所有节点的子树高度差不大于1。</li><li>插入和删除的时间复杂度都是O（log2n），由于其高度平衡，所以维护成本很高，一直需要旋转，从而满足平衡二叉树结构。<ul><li>主要有四种旋转LL、RR、LR、RL旋转。</li></ul></li></ol><hr><ul><li><blockquote><p>红黑树,简称RB树，是一棵加了颜色信息的二叉树。</p></blockquote></li></ul><ol><li><p>他同样也是一棵二叉搜素树，同时满足红定理和黑定理。</p><ul><li>红定理就是其没有连续的红色节点。</li><li>黑定理就是其每个节点的路径上的黑色节点数是相同的。这个性质保证了红黑树的大致平衡性。</li></ul></li><li><p>插入和删除时没有平衡二叉树那么多的旋转。同时我们默认插入的是红色节点，所以有4种情况。</p></li></ol><ul><li>1.父亲为黑直接满足</li><li>2.父亲为红，那么爷爷肯定为黑，我们只需要讨论叔叔节点即可。</li></ul><ol start="2"><li>旋转主要有左旋和右旋，最多旋转三次，就能恢复红黑树的性质。</li></ol><hr><ul><li><blockquote><p>总结：红黑树<strong>放弃了平衡二叉树的高度平衡</strong>，追求大致平衡。</p></blockquote></li><li>平衡二叉树频繁插入和删除操作，需要频繁的旋转，导致效率下降。</li><li>而红黑树每次插入最多只需要三次旋转就能达到平衡，实现较为简单，所以运用比较广泛，如STL种的Set和Map容器底层都是红黑树。       </li></ul><h3 id="2-平衡二叉树AVL、红黑树、B树的运用场景"><a href="#2-平衡二叉树AVL、红黑树、B树的运用场景" class="headerlink" title="2.平衡二叉树AVL、红黑树、B树的运用场景"></a>2.平衡二叉树AVL、红黑树、B树的运用场景</h3><ul><li><p>1.平衡二叉树<strong>运用较少</strong>，维护代价较高：<strong>window对进程的地址管理</strong>运用到了平衡二叉树</p></li><li><p>2.红黑树：广泛运用于C++中STL中，<strong>set和map底层都是红黑树</strong></p></li><li><p>3.B/B+树：用于磁盘文件索引、数据索引、数据库索引等</p></li></ul><h3 id="3-请你说一下哈夫曼-霍夫曼编码"><a href="#3-请你说一下哈夫曼-霍夫曼编码" class="headerlink" title="3.请你说一下哈夫曼/霍夫曼编码"></a>3.请你说一下哈夫曼/霍夫曼编码</h3><ul><li>霍夫曼编码是霍夫曼树的一种应用，广泛应用于文件压缩。</li><li>其使用<strong>字符出现的频率</strong>，建立霍夫曼树，路径上的0和1来表示字符。</li></ul><h3 id="4-Map-Set的底层为什么用红黑树"><a href="#4-Map-Set的底层为什么用红黑树" class="headerlink" title="4.Map / Set的底层为什么用红黑树"></a>4.Map / Set的底层为什么用红黑树</h3><ul><li>AVL 树是高度平衡的，频繁的插入和删除，会引起频繁的旋转，导致效率下降，维护成本很高。</li><li>红黑树放弃了高度平衡的树，同时他满足黑定理，红定理，保证了他大致上也是平衡的。而插入和删操作最多三次旋转，效率较高，维护成本低。</li></ul><h3 id="5-说一下B树"><a href="#5-说一下B树" class="headerlink" title="5.说一下B树"></a>5.说一下B树</h3><ul><li><blockquote><p>首先B树也是一个二叉搜索树，他和红黑树以及平衡二叉树的最大区别在于：他单节点可以多Value值和多索引指针。</p></blockquote></li><li>Value值和索引指针的数量取决于树的阶数，索引指针一般为【2，H】，Value值为【ceil(H/2)-1，H-1】(枝节点)</li><li>这样导致B树有很大的优点：就是<strong>节点储存的信息更多了</strong>，<strong>树的层数降低了</strong>，节点的利用和访问更加高效。</li><li>被广泛的运用于磁盘文件索引、数据索引、数据库索引等。</li></ul><h3 id="6-说一下B-树"><a href="#6-说一下B-树" class="headerlink" title="6.说一下B+树"></a>6.说一下B+树</h3><ul><li><blockquote><p>B+树是B树的变形，他只在叶子节点储存Value值，枝节点只保存索引指针。同时底层用有序链表相连。</p></blockquote></li><li><blockquote><p>这样导致B+树搜索数据的<strong>时间是稳定的</strong>，同时<strong>枝节点可以保存更多的信息</strong>。底层的有序链表便于对于<strong>区间数据据的查询</strong>。</p></blockquote></li></ul><h3 id="7-请你说一下map和unordered-map的底层实现"><a href="#7-请你说一下map和unordered-map的底层实现" class="headerlink" title="7.请你说一下map和unordered_map的底层实现"></a>7.请你说一下map和unordered_map的底层实现</h3><ul><li><blockquote><p>map底层是<strong>红黑树</strong>实现的，因此map中元素排列是有序的。</p></blockquote></li><li><blockquote><p>underordered_map是<strong>哈希表</strong>实现的，所以其元素是无序的，由对应的KeyValue对应值对应。</p></blockquote></li><li><p>map：有顺序要求</p></li><li><p>优点：<strong>有序性</strong>，这是map结构最大的优点，</p></li><li><p>缺点：查询速度慢，占用空间大</p><ul><li>其每个节点需要**保存父节点，</li><li>同时需要相应的反转操作**。</li></ul></li><li><p>unordered_map：无顺序要求</p></li><li><p>优点： 因为内部实现了哈希表，因此其查找<strong>速度非常的快</strong></p></li><li><p>缺点： 建立哈希表比较困难，<strong>建立合适的散列函数比较困难</strong>。</p></li></ul><h3 id="8-请你说一下红黑树的性质还有左右旋转"><a href="#8-请你说一下红黑树的性质还有左右旋转" class="headerlink" title="8.请你说一下红黑树的性质还有左右旋转"></a>8.请你说一下红黑树的性质还有左右旋转</h3><ul><li><blockquote><p>红黑树是在平衡二叉树基础上提出来的，由于平衡二叉树的高度平衡性，使得插入删除等操作旋转次数过多，开销太大。</p></blockquote></li><li><p>而红黑树相较于平衡二叉树，不需要频繁的旋转，<strong>最多旋转三次便可满足所有条件</strong>，同时满足黑定理和红定理大致上也相对平衡。</p></li><li><blockquote><p>红黑树的性质:</p></blockquote></li><li><p>满足：红定理和黑定理</p></li></ul><ol><li>其满足二叉搜索树</li><li>红定理：无连续的红色节点</li><li>黑定理：根节点为黑，每条路径上黑色节点个数相同。</li></ol><ul><li><blockquote><p>红黑树的旋转：<strong>旋转</strong>以后，<strong>变换颜色</strong>。直至满足。</p></blockquote></li><li>一般插入最多旋转2次，删除3次就可以满足，然后变换颜色。</li><li>左旋：类似平衡二叉树的RR旋转，同时重新定义指向父节点的指针。</li><li>右旋：类似平衡二叉树的LL旋转，同时重新定义指向父节点的指针。</li><li>我们默认插入的节点颜色是红色，这样父亲是黑色，只需要讨论叔叔节点的情况即可。</li></ul><h3 id="9-Stack-overflow-栈溢出，举个简单的例子导致栈溢出"><a href="#9-Stack-overflow-栈溢出，举个简单的例子导致栈溢出" class="headerlink" title="9.Stack overflow/栈溢出，举个简单的例子导致栈溢出"></a>9.Stack overflow/栈溢出，举个简单的例子导致栈溢出</h3><ul><li><p>变量写入的字节数，超过了申请的字节数。</p></li><li><p>数组越界</p></li><li><blockquote><p>栈溢出原因：</p></blockquote></li></ul><ol><li>临时变量大小过大。       <ul><li>解决：增大栈空间，或者使用malloc和new动态分配内存空间</li></ul></li><li>递归调用层次太多。递归函数在运行时，会进行压栈操作，压栈次数太多会导致栈溢出。</li><li>指针或者<strong>数组越界</strong>。</li></ol><h3 id="10-栈和堆的区别，为什么栈快"><a href="#10-栈和堆的区别，为什么栈快" class="headerlink" title="10.栈和堆的区别，为什么栈快"></a>10.栈和堆的区别，为什么栈快</h3><ul><li><p>E栈区—存放函数局部变量，形参和函数返回值等（最快）</p></li><li><p>D堆区—存放 malloc 和 new 、自己开辟的内存，程序员手动开辟和释放</p></li><li><p>C静态区（全局区）—存放静态变量和全局变量</p><ul><li>DATA段：全局初始化区</li><li>BSS段：全局未初始化区</li></ul></li><li><p>B文字常量区—存放常量，如：10，字符串常量等等</p></li><li><p>A代码区—存放程序的代码区</p></li><li><blockquote><p>栈：由高地址往低地址扩展，<strong>系统自动管理，自动优化</strong>。系统停供支持，分配效率高。</p></blockquote></li><li><blockquote><p>堆：由低地址往高地址扩展，由程序员手动申请释放内存，多了很多步骤，存在内存碎片，分配效率低，所以较之栈慢。</p></blockquote></li></ul><ul><li>同时<strong>栈位于一级缓存中</strong>，<strong>堆在二级缓存中做缓存</strong>。</li></ul><h3 id="11-说一下数组和链表的区别"><a href="#11-说一下数组和链表的区别" class="headerlink" title="11.说一下数组和链表的区别"></a>11.说一下数组和链表的区别</h3><ul><li><p>数组是元素在连续内存空间，支持随机访问，寻址快速，但是删除插入效率低。而且固定不能动态扩展。</p></li><li><p>链表中元素不是连续存储的，通过指针关联，插入删除快，内存利用率高，大小灵活。但是寻址快速困难，不支持随机访问。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> learn </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++ / 数据库 / 增删修查</title>
      <link href="/2020/07/24/C-%E6%95%B0%E6%8D%AE%E5%BA%93-1/"/>
      <url>/2020/07/24/C-%E6%95%B0%E6%8D%AE%E5%BA%93-1/</url>
      
        <content type="html"><![CDATA[<h2 id="0-基本概念"><a href="#0-基本概念" class="headerlink" title="0.基本概念"></a>0.基本概念</h2><ul><li><blockquote><p>主键</p></blockquote></li><li>数据表中的唯一索引，可以<strong>标识</strong>出数据表中的其他所有信息。<strong>不重复、不为空</strong>。</li><li>一张表中主键只有一个，但是可以包含<strong>多字段</strong>。（就是多个属性组成一个主键）</li></ul><hr><ul><li><blockquote><p>外键：</p></blockquote></li><li>其他表的主键，可以重复，可以空。</li><li>作用：是为了保持数据的一致性，<strong>同别的表建立联系</strong>。</li></ul><hr><ul><li><blockquote><p>索引：就是数据库的数据结构。数据库中数据排列的方式，便于我们查询数据。最常见的B+树、红黑树等。</p></blockquote></li></ul><hr><h2 id="1-什么是数据库？（存放数据的仓库）"><a href="#1-什么是数据库？（存放数据的仓库）" class="headerlink" title="1.什么是数据库？（存放数据的仓库）"></a>1.什么是数据库？（存放数据的仓库）</h2><ul><li><blockquote><p>数据库是存储数据的仓库，本质上是一个文件系统。数据按照一定的格式存储在数据库内。</p></blockquote></li><li>用户可以对数据库进行<strong>增、删、修、查</strong>等操作。（增加、删除、修改、查找）</li><li>数据的基本形式是表。</li></ul><hr><h2 id="2-什么是数据库操作系统（管理数据库的软件）"><a href="#2-什么是数据库操作系统（管理数据库的软件）" class="headerlink" title="2.什么是数据库操作系统（管理数据库的软件）"></a>2.什么是数据库操作系统（管理数据库的软件）</h2><ul><li><blockquote><p>数据库操作系统本质上是一个大型的软件，帮助我们管理数据库。<strong>对数据库的建立、修改、维护做统一管理。</strong></p></blockquote></li><li>我们通过数据库管理系统从而访问数据库中表中的数据。</li></ul><hr><h2 id="3-数据库存储引擎（管理数据库的软件）"><a href="#3-数据库存储引擎（管理数据库的软件）" class="headerlink" title="3.数据库存储引擎（管理数据库的软件）"></a>3.数据库存储引擎（管理数据库的软件）</h2><ul><li><blockquote><p>是数据库的<strong>底层软件框架</strong>，<strong>不同的数据库存储引擎提供不同的存储机制和索引技巧</strong>。改变数据库存储引擎就是更换了数据库的底层框架。</p></blockquote></li><li>MySQL的存储引擎有<strong>innodb</strong>和<strong>Mylsam</strong>。innodb提供了事务支持，是Mysql的显著特点。<strong>同时支持表锁和行锁。Mylsam只支持表锁。</strong><br><img src="/pictures/clipboard99.png" alt="img1"></li></ul><hr><h2 id="4-什么是关系型数据库和非关系数据库"><a href="#4-什么是关系型数据库和非关系数据库" class="headerlink" title="4.什么是关系型数据库和非关系数据库"></a>4.什么是关系型数据库和非关系数据库</h2><p><img src="/pictures/clipboard94.png" alt="img1"></p><ul><li><blockquote><p>关系型数据库：主要有：Mysql / Oracle / Sql Server / Sqlite</p></blockquote></li><li><p>采用<strong>关系模型</strong>来构建数据的数据库。</p></li><li><p><strong>最经典的数据结构是表</strong>，由二维表及其之间的联系组成一个数据组织。最大的特点是支持事务。</p></li><li><p><strong>优点</strong>：易于维护，使用方便，支持事务。</p></li><li><p><strong>缺点</strong>：海量数据查询效率低下、高并发读写时，硬盘的I/O是很大问题。（持久性到硬盘）</p></li><li><p>总结：易于使用，方便维护，<strong>支持事务</strong>。 / 并发读写效率低下</p></li></ul><hr><p><img src="/pictures/clipboard95.png" alt="img1"></p><ul><li><blockquote><p>非关系型数据库：主要有：Redis / Hbase /MongoDB </p></blockquote></li><li>采用<strong>非关系模型</strong>来构建数据的数据库。</li><li>一般用的较多的是键值对的形式来构建。一般不遵守事务ACID原则，结构不固定。</li><li><strong>优点</strong>：格式灵活，<strong>查询速度快</strong>、成本低（无需直接写入硬盘，先从缓冲区寻找）</li><li><strong>缺点</strong>：无事务处理，数据结构比较复杂</li><li>总结：不支持事务，数据结构复杂。但是查询迅速。</li></ul><hr><h2 id="5-数据库中视图和表的区别"><a href="#5-数据库中视图和表的区别" class="headerlink" title="5.数据库中视图和表的区别"></a>5.数据库中视图和表的区别</h2><ul><li><blockquote><p>表是实际存在的数据，而视图是建立在表之上的，它依附于表，是<strong>展示表中数据的窗口</strong>。</p></blockquote></li><li><p>试图可以对应一个表，也可以对应多个表。总体上是表的一个子查询，性能比直接查询高很多（存在内部优化）。但是不能嵌套查询，会大大增加开销。</p></li><li><blockquote><p>区别：视图是编辑好的Sql语句，而表不是。</p></blockquote></li><li><p>表是内模式，视图是外模式</p></li><li><p>视图没有物理记录</p></li></ul><hr><h2 id="6-数据库中的三范式（表中数据的设计规范）"><a href="#6-数据库中的三范式（表中数据的设计规范）" class="headerlink" title="6.数据库中的三范式（表中数据的设计规范）"></a>6.数据库中的三范式（表中数据的设计规范）</h2><ul><li><blockquote><p>表中的数据<strong>遵守的设计标准</strong>，我们称为范式。只要有1NF、2NF、3NF、4NF、5NF。（关系模型）</p></blockquote></li><li><p>同时设计标准满足<strong>向下兼容</strong>，高一级的范式必定遵守低一级的范式标准。</p></li><li><p>“关系模式”和“关系”辅助理解：关系模型是表的数据结构，而关系是具体的一张表。关系需要满足关系模型的设计要求。</p></li></ul><hr><ul><li><blockquote><p>第一范式：表中的字段不可再分。</p></blockquote></li><li><blockquote><p>第二范式：满足第一范式，同时非主键字段必须完全依赖于主键。</p></blockquote></li><li><blockquote><p>第三范式：满足第二范式，同时非主键字段之间不能存在传递依赖。</p></blockquote></li></ul><p><font size=6> 具体解释</font></p><ol><li>第一范式<br><img src="/pictures/clipboard96.png" alt="img1"><ul><li>字段需要不可再分</li><li>缺点：满足第一范式的表数据还是<strong>存在很多冗余</strong>，会导致很多插入、删除、修改异常。</li></ul></li></ol><hr><ol><li>第二范式</li></ol><ul><li><p>名词解释：</p></li><li><p><strong>函数依赖</strong>：类似于y = f(x)，在X确定的情况下，只会对应计算出唯一的Y值。</p><ul><li><strong>完全依赖</strong></li><li>ID -&gt; 姓名 / 唯一</li><li>ID -&gt; 学号 / 唯一</li><li>姓名 -&gt; ID / 不唯一，存在重名等情况</li><li>我们称：姓名和学号<strong>完全依赖</strong>于ID</li><li><strong>部份依赖</strong></li><li>（ID + 性别） -&gt; 姓名 / 唯一</li><li>此时出现了冗余，一个ID就可以推出唯一的姓名，所以我们称姓名<strong>部分依赖</strong>于（ID+性别）</li></ul></li><li><p><strong>码</strong>（主属性）：就是主键，可以包含一个或多个字段。 </p></li><li><p><strong>主属性</strong>：主键中的所有字段。 </p></li><li><p><strong>非主属性</strong>：除了主键中的字段外，其他的字段就是非主属性。</p></li><li><blockquote><p>举例说明<br><img src="/pictures/clipboard97.png" alt="img"></p></blockquote></li><li><p>1.找到主键</p></li><li><p>2.确定主属性 / 非主属性</p></li><li><p>3.检验<strong>是否存在部分依赖情况</strong></p></li></ul><hr><ul><li><p>1.找主键（学号、课名）</p></li><li><p>2.主属性——学号、课名</p></li><li><p>3.非主属性——姓名、系名、系主任、分数</p></li><li><p>4.进行检验</p><ul><li><p>学号、课名 ——&gt;姓名</p></li><li><p>学号        ——&gt;姓名        <strong>部份依赖</strong></p></li><li><p>学号、课名——&gt;系主任</p></li><li><p>学号        ——&gt;系主任     <strong>部份依赖</strong></p></li></ul></li><li><blockquote><p>总结：综上不满足第二范式，如何解决我们可以进行模式分解，将大表拆成多个小表。</p></blockquote></li><li><p>缺点：满足第二范式虽然消除了很多冗余，但是还是存在一些问题。比如我们想插入一个新的学院，但是该学院还没有学生，这样主键是空的，所以不能插入元素。</p></li></ul><hr><ol><li>第三范式：满足第二范式的基础上，同时非主键字段间不能存在传递依赖。只存在主键和非主键间的完全依赖。</li></ol><ul><li><p>主码为（学号，课名），主属性为学号和课名  </p><ul><li>非主属性只有一个，为分数</li><li>学号，课名 ——&gt; 分数————满足</li></ul></li><li><p>主码为学号，主属性为学号，非主属性为姓名、系名和系主任</p><ul><li>学号 → 系名，</li><li>同时 系名 → 系主任——不满足</li></ul></li></ul><hr><ul><li><blockquote><p>第一范式：表中的字段不可再分。</p></blockquote></li><li><blockquote><p>第二范式：满足第一范式，同时非主键字段必须完全依赖于主键。</p></blockquote></li><li><blockquote><p>第三范式：满足第二范式，同时非主键字段之间不能存在传递依赖。</p></blockquote></li></ul><hr><h2 id="7-数据库中的All关键字"><a href="#7-数据库中的All关键字" class="headerlink" title="7.数据库中的All关键字"></a>7.数据库中的All关键字</h2><ul><li>特殊关键字<ul><li>主键：primary key：表中的唯一索引属性</li><li>外键：foreign key references：其他表的主键，用于表之间的关联</li><li>不为空：no null<br><img src="/pictures/clipboard98.png" alt="img"></li></ul></li></ul><hr><ul><li><blockquote><p>增、删、修关键字</p></blockquote></li><li><p><strong>create</strong> table ——创建一张表</p></li><li><p><strong>drop</strong> table——删除一张表</p></li><li><p><strong>insert</strong> into …  values——插入一条信息</p></li><li><p><strong>update</strong>  …information…where    ——更新信息</p></li><li><p><strong>delete</strong>  information  ——删除信息</p></li><li><p><strong>alter</strong> table  … add——向表中添加某个字段</p></li><li><p>alter table  … drop——将表中的某个字段删除</p></li></ul><hr><ul><li><blockquote><p>查询关键字</p></blockquote></li><li><p>select B/ 表示要查找出的表所含有的属性</p><ul><li>distinct / 在select后加，表示<strong>结果去重</strong></li><li>all / 在select后加，表示<strong>结果不去重</strong></li></ul></li><li><p>from 表A / 表示要操作的表</p></li><li><p>where / 判断条件，根据该判断条件选择信息</p><ul><li>and / where中的判断条件，连起来</li><li>or / where中的判断条件，多选一</li><li>not / where中的判断条件，条件取反</li></ul></li></ul><hr><ul><li><blockquote><p>多关系查找关键字</p></blockquote></li><li>A，B        ——    在from的后面，表示连接多张表</li><li><strong>natural join</strong>    ——    将两张表进行自然连接运算<ul><li>——分为全连接(并)、左连接、右连接、内连接(交)（交并补）</li><li>LEFT JOIN（左连接）</li><li>RIGHT JOIN（右连接）</li><li>交并补——对于数据库来说</li></ul></li></ul><hr><ul><li><blockquote><p>附加运算符</p></blockquote></li><li>as：将as前的关系起别名，这样表中可以用别名来指代这个表。——类似于浅拷贝</li><li>*：表中的所有数据</li><li>order by：对于查取的信息进行升序或降序排序<ul><li>desc：默认升序</li><li>asc：降序</li></ul></li><li>between：查询两个数值中间的数值</li><li>not between：between间数据的取反</li></ul><hr><ul><li>union / union all——对两个SQL语句做<strong>并操作</strong>，自动去重，加all不去重</li><li>intersect / intersect all——对两个SQL语句做<strong>交操作</strong>，自动去重，加all不去重</li><li>except / except all——对两个SQL语句做<strong>差操作</strong>，自动去重，加all不去重</li></ul><hr><ul><li>is null ：在where中使用，表示这个值是空值</li><li>is not null ：在where中使用，表示这个值是不是空值</li></ul><hr><ul><li><blockquote><p>模糊查询 / where name like “%庄_”;</p></blockquote></li><li>Like：名称前面加。</li><li>%：任意多个字符。</li><li>_：下划线表示任意一个字符。</li></ul><hr><ul><li><blockquote><p>聚集函数</p></blockquote></li><li>avg</li><li>min</li><li>max</li><li>sum</li><li>count计数</li><li>distinct对于数据进行去重</li></ul><hr><h2 id="8-数据库中exists-和-in-的区别"><a href="#8-数据库中exists-和-in-的区别" class="headerlink" title="8.数据库中exists  和   in 的区别"></a>8.数据库中exists  和   in 的区别</h2><ul><li><blockquote><p>in的判断类似于or，是将满足的子条件记录全部查询</p></blockquote></li><li><blockquote><p>exists  类似于一个子查询，然后进行bool判断是否查找到结果，有就返回true，没有就返回false</p></blockquote></li></ul><hr><h2 id="9-数据库中的底层数据结构"><a href="#9-数据库中的底层数据结构" class="headerlink" title="9.数据库中的底层数据结构"></a>9.数据库中的底层数据结构</h2><ul><li><strong>索引</strong>就是数据库中数据的排序结构。</li><li>一般的数据结构有平衡二叉树、红黑树、B树、B+树等。</li><li>常见的查找算法有<strong>顺序查找</strong>，<strong>二分查找法</strong>，<strong>哈希表散列法</strong>等。</li></ul><hr><ul><li><blockquote><p>MySql是持久化到硬盘的数据库，所以需要将数据读取到内存中。</p></blockquote></li><li><p>磁盘读取数据到内存时，是以磁盘块(Block)为基本单位的，位于同一区域的数据会被全部读取出来。</p></li><li><p>所以根据磁盘读取的规则，读取次数越少，时间越快，消耗越少。所以当树的层级越少，枝节点保存的数据越多，这样查询的效率也就越高。</p></li><li><p>B树，单节点多Value值和索引指针，这样层数降低，单个节点保存的数据变多，读写次数更少。</p></li><li><p>B+树，只在叶子节点存数据，这样树的高度更低，同时单个枝节点存放的信息也更多，所以读取磁盘的时间更少。</p></li><li><p>B<em>树则是提高了B+树的利用效率，当节点元素超过数量上限时需要分裂，而B</em>树会优先去查询兄弟节点是否缺，同时也只会将1/3的元素放入下面的节点。</p></li></ul><hr><h2 id="10-Redis和MySQL的区别？"><a href="#10-Redis和MySQL的区别？" class="headerlink" title="10. Redis和MySQL的区别？"></a>10. Redis和MySQL的区别？</h2><ul><li><p>a).mysql是关系型数据库，而redis是非关系型数据库。Mysql支持事务。而redis不支持事务。</p></li><li><p>b).Mysql是持久化数据库，每次访问都要在硬盘上进行I/O操作。频繁访问数据库会在反复连接数据库上花费大量时间。Redis则会在<strong>缓存区</strong>存储大量频繁访问的数据，当浏览器访问数据的时候，先访问缓存，如果访问不到再进入数据库.</p></li><li><p>总结：</p></li><li><p>Mysql持久性质，存到硬盘，读取慢，高频繁的IO导致效率很低。支持事务，结构稳定。</p></li><li><p>Redis缓存区存储大量频繁访问的数据，访问速度快，先访问缓存在去访问数据库。数据结构复杂，不支持事务。</p></li></ul><hr><h2 id="11-数据库的索引和优化"><a href="#11-数据库的索引和优化" class="headerlink" title="11.数据库的索引和优化"></a>11.数据库的索引和优化</h2><ul><li><p>索引定义：数据库中数据的排序方式。比如：平衡二叉树等等。</p></li><li><p>索引的优点：1.加快数据检索的时间</p></li><li><p>索引的缺点：1.索引的维护都需要时间，对数据的增删改查 2.索引需要占用额外的内存空间</p></li></ul><hr><h2 id="12-数据库的锁"><a href="#12-数据库的锁" class="headerlink" title="12.数据库的锁"></a>12.数据库的锁</h2><ul><li><blockquote><p>都是为了解决数据库并发控制的问题。确保多个事务存取数据的时候，不破坏事务的一致性和隔离性。</p></blockquote></li></ul><ol><li><strong>读锁</strong>/共享锁</li><li><strong>写锁</strong>/排他锁</li><li><strong>读写锁</strong></li><li>意向锁——获得读写锁之前，需要</li><li><strong>表锁</strong></li><li><strong>行锁</strong></li></ol><hr><h2 id="13-乐观锁和悲观锁"><a href="#13-乐观锁和悲观锁" class="headerlink" title="13.乐观锁和悲观锁"></a>13.乐观锁和悲观锁</h2><ul><li><p>数据库的并发控制：确保多个事务存取数据的时候，不破坏事务的一致性和隔离性。</p></li><li><p>实现并发控制的主要手段有：乐观控制、悲观控制。——简单来说就是<strong>悲观锁、乐观锁</strong>。</p></li><li><blockquote><p>定义：</p></blockquote></li><li><p>悲观锁：在操作数据之前，对数据进行加锁。利用数据库锁的机制，保证事务间不会发生冲突。</p><ul><li>包含读锁和写锁：对用户权限的控制 </li></ul></li><li><p>乐观锁：默认数据之间不会发生冲突，只在数据更新的时候对数据进行检测，如果发现了冲突，数据更新失败。没发现冲突，数据更新成功。</p><ul><li>一般不使用数据库锁的机制：利用<strong>记录数据的版本来实现</strong>。 </li></ul></li></ul><hr><p><img src="/pictures/clipboard100.png" alt="img"></p><ul><li>悲观锁：在Mysql中的事务处理中，会使用for  update对数据进行锁定。然后对数据进行修改，保证数据的独享。</li></ul><p><img src="/pictures/clipboard101.png" alt="img"></p><ul><li>乐观锁：一般两个步骤，<strong>冲突检测，数据更新</strong>。典型的就是<strong>CAS算法</strong>：compare  and swap。是一项乐观锁的技术。</li><li>检测数据版本，如果<strong>当前数据版本</strong>和之前不一样，那么就是数据过期了，需要予以更新。<ul><li>简单来说就是当多个线程同时更新一个数据时，只有一个线程能够更新成功。其他的线程失败，失败的线程不会被挂起，而是被告知失败，可以再次尝试。</li></ul></li></ul><hr><h2 id="14-数据的事务"><a href="#14-数据的事务" class="headerlink" title="14.数据的事务"></a>14.数据的事务</h2><ul><li><blockquote><p>是对数据库内容的一个操作序列，是一个不可分割的单位。</p></blockquote></li><li>事务结束的两种结果：（成功的事务提交、失败的事务回滚_撤销操作）<ul><li>操作全部完成事务提交。</li><li>其中一个步骤失败，发生<strong>回滚操作</strong>，撤消该事务已执行的操作。</li></ul></li></ul><ul><li><blockquote><p>事务的四大性质ACID / <strong>原子、一致、隔离、持久性</strong>。（Atomicity）/ （Consistency） / （Isolation）/（Durability）</p></blockquote></li></ul><ol><li>A_<strong>原子性</strong>：事务是不可分割的单位，只有0和1，要么成功，要么失败。<ul><li>通过<strong>二进制日志文件</strong>来保证。将所有对数据的更新操作都写入日志，如果一个事务中的一部分操作已经成功，但以后的操作，由于断电/系统崩溃/其它的软硬件错误而无法继续，则通过<strong>回溯日志</strong>，将已经执行成功的<strong>操作撤销</strong>，从而达到“全部操作失败”的目的。 </li></ul></li><li>C_<strong>一致性</strong>：事务前后数据保持一致性。需要<strong>符合逻辑运算</strong>。<ul><li>通过原子性、隔离性、持久性来实现一致性。 </li></ul></li><li>I_<strong>隔离性</strong>：并发的访问数据库时，事务间不能相互影响。<ul><li>通过各种锁来实现：乐观锁、悲观锁等。从而解决脏读、不可重复读、幻读问题。 </li></ul></li><li>D_<strong>持久性</strong>：事务提交后，对数据内容的更改是永久性的。持久性到硬盘，断开也不影响。<ul><li>通过写入到硬盘来实现，而彼时redis的缓存区。 </li></ul></li></ol><hr><ul><li><blockquote><p>三种错误读取——方式</p></blockquote></li></ul><ol><li><strong>脏读</strong>——事务A，读取到了B事务未提交的数据，事务B回滚就产生了脏读。</li><li><strong>不可重复读</strong>——重复读取数据时，前后读取的数据值不同。</li><li><strong>幻读</strong>——读取到了别的事务刚刚插入的行数据，导致前后读取不同。</li></ol><hr><ul><li><a href="https://www.jianshu.com/p/1ee2f3ca443c" target="_blank" rel="noopener">https://www.jianshu.com/p/1ee2f3ca443c</a></li><li><blockquote><p>数据库隔离等级<br><img src="/pictures/clipboard102.png" alt="img"></p></blockquote></li></ul><ol><li><strong>读未提交</strong>：读取到了别的事务未提交的数据。（读取到了其他事务未提交的数据）</li></ol><ul><li>一致性最差的，查询不加锁，产生脏读、不可重复读、幻读。</li><li>举例：<ul><li>老板事务：发3000，但是发了30000，发现了产生回滚。</li><li>自己事务：发现余额30000，但是过了会，变成了3000，留下了贫穷的眼泪。<br><img src="/pictures/clipboard103.png" alt="img"></li></ul></li></ul><hr><ol><li><strong>读提交</strong>：在同一个事务下，读取到的数据是不一样的。（前后两次读到的数据不同，数据被其他事务改写了）</li></ol><ul><li>可以避免脏读。但是还是会产生不可重复读、幻读。</li><li>举例:<ul><li>自己事务：查询余额发现5000，准备消费2000。付款时查询发现还剩1000。</li><li>女朋友事务：败家老婆在这期间花了4000。<br><img src="/pictures/clipboard104.png" alt="img"></li></ul></li></ul><hr><ol><li><strong>可重复读</strong>：在同一个事务下，不允许别的事务对自己的数据进行修改。</li></ol><ul><li>MySql的默认隔离等级，但是还会产生幻读。</li><li>举例:<ul><li>自己事务：事务1.消费了1000，事务2.之后消费了10000。 </li><li>女朋友事务：事务1.后开启事务：发现消费1000，之后再次查询发现消费10000，读取到了新插入的新消费信息。<br><img src="/pictures/clipboard105.png" alt="img"></li></ul></li></ul><hr><ol><li><strong>序列化</strong>：一致性最好的，但是效率极其差，<strong>同时开销也很大，一般不使用</strong>。</li></ol><ul><li>别人正在操作时，锁住整个表</li></ul><hr><ul><li>总结：<ul><li>读未提交：读到别的事物未提交的数据</li><li>读提交：在一个事务期间，读到的数据不一样。</li><li>可重复读：在一个事务期间，不允许对当前行数据进行修改。（行锁）</li><li>串行化：在一个事务期间，不允许对当整个表进行修改。（表锁）</li></ul></li></ul><hr><h2 id="15-MySql的binlog三种模式？（主站写、从站读）"><a href="#15-MySql的binlog三种模式？（主站写、从站读）" class="headerlink" title="15.MySql的binlog三种模式？（主站写、从站读）"></a>15.MySql的binlog三种模式？（主站写、从站读）</h2><ul><li><blockquote><p>MySql的<strong>二进制日志文件</strong>binlog。</p></blockquote></li></ul><ol><li>以二进制形式记录更改数据库的SQL语句（insert,update,delete,create,drop,alter等）</li><li>用于Mysql主从复制</li><li>增量数据库的备份及恢复</li></ol><hr><ul><li><blockquote><p>一共有三种记录模式。（ROW：记录要修改的Value，Statement记录命令）</p></blockquote></li></ul><ol><li>Row模式：日志会记录<strong>每行数据被修改成的形式</strong>，然后在从端再对相同的数据进行修改，只记录要修改的数据，只有value，不会有sql多表关联的情况。<ul><li>优点：记录数据详细（每行），主从一致</li><li>缺点：占用大量的磁盘空间，降低了磁盘的性能</li></ul></li><li>Statement模式：每一条会修改数据的SQL命令都会记录到master的binlog中，slave在复制的时候sql进程会解析成和原来master端相同的sql再执行。<ul><li>优点：记录的简单，内容少</li><li>缺点：可能导致主从不一致</li></ul></li><li>Mixed模式：选择Row模式和Statement模式，二选一<ul><li>普通操作使用Statement记录，当无法使用Statement的时候使用row。</li></ul></li></ol><hr><h2 id="16-Mvcc和-四种读的实现方式？"><a href="#16-Mvcc和-四种读的实现方式？" class="headerlink" title="16.Mvcc和 四种读的实现方式？"></a>16.Mvcc和 四种读的实现方式？</h2><ul><li><p><a href="https://baijiahao.baidu.com/s?id=1669272579360136533&amp;wfr=spider&amp;for=pc" target="_blank" rel="noopener">https://baijiahao.baidu.com/s?id=1669272579360136533&amp;wfr=spider&amp;for=pc</a></p></li><li><blockquote><p>MVCC(Mutil-Version Concurrency Control)，就是<strong>多版本并发控制</strong>。在数据库中，用来实现对<strong>数据库的并发访问</strong>,从而实现可重读的隔离等级。</p></blockquote></li></ul><hr><ul><li>一般可重读的隔离等级：用<strong>行锁</strong>来实现，</li><li>事务隔离的实现方案有两种，<strong>LBCC</strong>和<strong>MVCC</strong><ul><li>LBCC：Based Concurrency Control，基于锁的控制</li><li>MVCC：俗称<strong>快照读</strong>，为<strong>当前数据创建一个快照</strong>，后面就可以直接读取这个快照，读取的是数据的历史版本，而不是最新版本。没用到锁。<ul><li>快照读，指的是在RR隔离级别下，在<strong>不加锁</strong>的情况下MySQL会根据回滚指针选择从undo log记录中获取快照数据，而不总是获取最新的数据。</li><li>undo log：维护着历史数据</li><li>DB_TRX_ID：最后一个事务的事务ID / DB_ROLL_PTR：回滚指针</li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> learn </category>
          
          <category> 数据库 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>项目 / 水下立体视觉</title>
      <link href="/2020/07/24/%E9%A1%B9%E7%9B%AE-%E6%B0%B4%E4%B8%8B%E7%AB%8B%E4%BD%93%E8%A7%86%E8%A7%89-1/"/>
      <url>/2020/07/24/%E9%A1%B9%E7%9B%AE-%E6%B0%B4%E4%B8%8B%E7%AB%8B%E4%BD%93%E8%A7%86%E8%A7%89-1/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
          <category> 水下立体视觉 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>项目 / 树莓派</title>
      <link href="/2020/07/24/%E9%A1%B9%E7%9B%AE-%E6%A0%91%E8%8E%93%E6%B4%BE/"/>
      <url>/2020/07/24/%E9%A1%B9%E7%9B%AE-%E6%A0%91%E8%8E%93%E6%B4%BE/</url>
      
        <content type="html"><![CDATA[<h2 id="液面检测-位姿判断（浦东新区中天科技园-生物公司）"><a href="#液面检测-位姿判断（浦东新区中天科技园-生物公司）" class="headerlink" title="液面检测 / 位姿判断（浦东新区中天科技园_生物公司）"></a>液面检测 / 位姿判断（浦东新区中天科技园_生物公司）</h2><h4 id="1-项目需求"><a href="#1-项目需求" class="headerlink" title="1.项目需求"></a>1.项目需求</h4><ol><li>试管名称：一次性使用采样器。（大规模送检测试器皿）</li><li>作用：类似于验血时的一次性保存容器，通过棉签擦拭部位然后采集液体。<br>（液体类似酒精混合物）</li><li>项目需求：通过相机采集规定ROI区域内：试管内棉签的位姿状态和样本液体的高度数据。<ul><li>高度误差： +-1mm————防止下针采集时刺穿了采样器。</li><li>角度误差： +-10°————主要了为了判断出棉签是靠左还是靠右，这样可以云台控住的采集器可以下针吸取液体。<br><img src="/pictures/clipboard39.png" alt="img1"></li></ul></li></ol><hr><h4 id="2-Modbus通讯"><a href="#2-Modbus通讯" class="headerlink" title="2.Modbus通讯"></a>2.Modbus通讯</h4><ul><li><blockquote><p>Modbus主要有<strong>线圈寄存器</strong>和<strong>保持寄存器</strong>。前者支持0和1的输入输出，常用于控制开关,保持寄存器常用于读写数据。</p></blockquote></li><li><blockquote><p>0x10: 写多个保持寄存器/16示例：<br><img src="/pictures/clipboard40.png" alt="功能码16"></p></blockquote></li><li><blockquote><p>树莓派网络设置：</p></blockquote></li></ul><ol><li>IP: 192.168.178.100</li><li>Mask: 255.255.255.0</li><li>Timeout: 1000ms</li><li>Port: 502</li><li>ModbusTCPSlave</li><li>功能码0x17 / 23读写多个保持寄存器</li></ol><hr><ul><li><blockquote><p>0x17: 读写多个保持寄存器<br><img src="/pictures/clipboard41.png" alt="功能码23"></p></blockquote></li></ul><ol><li><p>主站询问报文：一般由三部分组成，</p><ol><li>报头：7字节的报头，</li><li>数据大小和起始位置：1字节表示功能码，4字节高低位的数量和起始位，</li><li>具体的交互数据：1字节统计总数，输入数据字节1，字节2，字节3 ，我们共10字节</li></ol></li><li><p>从站应答报文：对应主站报文</p></li><li><p>一个数据2个字节，高位和地位0-65535</p></li><li><p>在对应的交互数据中写入数据，返回报文</p><table><thead><tr><th>主站写</th><th>主站写</th><th>从站写</th><th>从站写</th><th>从站写</th></tr></thead><tbody><tr><td>数据1</td><td>数据2</td><td>数据3</td><td>数据4</td><td>数据5</td></tr><tr><td>1.检索命令</td><td>2.试管类型编号</td><td>3.棉签角度</td><td>4.液面高度</td><td>5模板高度</td></tr></tbody></table></li></ol><ul><li>错误码返回说明：<ul><li>1.当出入试管类型不存在，返回65535</li><li>2.检测ROI区域存在问题，前景后景提取失败    65534</li><li>3.液面检测失败—（液面无梯度信息，液面高度过低）65533      </li></ul></li></ul><hr><h4 id="3-工作流程"><a href="#3-工作流程" class="headerlink" title="3.工作流程"></a>3.工作流程</h4><ul><li><blockquote><p>工作流程：</p></blockquote></li></ul><ol><li>预处理：试管模板的制作，根据不同试管的尺寸和大小，制作不同的试管下部模板，然后生成下模板二值图和对应的试管类型编号xml文件。<ul><li>包含了试管宽度、编号、模板类型信息——满足一套系统，不同尺寸试管的检测要求，只需Modbus通讯时，报文输入对应的使馆编号，按 照对应的试管编号进行类型处理。</li></ul></li><li>建立Modbus TCP通讯连接，树莓派作为服务器（从站），西门子PLC为客户端（主站）</li><li>PLC发送对应的Modbus—功能码23（0x17）读写多个保存寄存器，树莓派进行检测，返回对应数据。</li><li>PLC根据返回数据，进行判断旋转云台，后再次采集数据，旋转试管至满足要求。<br><img src="/pictures/clipboard42.png" alt="img"><br><img src="/pictures/clipboard43.png" alt="img"></li></ol><hr><h4 id="4-工作流程（精简）"><a href="#4-工作流程（精简）" class="headerlink" title="4.工作流程（精简）"></a>4.工作流程（精简）</h4><ol><li>试管进行预处理，对应的生成试管类型编号文件和模板文件</li><li>PLC和树莓派进行Modbus TCP通讯，建立主站从站，收发数据。</li><li>PLC根据树莓派返回的数据进行 云台的旋转，调整试管位姿至满足状态。</li></ol><hr><h4 id="5-算法"><a href="#5-算法" class="headerlink" title="5.算法"></a>5.算法</h4><ul><li>主要分为<strong>棉签位姿判断</strong>和<strong>液面高度判断</strong></li></ul><ol><li>ROI区域前后景分离（OTSU）</li><li>液面高度—ROI区域进行倒置，下部区域模板匹配，上部区域Scharr梯度提取液面梯度。<ul><li>倒置是为了提取液面低处，同时包含误差检验算法—像素和要求。</li></ul></li><li>ROI区域图像的一阶矩求重心，而阶矩求倾斜角。<ul><li>误差检验算法—像素区域和，同时根据液面高度选择极限角度的不同位置</li></ul></li></ol><p><img src="/pictures/clipboard44.png" alt="img"></p><hr><h4 id="6-问题解决"><a href="#6-问题解决" class="headerlink" title="6.问题解决"></a>6.问题解决</h4><ul><li><blockquote><p>首先使用的边缘检测，误检率比较高?</p></blockquote></li><li><p>后使用背景分离算法。</p></li><li><blockquote><p>前景背景分离时受到外部光线影响较大，如何减小影响？</p></blockquote></li><li><p>解决方法：客户是在室内使用的，所以对外部光线对其影响不大，主要是解决室内光的问题。对相机采用了自适应曝光后，算法稳定性可靠的提升了。</p></li><li><blockquote><p>对于角度的判定存在一定的误差，由于不同的液面，图像的矩的角度极限位置不同</p></blockquote></li><li><p>解决方法：根据实际测量实验，得出了不同液面高度的<strong>修正系数表</strong>，根据液面高度来修正角度极限位置的交点位置。</p></li></ul><hr><h4 id="7-硬件选型"><a href="#7-硬件选型" class="headerlink" title="7.硬件选型"></a>7.硬件选型</h4><ul><li><blockquote><p>相机布局示意图<br><img src="/pictures/clipboard45.png" alt="img"></p></blockquote></li><li><p>视野范围</p></li><li><p>X方向：200*3.04/3.6=236.8</p></li><li><p>Y方向：200*3.04/2.7=177.6</p></li><li><blockquote><p>相机参数<br><img src="/pictures/clipboard46.png" alt="img"><br><img src="/pictures/clipboard47.png" alt="img"></p></blockquote></li></ul><hr><h4 id="8-算法介绍"><a href="#8-算法介绍" class="headerlink" title="8.算法介绍"></a>8.算法介绍</h4><ul><li><blockquote><p><font size=6>1.OTSU大津法——<strong>最大类间方差法</strong> </font></p></blockquote></li></ul><ol><li>分割后图像的前景与后景类间方差最大。<ul><li>被认为是最佳的阈值分割算法，计算简单不受图像亮度和对比度的影响。</li></ul></li><li>前景和背景的类间方差越大，说明两部分的差别越大。<ul><li>当前景和背景错分时，都会导致类间方差变小。所以类间方差最大分割，意味着<strong>错分概率</strong>是最小的。</li></ul></li><li><strong>找到最合适的灰度级K</strong>，使得<strong>类间方差</strong>最大</li></ol><ul><li><blockquote><p><img src="/pictures/clipboard48.png" alt="img"><br><img src="/pictures/clipboard49.png" alt="img"><br><img src="/pictures/clipboard50.png" alt="img"></p></blockquote></li></ul><hr><ul><li><blockquote><p><font size=6>2.图像的矩求 重心 / 倾斜角 </font></p></blockquote></li></ul><ol><li>0阶矩——白色区域面积</li><li>1阶矩——图像重心</li><li>2阶矩——图像倾斜角度</li></ol><hr><ul><li><p>定义：图像识别的核心问题就是：图像的特征提取，利用一些简单的数据来描述整个图像。这些数据越简单越有代表性越好。图像识别发展几十年，不断有新的特征提出，而<strong>图像不变矩</strong>就是其中一个。</p></li><li><p>矩是概率与统计中的一个概念，是随机变量的一种数字特征。</p></li><li><blockquote><p>设x为随机变量，c为常数，k为正整数。则量E[(x-c)k]为x关于c点的k阶矩。</p></blockquote></li><li><p>1.如果E[(x-c)k]存在</p><ul><li>当c=0，A = E(xk)，称为x的k阶<strong>原点矩</strong></li><li>当c=E(x)，A = E( [x-E(x)]k )，称为x的k阶<strong>中心距</strong></li></ul></li><li><p>2.如果E[(x-c1)p * (y-c2)q ]存在，称其为X，Y关于c点<strong>p + q阶矩</strong></p></li><li><p>不变矩是一处高度浓缩的图像特征，具有<strong>平移、灰度、尺度、旋转不变性。</strong></p></li></ul><ol><li>1961M.K.Hu提出了Hu不变矩。</li><li>1979M.R.Teague根据正交多项式，提出了Zernike矩</li></ol><ul><li><blockquote><p><img src="/pictures/clipboard51.png" alt="img"><br><img src="/pictures/clipboard52.png" alt="img"></p></blockquote></li></ul><h4 id="9-实际工况图"><a href="#9-实际工况图" class="headerlink" title="9.实际工况图"></a>9.实际工况图</h4><p><img src="/pictures/555.jpg" alt="img"><br><img src="/pictures/557.jpg" alt="img"><br><img src="/pictures/556.jpg" alt="img"></p><hr><h2 id="PNP螺丝漏打识别-透视投影（博世BOSCH）"><a href="#PNP螺丝漏打识别-透视投影（博世BOSCH）" class="headerlink" title="PNP螺丝漏打识别 / 透视投影（博世BOSCH）"></a>PNP螺丝漏打识别 / 透视投影（博世BOSCH）</h2><h4 id="1-项目需求-1"><a href="#1-项目需求-1" class="headerlink" title="1.项目需求"></a>1.项目需求</h4><ul><li><blockquote><p>项目需求：机器视觉，<strong>动态检测</strong>工人的电动螺丝刀头的位置，从而判断是否正确安装螺丝。</p></blockquote><ul><li>电动螺丝刀给零件拧螺丝：一般都是有顺序的拧多个螺丝。但是在实际的操作过程中，经常发生<strong>漏拧错拧</strong>漏的现象。为了提高良品率，杜绝这种错拧漏拧的现象，我们需要设计一套监控系统。</li></ul></li></ul><h4 id="2-技术路线"><a href="#2-技术路线" class="headerlink" title="2.技术路线"></a>2.技术路线</h4><ul><li>工作流程：</li></ul><ol><li><strong>单目相机位姿跟踪</strong>的方法——跟踪螺丝刀头的位置和姿态。</li><li>首先通过工人示教出打螺丝各个位置，刀头的姿态。然后工人实际拧螺丝的时候触发相机工作和实际计算的螺丝刀头的位姿进行比较，如果超过阈值，触发报警，提醒工人。</li></ol><h4 id="3-算法原理—PNP透视投影"><a href="#3-算法原理—PNP透视投影" class="headerlink" title="3.算法原理—PNP透视投影"></a>3.算法原理—PNP透视投影</h4><ul><li><blockquote><p>PnP（Perspective-n-Point）是求解 3D 到 2D 点对运动的方法。它描述了当我们知道n 个 3D 空间点以及它们的投影位置时，如何估计相机所在位姿的问题。如图所示，如果知道大于3对点在世界坐标系中3D点坐标和其在图像坐标系中对应的2D点坐标时，就可以估计相机运动。3D-2D 方法不需要使用对极约束，又可以在很少的匹配点中获得较好的运动估计，是最重要的一种姿态估计方法。<br><img src="/pictures/clipboard53.png" alt="img"></p></blockquote></li></ul><h4 id="4-算法设计"><a href="#4-算法设计" class="headerlink" title="4.算法设计"></a>4.算法设计</h4><ol><li><p>相机进行标定，得到相机的内参系数K，自定义世界坐标系6个点。</p><ul><li><p>Point3f center1=Point3f(0 ,30 ,490);      </p></li><li><p>Point3f center2=Point3f(25.981, 15 ,490);</p></li><li><p>Point3f center3=Point3f(25.981, -15,490);     </p></li><li><p>Point3f center4=Point3f(0, -30 ,490);</p></li><li><p>Point3f center5=Point3f(-25.981, -15, 490);     </p></li><li><p>Point3f center6=Point3f(-25.981 ,15,490);</p></li><li><p>距离圆心30mm</p></li><li><p>内参矩阵(Mat_<double>(3,3)&lt;&lt;2062.281673430,0,1316.924373761,0,2061.800740149,996.245044127,0,0,1)</p></li><li><p>畸变系数(Mat_<double>(4,1)&lt;&lt;0.172651199,-0.322824460, -0.000679134, 0.000281738);</p></li></ul></li><li><p>处理相机采集到的图片，图像上的坐标（像素坐标）图像检测获得，进行相机位姿计算和倾斜角度换算。</p><ul><li><p>求取：R T，相机和标志物坐标系的距离</p></li><li><p>位姿Rodrigues(_PoseR,PoseR);</p><ul><li>倾斜角度double aa;</li><li>aa=PoseR.at<double>(2, 2);</li><li>dvalue=acos(aa)*180/3.1415926;</li></ul></li></ul></li></ol><h4 id="5-算法难点"><a href="#5-算法难点" class="headerlink" title="5.算法难点"></a>5.算法难点</h4><ol><li>预处理，提取出大致图像（红外相机 + 850 nm 红外光源）</li><li>在于正确识别出6个圆环中至少4个点。</li><li>同时能够区分出每个圆对应的编号</li></ol><ul><li><blockquote><p>设计标靶</p></blockquote></li><li><blockquote><p>标靶检测算法</p></blockquote><p><code>设计</code>：为了能够得到螺丝刀上大于三个特征点3D坐标和对应的2D坐标，需要设计标靶，并且需要保证标靶上的特征点顺序保持<strong>旋转不变性</strong>和部分<strong>遮挡不变性</strong>，本项目设计了如图所示的标靶，由<strong>4个实心圆和2个圆环</strong>组成，保证了使用过程中对应的点标号顺序不变。<strong>标靶由反光标志点组成</strong>，在<strong>红外光源的照射</strong>下，能够保证标靶点与周围环境有很高的对比度，方便提取各标靶点椭圆圆心的坐标。</p></li></ul><p> <img src="/pictures/clipboard54.png" alt="img"></p><p><code>方案</code>：由于螺丝刀顶部的电源线会对标靶点有一定的遮挡，本项目设计了如下的标靶编号算法，可以保证6个标靶点遮挡相邻的0-2个点时，仍能正确计算螺丝刀刀头的位姿。具体算法如下：</p><ul><li><blockquote><p>标靶编号算法流程：</p></blockquote></li><li>使用atan2函数计算每个点相对于质心点的方位角，然后再计算出各个点的夹角。(以下夹角和编号都是顺时针，夹角都取角和补角中的小值)</li></ul><ol><li><p>Case1:  6个标志点均未被遮挡（size=8）</p><ul><li>1）若夹角排列为120  120  60  60 ，则标号为 1356 </li><li>2）若夹角排列为120  60  60  120，则标号为 3561  </li><li>3）若夹角排列为60  60  120  120 ，则标号为 5613</li><li>4）若夹角排列为60  120  120  60，则标号为 6135</li><li>与1、3号夹角均为60度则是2号</li><li>遍历圆与2个圆环之间的夹角，如果均是60度，则是3号点，顺时针依次是45612  </li></ul></li><li><p>Case2:  1号标志点被遮挡（夹角排列为120    60    180或60 180    120或180    120    60）</p><ul><li>1）若夹角排列为120    60    180，则标号为 356 </li><li>2）若夹角排列为60    180    120，则标号为 563  </li><li>3）若夹角排列为180    120    60 ，则标号为 635</li><li>与3、5号夹角均为60度则是4号，另一个同心圆则是2</li><li>遍历圆与2个圆环之间的夹角，如果均是60度，则是3号点，顺时针依次是4562</li></ul></li><li><p>Case3:  5号标志点被遮挡（夹角排列为60    120    180或120    180    60或180 60    120）</p><ul><li>1）若夹角排列为60    120    180，则标号为 613 </li><li>2）若夹角排列为120    180    60，则标号为 136    </li><li>3）若夹角排列为180    60    120 ，则标号为 361</li><li>与1、3号夹角均为60度则是2号，另一个同心圆则是4</li><li>遍历圆与2个圆环之间的夹角，如果均是60度，则是3号点，顺时针依次是4612</li></ul></li><li><p>Case4:  3号标志点被遮挡（夹角排列为60    60    120或60  120 60或120 60 60）</p><ul><li>1）若夹角排列为60    60    120，则标号为 561 </li><li>2）若夹角排列为60    120    60，则标号为 615 </li><li>3）若夹角排列为120    60    60 ，则标号为 156</li><li>与1号夹角180，与5号夹角60则是4，另一个同心圆则是2</li><li>遍历圆与2个圆环之间的夹角，如果均是120度，则是6号点，顺时针依次是1245</li></ul></li><li><p>Case5:  6号标志点被遮挡（夹角排列为120    120    120）</p></li></ol><ul><li>此时夹角均为120，不能通过夹角来区分，稍复杂<ul><li>1）若该点与两个圆环均为60度，则该点为3号点；</li><li>2）顺时针方向，3号点前面是2号，后面是4号；</li><li>3）若该点与4号角点夹角为60，且与2号环形点为180度，则该点为5号点</li><li>遍历圆与2个圆环之间的夹角，如果均是60度，则是3号点，顺时针依次是4512</li></ul></li></ul><ol><li>Case6:环形标志点被遮挡</li></ol><ul><li>按照Case1情况对圆形标志点标号，然后判断圆环是2还是4，与1号、3号夹角均为69度则是2，另一个则是4，反之取反。<ul><li>1）若夹角排列为120  120  60  60 ，则标号为 1356 </li><li>2）若夹角排列为120  60  60  120，则标号为 3561 </li><li>3）若夹角排列为60  60  120  120 ，则标号为 5613</li><li>4）若夹角排列为60  120  120  60，则标号为 6135</li><li>与1、3号夹角均为60度则是2号</li></ul></li></ul><ol><li>Case7:相邻两个标志点被遮挡<ul><li>1）    挡住1和2，与挡住1相同，此时识别到的标志点个数为4；</li><li>2）    挡住3和2 or挡住3和4，与挡住3相同，此时识别到的标志点个数为4；</li><li>1、若夹角排列为60    60    120，则标号为 561 </li><li>2、若夹角排列为60    240    300，则标号为 615 </li><li>3、若夹角排列为240 60    300 ，则标号为 156</li><li>判断圆环是2还是4的方法：与1的夹角为30-90°为2，否则为4</li><li>3）    挡住4和5，与挡住5相同，此时识别到的标志点个数为4；</li><li>4）    挡住5和6，则此时是 圆、环、圆、环，且圆和环的个数均为2</li><li>5）    挡住6和1，则此时是 环、圆、环、圆，且圆和环的个数均为2</li></ul></li></ol><hr><h4 id="6-硬件选型"><a href="#6-硬件选型" class="headerlink" title="6.硬件选型"></a>6.硬件选型</h4><ul><li>1.树莓派3B+</li><li>2.PI Camera V2红外相机-800w像素</li><li>3.850 nm红外光源</li></ul><h4 id="7-实际工况"><a href="#7-实际工况" class="headerlink" title="7.实际工况"></a>7.实际工况</h4><p> <img src="/pictures/clipboard55.png" alt="img"><br> <img src="/pictures/clipboard56.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
          <category> 树莓派 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>剑指Offer68 / # 48 - 68</title>
      <link href="/2020/07/20/jianzhioffer3/"/>
      <url>/2020/07/20/jianzhioffer3/</url>
      
        <content type="html"><![CDATA[<h1 id="48-68"><a href="#48-68" class="headerlink" title="48 - 68"></a>48 - 68</h1><hr><h3 id="48-最长不含重复字符的子字符串"><a href="#48-最长不含重复字符的子字符串" class="headerlink" title="48.    最长不含重复字符的子字符串"></a>48.    最长不含重复字符的子字符串</h3><ul><li><blockquote><p>请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。</p></blockquote></li></ul><ul><li>输出</li><li>输入: “abcabcbb”</li><li>输出: 3 </li><li>解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。</li></ul><hr><ul><li>输入: “bbbbb”</li><li>输出: 1</li><li>解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。</li></ul><hr><ul><li>输入: “pwwkew”</li><li>输出: 3</li><li>解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。</li><li>请注意，你的答案必须是 子串 的长度，”pwke” 是一个子序列，不是子串。</li></ul><hr><ul><li><blockquote><p>方法：双指针 + 辅助数组，最多256个字符</p></blockquote></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (s.<span class="built_in">size</span>() &lt;= <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> s.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;arr(<span class="number">256</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> right = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (right &lt; s.<span class="built_in">size</span>()) &#123;</span><br><span class="line"><span class="keyword">char</span> tempChar = s[right++];<span class="comment">//右是开，区间外第一个字符</span></span><br><span class="line">arr[tempChar]++;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (arr[tempChar] &gt; <span class="number">1</span>) &#123;  <span class="comment">//说明有重复的</span></span><br><span class="line">arr[s[left]]--;<span class="comment">//左边字符去除</span></span><br><span class="line">left++;<span class="comment">//左值针移动</span></span><br><span class="line">&#125;</span><br><span class="line">res = <span class="built_in">max</span>(res, right - left);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="49-丑数"><a href="#49-丑数" class="headerlink" title="49.丑数"></a>49.丑数</h3><ul><li><blockquote><p>我们把只包含质因子 2、3 和 5 的数称作丑数（Ugly Number）。求按从小到大的顺序的第 n 个丑数。</p></blockquote></li><li><blockquote><p>输出</p></blockquote></li><li><p>输入: n = 10</p></li><li><p>输出: 12</p></li><li><p>解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。</p></li><li><blockquote><p>方法：丑数本身是丑数，丑数是在丑数的基础上*2 或 *3 或 *5</p></blockquote></li><li><p>所以我们在三个丑数数组中选取最小的数来组成，三个变量a、b、c</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">nthUglyNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>, c = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;dp(n, <span class="number">0</span>);</span><br><span class="line">dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//在三个顺序数组中拿出最小的数组成</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> temp1 = dp[a] * <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> temp2 = dp[b] * <span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> temp3 = dp[c] * <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">dp[i] = <span class="built_in">min</span>(temp1, <span class="built_in">min</span>(temp2, temp3));</span><br><span class="line"><span class="keyword">if</span> (dp[i] == temp1)a++;</span><br><span class="line"><span class="keyword">if</span> (dp[i] == temp2)b++;</span><br><span class="line"><span class="keyword">if</span> (dp[i] == temp3)c++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="50-第一个只出现一次的字符"><a href="#50-第一个只出现一次的字符" class="headerlink" title="50.第一个只出现一次的字符"></a>50.第一个只出现一次的字符</h3><ul><li><blockquote><p>在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。 s 只包含小写字母。</p></blockquote></li><li><blockquote><p>输出</p></blockquote></li><li><p>s = “abaccdeff”</p></li><li><p>返回 “b”</p></li><li><p>s = “” </p></li><li><p>返回 “ “</p></li><li><blockquote><p>方法：哈希表统计</p></blockquote></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">firstUniqChar</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; t;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> temp : s) t[temp]++;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">char</span> temp : s)</span><br><span class="line"><span class="keyword">if</span> (t[temp] == <span class="number">1</span>) <span class="keyword">return</span> temp;</span><br><span class="line"><span class="keyword">return</span> <span class="string">' '</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="51-数组中的逆序对"><a href="#51-数组中的逆序对" class="headerlink" title="51.数组中的逆序对"></a>51.数组中的逆序对</h3><ul><li><blockquote><p>方法：归并</p></blockquote></li><li><strong>在归并排序的基础上，加上两行。</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;arr, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;temp, <span class="keyword">int</span> L, <span class="keyword">int</span> mid, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> p1 = L;</span><br><span class="line"><span class="keyword">int</span> p2 = mid + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> p = L;</span><br><span class="line"><span class="keyword">while</span> (p1 &lt;= mid &amp;&amp; p2 &lt;= R) &#123;</span><br><span class="line"><span class="keyword">if</span> (arr[p1] &lt;= arr[p2]) &#123;</span><br><span class="line">temp[p++] = arr[p1++];</span><br><span class="line">res += p2 - (mid + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">temp[p++] = arr[p2++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (p1 &lt;= mid) &#123;</span><br><span class="line">temp[p++] = arr[p1++];</span><br><span class="line">res += p2 - (mid + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (p2 &lt;= R)  temp[p++] = arr[p2++];</span><br><span class="line"></span><br><span class="line">copy(temp.<span class="built_in">begin</span>() + L, temp.<span class="built_in">begin</span>() + R + <span class="number">1</span>, arr.<span class="built_in">begin</span>() + L);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;arr, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;tmp, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (L &gt;= R)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> mid = (L + R) / <span class="number">2</span>;</span><br><span class="line">sort(arr, tmp, L, mid);</span><br><span class="line">sort(arr, tmp, mid + <span class="number">1</span>, R);</span><br><span class="line"></span><br><span class="line">merge(arr, tmp, L, mid, R);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">reversePairs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;tmp(nums.<span class="built_in">size</span>());</span><br><span class="line">sort(nums, tmp, <span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="52-两个链表的第一个公共节点"><a href="#52-两个链表的第一个公共节点" class="headerlink" title="52.两个链表的第一个公共节点"></a>52.两个链表的第一个公共节点</h3><ul><li><blockquote><p>输入两个链表，找出它们的第一个公共节点。</p></blockquote></li><li><blockquote><p>输出<br><img src="/pictures/clipboard36.png" alt="img1"></p></blockquote></li><li><blockquote><p>方法：</p></blockquote></li><li><p>a + c + b = b + c + a程序员的浪漫</p></li><li><blockquote><p>太浪漫了 两个结点不断的去对方的轨迹中寻找对方的身影</p></blockquote></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">ListNode *h1 = headA, *h2 = headB;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (h1 != h2) &#123;</span><br><span class="line">h1 = h1 == <span class="literal">NULL</span> ? headB : h1-&gt;next;</span><br><span class="line">h2 = h2 == <span class="literal">NULL</span> ? headA : h2-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> h1;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="53-1-在排序数组中查找数字出现次数"><a href="#53-1-在排序数组中查找数字出现次数" class="headerlink" title="53-1.在排序数组中查找数字出现次数"></a>53-1.在排序数组中查找数字出现次数</h3><ul><li><blockquote><p>统计一个数字在排序数组中出现的次数。</p></blockquote></li><li><blockquote><p>输出</p></blockquote></li><li><blockquote><p>输入: nums = [5,7,7,8,8,10], target = 8</p></blockquote></li><li><p>输出: 2</p></li><li><blockquote><p>输入: nums = [5,7,7,8,8,10], target = 6</p></blockquote></li><li><p>输出: 0</p></li><li><blockquote><p>方法：二分法！！有序一般都是二分法</p></blockquote></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line"><span class="keyword">int</span> mid = left + right &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (nums[mid] &lt; target)</span><br><span class="line">left = mid + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">right = mid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (left &lt; nums.<span class="built_in">size</span>() &amp;&amp; nums[left++] == target)</span><br><span class="line">res++;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="53-2-0～n-1中缺失的数字"><a href="#53-2-0～n-1中缺失的数字" class="headerlink" title="53-2. 0～n-1中缺失的数字"></a>53-2. 0～n-1中缺失的数字</h3><ul><li><blockquote><p>一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。</p></blockquote></li><li><blockquote><p>输出</p></blockquote></li><li><blockquote><p>输入: [0,1,3]</p></blockquote></li><li><p>输出: 2</p></li><li><blockquote><p>输入: [0,1,2,3,4,5,6,7,9]</p></blockquote></li><li><p>输出: 8</p></li></ul><ul><li><blockquote><p>方法：二分法，但是最后的判断很难。找到最左边不等于下标的数。</p></blockquote></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line"><span class="keyword">int</span> mid = left + right &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (nums[mid] != mid)</span><br><span class="line">right = mid;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">left = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果从0 ~ n-1都不缺值, 则缺少的是n /  比如： 012,输出3</span></span><br><span class="line"><span class="keyword">return</span> left == nums.<span class="built_in">size</span>() - <span class="number">1</span> &amp;&amp; nums[left] == left ? left + <span class="number">1</span> : left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="54-二叉搜索树的第k大节点"><a href="#54-二叉搜索树的第k大节点" class="headerlink" title="54.二叉搜索树的第k大节点"></a>54.二叉搜索树的第k大节点</h3><ul><li><blockquote><p>给定一棵二叉搜索树，请找出其中第k大的节点。</p></blockquote></li><li><blockquote><p>输出<br><img src="/pictures/clipboard37.png" alt="img1"></p></blockquote></li><li><blockquote><p>方法：利用搜索二叉树的中序遍历得到顺序数组</p></blockquote></li><li><blockquote><p>方法：更加优秀的，直接利用倒置的中序遍历，反向从大到小开始遍历。</p></blockquote></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// int kthLargest(TreeNode* root, int k) &#123;</span></span><br><span class="line"><span class="comment">//     vector&lt;int&gt;res;</span></span><br><span class="line"><span class="comment">//     help(root,res);</span></span><br><span class="line"><span class="comment">//     return res[res.size()-k];</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// void help(TreeNode* root,vector&lt;int&gt;&amp; arr)&#123;</span></span><br><span class="line"><span class="comment">//     if(root==NULL)</span></span><br><span class="line"><span class="comment">//         return;</span></span><br><span class="line"><span class="comment">//     help(root-&gt;left,arr);</span></span><br><span class="line"><span class="comment">//     arr.push_back(root-&gt;val);</span></span><br><span class="line"><span class="comment">//     help(root-&gt;right,arr);</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">//反向利用中序</span></span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kthLargest</span><span class="params">(TreeNode* root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">help(root, k);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">help</span><span class="params">(TreeNode* root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">help(root-&gt;right, k);</span><br><span class="line"><span class="keyword">if</span> (++count == k)</span><br><span class="line">res = root-&gt;val;</span><br><span class="line"></span><br><span class="line">help(root-&gt;left, k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="55-1-二叉树的深度"><a href="#55-1-二叉树的深度" class="headerlink" title="55-1.    二叉树的深度"></a>55-1.    二叉树的深度</h3><ul><li><blockquote><p>输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。</p></blockquote></li><li><blockquote><p>输出<br><img src="/pictures/clipboard38.png" alt="img1"></p></blockquote></li><li><blockquote><p>方法：dfs求取树的深度</p></blockquote></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> lTree = maxDepth(root-&gt;left) + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> rTree = maxDepth(root-&gt;right) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> lTree &gt; rTree ? lTree : rTree;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="55-2-判断是否平衡二叉树"><a href="#55-2-判断是否平衡二叉树" class="headerlink" title="55-2.判断是否平衡二叉树"></a>55-2.判断是否平衡二叉树</h3><ul><li><blockquote><p>输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。</p></blockquote></li><li><blockquote><p>输出<br><img src="/pictures/clipboard57.png" alt="img"></p></blockquote></li><li><blockquote><p>方法：</p></blockquote></li><li><p>DFS遍历看是否满足条件1：左中右和条件2：高度差不大于1</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line"><span class="comment">//平衡二叉树——1.二叉搜索树2.左右子树高度差小于等于1</span></span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">abs</span>(depth(root-&gt;left) - depth(root-&gt;right)) &gt; <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> isBalanced(root-&gt;left) &amp;&amp; isBalanced(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">depth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">max</span>(depth(root-&gt;left), depth(root-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="拓展-二叉树路径和是否为Sum"><a href="#拓展-二叉树路径和是否为Sum" class="headerlink" title="拓展.二叉树路径和是否为Sum"></a>拓展.二叉树路径和是否为Sum</h3><p><img src="/pictures/clipboard69.png" alt="img1"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (root-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;right == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> sum - root-&gt;val == <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> hasPathSum(root-&gt;left, sum - root-&gt;val) || hasPathSum(root-&gt;right, sum - root-&gt;val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="拓展-求二叉树的最大直径"><a href="#拓展-求二叉树的最大直径" class="headerlink" title="拓展.求二叉树的最大直径"></a>拓展.求二叉树的最大直径</h3><p><img src="/pictures/clipboard70.png" alt="img1"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> length;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">diameterOfBinaryTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">length = <span class="number">0</span>;</span><br><span class="line">dfs(root);</span><br><span class="line"><span class="keyword">return</span> length;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> L = dfs(root-&gt;left);</span><br><span class="line"><span class="keyword">int</span> R = dfs(root-&gt;right);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> curlength = L + R;</span><br><span class="line">length = <span class="built_in">max</span>(length, curlength); <span class="comment">//这个节点的最大值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">max</span>(L, R) + <span class="number">1</span>;            <span class="comment">//返回该子节点的最大分治</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="56-1-数组中数字出现的次数"><a href="#56-1-数组中数字出现的次数" class="headerlink" title="56-1.数组中数字出现的次数"></a>56-1.数组中数字出现的次数</h3><ul><li><blockquote><p>一个整型数组 nums 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。</p></blockquote></li><li><blockquote><p>输出</p></blockquote></li><li><blockquote><p>输入：nums = [4,1,4,6]</p></blockquote></li><li><p>输出：[1,6] 或 [6,1]</p></li><li><blockquote><p>输入：nums = [1,2,10,4,1,4,3,3]</p></blockquote></li><li><p>输出：[2,10] 或 [10,2]</p></li><li><blockquote><p>方法1：哈希表</p></blockquote></li><li><blockquote><p>方法2：位运算</p></blockquote></li><li><p>A^A=0</p></li><li><p>A&amp;(-A)=最低一位</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">singleNumbers</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//找出只出现一次的两个数,2和10</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it : nums)</span><br><span class="line">sum = sum ^ it;</span><br><span class="line"><span class="comment">//根据两者的最低二进制差异位，区分两个数</span></span><br><span class="line"><span class="keyword">int</span> flag = (-sum)&amp;sum;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;res(<span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line"><span class="comment">//根据差异位来区分两组数,2一组,10一组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it : nums) &#123;</span><br><span class="line"><span class="keyword">if</span> ((flag&amp;it))</span><br><span class="line">res[<span class="number">0</span>] ^= it;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">res[<span class="number">1</span>] ^= it;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="56-2-数组中数字出现的次数-II"><a href="#56-2-数组中数字出现的次数-II" class="headerlink" title="56-2.    数组中数字出现的次数 II"></a>56-2.    数组中数字出现的次数 II</h3><ul><li><blockquote><p>在一个数组 nums 中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字。</p></blockquote></li><li><blockquote><p>输出</p></blockquote></li><li><blockquote><p>输入：nums = [3,4,3,3]</p></blockquote></li><li><p>输出：4</p></li><li><blockquote><p>输入：nums = [9,1,7,9,7,9,7]</p></blockquote></li><li><p>输出：1</p></li><li><blockquote><p>方法1：哈希表</p></blockquote></li><li><blockquote><p>方法2：位运算 / 出现几次就能被几整除，然后找到那个不能整除的位，累加</p></blockquote></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line"><span class="comment">// unordered_map&lt;int, int&gt; mp;</span></span><br><span class="line"><span class="comment">// for(int n : nums) mp[n] ++;</span></span><br><span class="line"><span class="comment">// int ans;</span></span><br><span class="line"><span class="comment">// for(auto pr : mp)&#123;</span></span><br><span class="line"><span class="comment">//     if(pr.second == 1)&#123;</span></span><br><span class="line"><span class="comment">//         ans = pr.first;</span></span><br><span class="line"><span class="comment">//         break;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// return ans;</span></span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it : nums) &#123;</span><br><span class="line"><span class="keyword">if</span> (it&amp;(<span class="number">1</span> &lt;&lt; i))temp++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (temp % <span class="number">3</span> == <span class="number">1</span>)res ^= (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="57-1-数组中和为s的两个数字"><a href="#57-1-数组中和为s的两个数字" class="headerlink" title="57-1.数组中和为s的两个数字"></a>57-1.数组中和为s的两个数字</h3><ul><li><blockquote><p>输入一个递增排序的数组和一个数字s，在数组中查找两个数，使得它们的和正好是s。如果有多对数字的和等于s，则输出任意一对即可。</p></blockquote></li><li><blockquote><p>输出</p></blockquote></li><li><blockquote><p>输入：nums = [2,7,11,15], target = 9</p></blockquote></li><li><p>输出：[2,7] 或者 [7,2]</p></li><li><blockquote><p>输入：nums = [10,26,30,31,47,60], target = 40</p></blockquote></li><li><p>输出：[10,30] 或者 [30,10]</p></li></ul><ul><li><blockquote><p>方法：有序！！双指针</p></blockquote></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line"><span class="comment">//1.哈希表</span></span><br><span class="line"><span class="comment">//2.双指针</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;res;</span><br><span class="line"><span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line"><span class="keyword">int</span> mid = left + right &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (nums[left] + nums[right] &lt; target)</span><br><span class="line">left++;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (nums[left] + nums[right] &gt; target)</span><br><span class="line">right--;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> &#123; nums[left],nums[right] &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="57-2-和为s的连续正数序列"><a href="#57-2-和为s的连续正数序列" class="headerlink" title="57-2.和为s的连续正数序列"></a>57-2.和为s的连续正数序列</h3><ul><li><blockquote><p>输入一个正整数 target ，输出所有和为 target 的连续正整数序列（至少含有两个数）。</p></blockquote></li><li>序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。</li></ul><ul><li><blockquote><p>输出</p></blockquote></li><li><blockquote><p>输入：target = 9</p></blockquote></li><li><p>输出：[[2,3,4],[4,5]]</p></li><li><blockquote><p>输入：target = 15</p></blockquote></li><li><p>输出：[[1,2,3,4,5],[4,5,6],[7,8]]</p></li><li><blockquote><p>方法：有序数组！！双指针区间的压缩和遍历</p></blockquote></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">findContinuousSequence</span><span class="params">(<span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;<span class="comment">//双指针缩放，连续空间</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;res;</span><br><span class="line"><span class="keyword">while</span> (i &lt;= target / <span class="number">2</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (sum &lt; target) &#123;</span><br><span class="line">sum += j;</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; target) &#123;</span><br><span class="line">sum -= i;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;temp;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> u = i; u &lt; j; u++) &#123;</span><br><span class="line">temp.push_back(u);</span><br><span class="line">&#125;</span><br><span class="line">res.push_back(temp);</span><br><span class="line">sum -= i++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="58-1-翻转单词顺序"><a href="#58-1-翻转单词顺序" class="headerlink" title="58-1.翻转单词顺序"></a>58-1.翻转单词顺序</h3><ul><li><blockquote><p>输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如输入字符串”I am a student. “，则输出”student. a am I”。</p></blockquote></li></ul><ul><li><blockquote><p>输出</p></blockquote></li><li><blockquote><p>输入: “the sky is blue”</p></blockquote></li><li><p>输出: “blue is sky the”</p></li><li><blockquote><p>输入: “  hello world!  “</p></blockquote></li><li><p>输出: “world! hello”</p></li><li><p>解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。</p></li><li><blockquote><p>输入: “a good   example”</p></blockquote></li><li><p>输出: “example good a”</p></li><li><p>解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</p></li><li><blockquote><p>方法：利用stringstream ss(s)，但是当首字母有空的时候，还是直接使用&gt;&gt;；而不是getline</p></blockquote></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">reverseWords</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (s.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> res;</span><br><span class="line"><span class="function"><span class="built_in">stringstream</span> <span class="title">ss</span><span class="params">(s)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> temp;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;arr;</span><br><span class="line"><span class="comment">//getline(ss,temp,' ')</span></span><br><span class="line"><span class="keyword">while</span> (ss &gt;&gt; temp) &#123;</span><br><span class="line">arr.push_back(temp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//很重要很重要</span></span><br><span class="line"><span class="keyword">if</span> (arr.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = arr.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">res += arr[i] + <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line">res += arr[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="58-2-左旋转字符串"><a href="#58-2-左旋转字符串" class="headerlink" title="58-2.左旋转字符串"></a>58-2.左旋转字符串</h3><ul><li><blockquote><p>字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串”abcdefg”和数字2，该函数将返回左旋转两位得到的结果”cdefgab”。</p></blockquote></li></ul><ul><li><blockquote><p>输出</p></blockquote></li><li><p>输入: s = “abcdefg”, k = 2</p></li><li><p>输出: “cdefgab”</p></li><li><p>输入: s = “lrloseumgh”, k = 6</p></li><li><p>输出: “umghlrlose”</p></li></ul><ul><li><blockquote><p>方法：substr</p></blockquote></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">reverseLeftWords</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span>  s.substr(n, s.<span class="built_in">size</span>() - n) + s.substr(<span class="number">0</span>, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="59-1-滑动窗口的最大值——利用deque维护（连续区间）"><a href="#59-1-滑动窗口的最大值——利用deque维护（连续区间）" class="headerlink" title="59-1.滑动窗口的最大值——利用deque维护（连续区间）"></a>59-1.滑动窗口的最大值——利用deque维护（连续区间）</h3><ul><li><blockquote><p>给定一个数组 nums 和滑动窗口的大小 k，请找出所有滑动窗口里的最大值。</p></blockquote></li><li><blockquote><p>输出</p></blockquote></li><li><p>输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3</p></li><li><p>输出: [3,3,5,5,6,7] </p></li><li><p>解释: </p></li><li><p>滑动窗口的位置                最大值</p></li></ul><hr><ul><li>[1  3  -1] -3  5  3  6  7       3</li><li>1 [3  -1  -3] 5  3  6  7       3</li><li>1  3 [-1  -3  5] 3  6  7       5</li><li>1  3  -1 [-3  5  3] 6  7       5</li><li>1  3  -1  -3 [5  3  6] 7       6</li><li>1  3  -1  -3  5 [3  6  7]      7</li></ul><ul><li><blockquote><p>方法：利用deque维护数组的最大值<br><img src="/pictures/clipboard58.png" alt="img"></p></blockquote></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; dq;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line"><span class="keyword">while</span> (!dq.empty() &amp;&amp; i - dq.front() + <span class="number">1</span> &gt; k) &#123;</span><br><span class="line">dq.pop_front();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (!dq.empty() &amp;&amp; nums[dq.back()] &lt;= nums[i]) &#123;</span><br><span class="line">dq.pop_back();</span><br><span class="line">&#125;</span><br><span class="line">dq.push_back(i);</span><br><span class="line"><span class="keyword">if</span> (i &gt;= k - <span class="number">1</span>)</span><br><span class="line">res.push_back(nums[dq.front()]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="59-2-队列的最大值"><a href="#59-2-队列的最大值" class="headerlink" title="59-2.队列的最大值"></a>59-2.队列的最大值</h3><ul><li><blockquote><p>使得queue实现max_value、push_back 和 pop_front功能，同时摊时间复杂度都是O(1)。</p></blockquote></li><li><blockquote><p>输出</p></blockquote></li><li><blockquote><p>输入: </p></blockquote></li><li><p>[“MaxQueue”,”push_back”,”push_back”,”max_value”,”pop_front”,”max_value”]</p></li><li><p>[[],[1],[2],[],[],[]]</p></li><li><p>输出: [null,null,null,2,1,2]</p></li><li><blockquote><p>输入: </p></blockquote></li><li><p>[“MaxQueue”,”pop_front”,”max_value”]</p></li><li><p>[[],[],[]]</p></li><li><p>输出: [null,-1,-1]</p></li><li><blockquote><p>方法：queue正常元素入出，deque维护最大值的变化</p></blockquote></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; dq;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max_value</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> que.empty() ? <span class="number">-1</span> : dq.front();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">que.push(value);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!dq.empty() &amp;&amp; dq.back() &lt; value)   <span class="comment">//重要</span></span><br><span class="line">dq.pop_back();</span><br><span class="line">dq.push_back(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pop_front</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (que.empty())</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> t = que.front();</span><br><span class="line">que.pop();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (t == dq.front())</span><br><span class="line">dq.pop_front();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="60-n个骰子的点数-（难）"><a href="#60-n个骰子的点数-（难）" class="headerlink" title="60.n个骰子的点数 （难）"></a>60.n个骰子的点数 （难）</h3><ul><li><blockquote><p>把n个骰子扔在地上，所有骰子朝上一面的点数之和为s。输入n，打印出s的所有可能的值出现的概率。</p></blockquote></li><li><p>你需要用一个浮点数数组返回答案，其中第 i 个元素代表这 n 个骰子所能掷出的点数集合中第 i 小的那个的概率。</p></li></ul><ul><li><blockquote><p>输出</p></blockquote></li><li><blockquote><p>输入: 1</p></blockquote></li><li><p>输出: [0.16667,0.16667,0.16667,0.16667,0.16667,0.16667]</p></li><li><blockquote><p>输入: 2</p></blockquote></li><li><p>输出: [0.02778,0.05556,0.08333,0.11111,0.13889,0.16667,0.13889,0.11111,0.08333,0.05556,0.02778]</p></li></ul><ul><li><blockquote><p>方法：dp动态规划</p></blockquote></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; <span class="title">twoSum</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; <span class="title">res</span><span class="params">(<span class="number">6</span> * n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">res[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">6</span> * i; j &gt;= i; j--) &#123;</span><br><span class="line">res[j] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x = j - <span class="number">1</span>; x &gt;= i - <span class="number">1</span> &amp;&amp; x &gt;= j - <span class="number">6</span>; x--) res[j] += res[x];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;num : res) num /= <span class="built_in">pow</span>(<span class="number">6</span>, n);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;(res.<span class="built_in">begin</span>() + n, res.<span class="built_in">end</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="61-扑克牌中的顺子"><a href="#61-扑克牌中的顺子" class="headerlink" title="61.扑克牌中的顺子"></a>61.扑克牌中的顺子</h3><ul><li><blockquote><p>从扑克牌中随机抽5张牌，判断是不是一个顺子，即这5张牌是不是连续的。2～10为数字本身，A为1，J为11，Q为12，K为13，而大、小王为 0 ，可以看成任意数字。A 不能视为 14。</p></blockquote></li></ul><ul><li><blockquote><p>输出</p></blockquote></li><li><blockquote><p>输入: [1,2,3,4,5]</p></blockquote></li><li><p>输出: True</p></li><li><blockquote><p>输入: [0,0,1,2,5]</p></blockquote></li><li><p>输出: True</p></li><li><blockquote><p>方法：顺序遍历，相等return false；分类讨论；</p></blockquote></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isStraight</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">sort(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line"><span class="keyword">int</span> king = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> diff = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>() - <span class="number">1</span>; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (nums[i] == <span class="number">0</span>)</span><br><span class="line">king++;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (nums[i] == nums[i + <span class="number">1</span>])</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">diff += nums[i + <span class="number">1</span>] - nums[i] - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> diff &gt; king ? <span class="literal">false</span> : <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="62-圆圈中最后剩下的数字（约瑟夫环问题）"><a href="#62-圆圈中最后剩下的数字（约瑟夫环问题）" class="headerlink" title="62.圆圈中最后剩下的数字（约瑟夫环问题）"></a>62.圆圈中最后剩下的数字（约瑟夫环问题）</h3><ul><li><blockquote><p>0,1,,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字。求出这个圆圈里剩下的最后一个数字。</p></blockquote></li><li><p>例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。</p></li></ul><ul><li><blockquote><p>输出</p></blockquote></li><li><blockquote><p>输入: n = 5, m = 3</p></blockquote></li><li><p>输出: 3</p></li><li><blockquote><p>输入: n = 10, m = 17</p></blockquote></li><li><p>输出: 2</p></li><li><blockquote><p>方法：约瑟夫环问题<br><img src="/pictures/clipboard59.png" alt="img"><br><img src="/pictures/clipboard60.png" alt="img"></p></blockquote></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lastRemaining</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line"><span class="comment">//约瑟夫环的问题</span></span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n + <span class="number">1</span>; i++) &#123;</span><br><span class="line">res = (res + m) % i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="63-股票的最大利润"><a href="#63-股票的最大利润" class="headerlink" title="63.股票的最大利润"></a>63.股票的最大利润</h3><ul><li><blockquote><p>假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可能获得的最大利润是多少？</p></blockquote></li><li><blockquote><p>输出</p></blockquote></li><li><blockquote><p>输入: [7,1,5,3,6,4]</p></blockquote></li><li><p>输出: 5</p></li><li><p>解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。</p></li><li><p>注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。</p></li><li><blockquote><p>输入: [7,6,4,3,1]</p></blockquote></li><li><p>输出: 0</p></li><li><p>解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</p></li></ul><ul><li><blockquote><p>方法：动态方程</p></blockquote></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">res = <span class="built_in">max</span>(res, prices[i] - prices[i - <span class="number">1</span>]);</span><br><span class="line">prices[i] = <span class="built_in">min</span>(prices[i], prices[i - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="64-求1-2-…-n"><a href="#64-求1-2-…-n" class="headerlink" title="64.求1+2+…+n"></a>64.求1+2+…+n</h3><ul><li><blockquote><p>求 1+2+…+n ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。</p></blockquote></li><li><blockquote><p>输出</p></blockquote></li><li><p>输入: n = 3</p></li><li><p>输出: 6</p></li></ul><ul><li><blockquote><p>方法：sizeof</p></blockquote></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sumNums</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">bool</span> arr[n][n + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">sizeof</span>(arr) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="65-不用加减乘除做加法"><a href="#65-不用加减乘除做加法" class="headerlink" title="65.不用加减乘除做加法"></a>65.不用加减乘除做加法</h3><ul><li><blockquote><p>写一个函数，求两个整数之和，要求在函数体内不得使用 “+”、“-”、“*”、“/” 四则运算符号。</p></blockquote></li><li><blockquote><p>输出</p></blockquote></li><li><p>输入: a = 1, b = 1</p></li><li><p>输出: 2</p></li><li><blockquote><p>方法：位运算</p></blockquote></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (b) &#123;        <span class="comment">//当没有进位则返回</span></span><br><span class="line"> <span class="comment">// 注意leetcode中C++无法对int型最小值进行左移（所以转为无符号int型）</span></span><br><span class="line"><span class="keyword">int</span> temp = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(a &amp; b) &lt;&lt; <span class="number">1</span>;<span class="comment">//c:进位和————双1才1</span></span><br><span class="line">a ^= b;              <span class="comment">//a:非进位和——单1才1</span></span><br><span class="line">b = temp;               <span class="comment">//b = 进位</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="66-构建乘积数组"><a href="#66-构建乘积数组" class="headerlink" title="66.构建乘积数组"></a>66.构建乘积数组</h3><ul><li><blockquote><p>给定一个数组 A[0,1,…,n-1]，请构建一个数组 B[0,1,…,n-1]，其中 B 中的元素 B[i]=A[0]×A[1]×…×A[i-1]×A[i+1]×…×A[n-1]。不能使用除法。</p></blockquote></li></ul><ul><li><blockquote><p>输出</p></blockquote></li><li><p>输入: [1,2,3,4,5]</p></li><li><p>输出: [120,60,40,30,24]</p></li><li><blockquote><p>方法：先左后右</p></blockquote></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">constructArr</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a)</span> </span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;res(a.<span class="built_in">size</span>(), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cur = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">res[i] = cur; <span class="comment">//乘以左边的数</span></span><br><span class="line">cur *= a[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cur = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = a.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">res[i] *= cur;</span><br><span class="line">cur *= a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="67-把字符串转换成整数"><a href="#67-把字符串转换成整数" class="headerlink" title="67.把字符串转换成整数"></a>67.把字符串转换成整数</h3><ul><li><blockquote><p>写一个函数 StrToInt，实现把字符串转换成整数这个功能。不能使用 atoi 或者其他类似的库函数。</p></blockquote></li><li><blockquote><p>输出</p></blockquote></li><li><blockquote><p>输入: “42”</p></blockquote></li><li><p>输出: 42</p></li><li><blockquote><p>输入: “space space -42”</p></blockquote></li><li><p>输出: -42</p></li><li><blockquote><p>输入: “4193 with words”</p></blockquote></li><li><p>输出: 4193</p></li><li><blockquote><p>输入: “-91283472332”</p></blockquote></li><li><p>输出: -2147483648</p></li><li><p>解释: 数字 “-91283472332” 超过 32 位有符号整数范围。<br>   因此返回 INT_MIN (−231) 。</p></li></ul><ul><li><blockquote><p>方法：isdigit()函数，头文件cstdio</p></blockquote></li><li><blockquote><p>INT:INT_MAX \ INT_MIN</p></blockquote></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">strToInt</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line"><span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> negative = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (str[i] == <span class="string">' '</span>)</span><br><span class="line">i++;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">isdigit</span>(str[i]) &amp;&amp; str[i] != <span class="string">'+'</span> &amp;&amp; str[i] != <span class="string">'-'</span>)<span class="comment">//非数字，正负号return</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (str[i] == <span class="string">'-'</span>) &#123;</span><br><span class="line">negative = <span class="literal">false</span>;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (str[i] == <span class="string">'+'</span>) &#123;</span><br><span class="line">negative = <span class="literal">true</span>;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">isdigit</span>(str[i])) &#123;</span><br><span class="line">res = res * <span class="number">10</span> + str[i] - <span class="string">'0'</span>;</span><br><span class="line"><span class="keyword">if</span> (negative == <span class="literal">true</span> &amp;&amp; res &gt; INT_MAX)</span><br><span class="line"><span class="keyword">return</span> INT_MAX;</span><br><span class="line"><span class="keyword">if</span> (negative == <span class="literal">false</span> &amp;&amp; -res &lt; INT_MIN)</span><br><span class="line"><span class="keyword">return</span> INT_MIN;</span><br><span class="line"></span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> negative ? res : -res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="68-1-二叉搜索树的最近公共祖先"><a href="#68-1-二叉搜索树的最近公共祖先" class="headerlink" title="68-1.二叉搜索树的最近公共祖先"></a>68-1.二叉搜索树的最近公共祖先</h3><ul><li><blockquote><p>二叉搜索树</p></blockquote></li><li><blockquote><p>输出<br><img src="/pictures/clipboard61.png" alt="img"></p></blockquote></li><li><blockquote><p>输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8</p></blockquote></li><li><p>输出: 6 </p></li><li><p>解释: 节点 2 和节点 8 的最近公共祖先是 6。</p></li><li><blockquote><p>输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4</p></blockquote></li><li><p>输出: 2</p></li><li><p>解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。</p></li></ul><ul><li><blockquote><p>方法：利用特性：左中右</p></blockquote></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (root-&gt;val &gt; p-&gt;val &amp;&amp;root-&gt;val &gt; q-&gt;val)</span><br><span class="line"><span class="keyword">return</span> lowestCommonAncestor(root-&gt;left, p, q);</span><br><span class="line"><span class="keyword">if</span> (root-&gt;val &lt; p-&gt;val &amp;&amp;root-&gt;val &lt; q-&gt;val)</span><br><span class="line"><span class="keyword">return</span> lowestCommonAncestor(root-&gt;right, p, q);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="68-2-二叉树的最近公共祖先"><a href="#68-2-二叉树的最近公共祖先" class="headerlink" title="68-2.二叉树的最近公共祖先"></a>68-2.二叉树的最近公共祖先</h3><ul><li><blockquote><p>方法：</p></blockquote></li></ul><p><img src="/pictures/clipboard62.png" alt="img"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">if</span> (root == q || root == p)</span><br><span class="line"><span class="keyword">return</span> root;</span><br><span class="line">TreeNode* L = lowestCommonAncestor(root-&gt;left, p, q);</span><br><span class="line">TreeNode* R = lowestCommonAncestor(root-&gt;right, p, q);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (L == <span class="literal">NULL</span>) <span class="keyword">return</span> R;</span><br><span class="line"><span class="keyword">if</span> (R == <span class="literal">NULL</span>) <span class="keyword">return</span> L;</span><br><span class="line"><span class="keyword">if</span> (L &amp;&amp; R) <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      <categories>
          
          <category> 剑指Offer </category>
          
          <category> 48 - 68 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>剑指Offer68 / # 26 - 47</title>
      <link href="/2020/07/20/jianzhioffer2/"/>
      <url>/2020/07/20/jianzhioffer2/</url>
      
        <content type="html"><![CDATA[<h1 id="26-47"><a href="#26-47" class="headerlink" title="26 - 47"></a>26 - 47</h1><hr><h3 id="26-树的子结构"><a href="#26-树的子结构" class="headerlink" title="26.树的子结构"></a>26.树的子结构</h3><ul><li><blockquote><p>输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)</p></blockquote></li></ul><p>B是A的子结构， 即 A中有出现和B相同的结构和节点值。</p><ul><li><blockquote><p>输入：</p></blockquote></li></ul><p><img src="/pictures/clipboard26.png" alt="img1"></p><ul><li><blockquote><p>解：<br><img src="/pictures/clipboard27.png" alt="img1"></p></blockquote></li></ul><ul><li><blockquote><p>方法：</p></blockquote></li></ul><ol><li>只要主树A有这一部分，B就是他的子树。DFS深度遍历</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isSubStructure</span><span class="params">(TreeNode* father, TreeNode* son)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (father == <span class="literal">NULL</span> || son == <span class="literal">NULL</span>)<span class="comment">//空树不是任意一个树的子结构</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> dfs(father, son) ||</span><br><span class="line">isSubStructure(father-&gt;left, son) || isSubStructure(father-&gt;right, son);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(TreeNode* father, TreeNode* son)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (son == <span class="literal">NULL</span>) <span class="comment">//当不能有相同剩余节点，(son == NULL &amp;&amp; father == NULL)</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> (father == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (son-&gt;val != father-&gt;val)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">return</span> dfs(father-&gt;left, son-&gt;left) &amp;&amp; dfs(father-&gt;right, son-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="27-二叉树的镜像"><a href="#27-二叉树的镜像" class="headerlink" title="27.二叉树的镜像"></a>27.二叉树的镜像</h3><ul><li><blockquote><p>请完成一个函数，输入一个二叉树，该函数输出它的镜像。</p></blockquote></li><li><blockquote><p>输入：<br><img src="/pictures/clipboard28.png" alt="img1"></p></blockquote></li><li><blockquote><p>方法：</p></blockquote></li></ul><ol><li>层序遍历后，reserve</li><li>dfs递归</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">mirrorTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line"><span class="comment">// if(root==NULL)</span></span><br><span class="line"><span class="comment">//     return NULL;</span></span><br><span class="line"><span class="comment">// queue&lt;TreeNode*&gt;q;</span></span><br><span class="line"><span class="comment">// q.push(root);</span></span><br><span class="line"><span class="comment">// while(!q.empty())&#123;</span></span><br><span class="line"><span class="comment">//     TreeNode* tmp = q.front();</span></span><br><span class="line"><span class="comment">//     q.pop();</span></span><br><span class="line"><span class="comment">//     swap(tmp-&gt;left,tmp-&gt;right);</span></span><br><span class="line"><span class="comment">//     if(tmp-&gt;left) q.push(tmp-&gt;left);</span></span><br><span class="line"><span class="comment">//     if(tmp-&gt;right) q.push(tmp-&gt;right);</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// return root;</span></span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第一个节点交换</span></span><br><span class="line">TreeNode* tmp = root-&gt;left;</span><br><span class="line">root-&gt;left = root-&gt;right;</span><br><span class="line">root-&gt;right = tmp;</span><br><span class="line"></span><br><span class="line"><span class="comment">//接下来的节点交换</span></span><br><span class="line">mirrorTree(root-&gt;left);</span><br><span class="line">mirrorTree(root-&gt;right);</span><br><span class="line"><span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="28-对称的二叉树"><a href="#28-对称的二叉树" class="headerlink" title="28.对称的二叉树"></a>28.对称的二叉树</h3><ul><li><blockquote><p>请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。</p></blockquote></li><li><p>例如，二叉树 [1,2,2,3,4,4,3] 是对称的。</p></li><li><blockquote><p>输入：</p></blockquote></li></ul><ul><li><blockquote><p>方法：</p></blockquote></li></ul><ol><li>dsf遍历看是否满足要求，左对右，右对左</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">NULL</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> dfs(root-&gt;left, root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(TreeNode* left, TreeNode* right)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (left == <span class="literal">NULL</span> &amp;&amp; right == <span class="literal">NULL</span>)<span class="comment">//两边为空，真</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> (left == <span class="literal">NULL</span> || right == <span class="literal">NULL</span>)<span class="comment">//一边为空，假</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (left-&gt;val != right-&gt;val)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">return</span> dfs(left-&gt;right, right-&gt;left) &amp;&amp; dfs(right-&gt;right, left-&gt;left);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="29-顺时针打印矩阵"><a href="#29-顺时针打印矩阵" class="headerlink" title="29.顺时针打印矩阵"></a>29.顺时针打印矩阵</h3><ul><li><blockquote><p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。</p></blockquote></li><li><blockquote><p>输入：</p></blockquote></li><li><p>输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]</p></li><li><p>输出：[1,2,3,6,9,8,7,4,5]</p></li><li><p>输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]</p></li><li><p>输出：[1,2,3,4,8,12,11,10,9,5,6,7]</p></li><li><blockquote><p>方法：</p></blockquote></li></ul><ol><li>边界判断：上下左右，逐渐缩小范围</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">spiralOrder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;res;</span><br><span class="line"><span class="keyword">if</span> (matrix.empty())</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> up = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> down = matrix.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> right = matrix[<span class="number">0</span>].<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"><span class="comment">//左往右</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = left; i &lt;= right; i++)</span><br><span class="line">res.push_back(matrix[up][i]);</span><br><span class="line"><span class="keyword">if</span> (up == down)<span class="keyword">return</span> res;</span><br><span class="line">up++;</span><br><span class="line"><span class="comment">//上往下</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = up; i &lt;= down; i++)</span><br><span class="line">res.push_back(matrix[i][right]);</span><br><span class="line"><span class="keyword">if</span> (left == right)<span class="keyword">return</span> res;</span><br><span class="line">right--;</span><br><span class="line"><span class="comment">//右往左</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = right; i &gt;= left; i--)</span><br><span class="line">res.push_back(matrix[down][i]);</span><br><span class="line"><span class="keyword">if</span> (up == down)<span class="keyword">return</span> res;</span><br><span class="line">down--;</span><br><span class="line"><span class="comment">//下往上</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = down; i &gt;= up; i--)</span><br><span class="line">res.push_back(matrix[i][left]);</span><br><span class="line"><span class="keyword">if</span> (left == right)<span class="keyword">return</span> res;</span><br><span class="line">left++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="30-包含min函数的栈"><a href="#30-包含min函数的栈" class="headerlink" title="30.包含min函数的栈"></a>30.包含min函数的栈</h3><ul><li><blockquote><p>定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。</p></blockquote></li><li><blockquote><p>输入：</p></blockquote></li><li><p>MinStack minStack = new MinStack();</p></li><li><p>minStack.push(-2);</p></li><li><p>minStack.push(0);</p></li><li><p>minStack.push(-3);</p></li><li><p>minStack.min();   –&gt; 返回 -3.</p></li><li><p>minStack.pop();</p></li><li><p>minStack.top();      –&gt; 返回 0.</p></li><li><p>minStack.min();   –&gt; 返回 -2.</p></li></ul><ul><li><blockquote><p>方法：</p></blockquote></li></ul><ol><li>空间换时间，入栈两个数</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt;arr;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (arr.empty()) &#123;</span><br><span class="line">arr.push(x);</span><br><span class="line">arr.push(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (x &lt; arr.top()) &#123;</span><br><span class="line">arr.push(x);</span><br><span class="line">arr.push(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">int</span> temp = arr.top();</span><br><span class="line">arr.push(x);</span><br><span class="line">arr.push(temp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">arr.pop();</span><br><span class="line">arr.pop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> temp = arr.top();</span><br><span class="line">arr.pop();</span><br><span class="line"><span class="keyword">int</span> temp1 = arr.top();</span><br><span class="line">arr.push(temp);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> temp1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> arr.top();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="31-栈的压入、弹出序列"><a href="#31-栈的压入、弹出序列" class="headerlink" title="31.栈的压入、弹出序列"></a>31.栈的压入、弹出序列</h3><ul><li><blockquote><p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如，序列 {1,2,3,4,5} 是某栈的压栈序列，序列 {4,5,3,2,1} 是该压栈序列对应的一个弹出序列，但 {4,3,5,1,2} 就不可能是该压栈序列的弹出序列。</p></blockquote></li></ul><ul><li><blockquote><p>输入：</p></blockquote></li><li><p>输入：pushed = [1,2,3,4,5], popped = [4,5,3,2,1]</p></li><li><p>输出：true</p></li><li><p>解释：我们可以按以下顺序执行：</p></li><li><p>push(1), push(2), push(3), push(4), pop() -&gt; 4,</p></li><li><p>push(5), pop() -&gt; 5, pop() -&gt; 3, pop() -&gt; 2, pop() -&gt; 1</p></li><li><p>输入：pushed = [1,2,3,4,5], popped = [4,3,5,1,2]</p></li><li><p>输出：false</p></li><li><p>解释：1 不能在 2 之前弹出。</p></li></ul><ul><li><blockquote><p>方法：</p></blockquote></li></ul><ol><li>利用辅助栈</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">validateStackSequences</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; pushed, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; popped)</span> </span>&#123;</span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt;vis;</span><br><span class="line"><span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pushed.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">vis.push(pushed[i]);</span><br><span class="line"><span class="keyword">while</span> (!vis.empty() &amp;&amp; vis.top() == popped[index]) &#123;</span><br><span class="line">vis.pop();</span><br><span class="line">index++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> vis.empty() ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="32-1-从上到下打印二叉树"><a href="#32-1-从上到下打印二叉树" class="headerlink" title="32-1.从上到下打印二叉树"></a>32-1.从上到下打印二叉树</h3><ul><li><blockquote><p>从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。</p></blockquote></li><li><blockquote><p>输入：<br><img src="/pictures/clipboard29.png" alt="img1"></p></blockquote></li><li><blockquote><p>方法：</p></blockquote></li></ul><ol><li>利用队列层序遍历</li><li>关键点：int size = q.size() 然后for(int i =0;i&lt;size;i++)</li><li>初始化可以vector<int>(arr.rbegin().arr.rend());</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">levelOrder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line"><span class="comment">//利用队列层序遍历</span></span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> &#123;&#125;;</span><br><span class="line"><span class="built_in">queue</span>&lt;TreeNode*&gt;q;</span><br><span class="line">q.push(root);</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;res;</span><br><span class="line"><span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">size</span> = q.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span>; i++) &#123;</span><br><span class="line">TreeNode* temp = q.front();</span><br><span class="line"><span class="keyword">int</span> num = temp-&gt;val;</span><br><span class="line">res.push_back(num);</span><br><span class="line">q.pop();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (temp-&gt;left)q.push(temp-&gt;left);</span><br><span class="line"><span class="keyword">if</span> (temp-&gt;right)q.push(temp-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果需要保存节点</span></span><br><span class="line"><span class="comment">//index = !index;</span></span><br><span class="line"><span class="comment">//if(index)        </span></span><br><span class="line"><span class="comment">//    res.push_back(vector&lt;int&gt;(arr.rbegin(), arr.rend()));      </span></span><br><span class="line"><span class="comment">//else</span></span><br><span class="line">  res.push_back(arr);</span><br></pre></td></tr></table></figure><hr><h3 id="32-2-从上到下打印二叉树-II"><a href="#32-2-从上到下打印二叉树-II" class="headerlink" title="32-2.从上到下打印二叉树 II"></a>32-2.从上到下打印二叉树 II</h3><hr><h3 id="32-3-从上到下打印二叉树-III"><a href="#32-3-从上到下打印二叉树-III" class="headerlink" title="32-3.从上到下打印二叉树 III"></a>32-3.从上到下打印二叉树 III</h3><hr><h3 id="33-二叉搜索树的后序遍历序列"><a href="#33-二叉搜索树的后序遍历序列" class="headerlink" title="33.二叉搜索树的后序遍历序列"></a>33.二叉搜索树的后序遍历序列</h3><ul><li><blockquote><p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 true，否则返回 false。假设输入的数组的任意两个数字都互不相同。</p></blockquote></li><li><blockquote><p>输入：<br><img src="/pictures/clipboard30.png" alt="img1"></p></blockquote></li><li><blockquote><p>方法：</p></blockquote></li></ul><ol><li>二叉搜索树：左 &gt; 中 &gt; 右</li><li>后序遍历：左  右  中</li><li>根据输入的数组是后序遍历，区分区间来判断数的值是不是对的上</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">verifyPostorder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; postorder)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (postorder.<span class="built_in">size</span>() &lt; <span class="number">2</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">return</span> dfs(postorder, <span class="number">0</span>, postorder.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//左右中</span></span><br><span class="line"><span class="comment">//根节点大于左子树任意节点，小于右子树任意节点</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; postorder, <span class="keyword">int</span> left, <span class="keyword">int</span> root)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (left &gt;= root)<span class="comment">//只剩一个节点时候，之前已经满足了搜索二叉树的条件</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//所以还是满足，返回true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> rootValue = postorder[root];</span><br><span class="line"></span><br><span class="line"><span class="comment">//区分左右区间，先找左右区间的区分节点位置</span></span><br><span class="line"><span class="keyword">int</span> i = left;</span><br><span class="line"><span class="keyword">while</span> (i &lt; root &amp;&amp; postorder[i] &lt; rootValue)</span><br><span class="line">i++;</span><br><span class="line"><span class="comment">//此时i已经是第一个右节点位置</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; root; j++)</span><br><span class="line"><span class="keyword">if</span> (postorder[j] &lt; rootValue)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当前树没问题，检查左树和右树</span></span><br><span class="line"><span class="keyword">return</span> dfs(postorder, left, i - <span class="number">1</span>) &amp;&amp; dfs(postorder, i, root - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="34-二叉树中和为某一值的路径Sum-一条路径的和"><a href="#34-二叉树中和为某一值的路径Sum-一条路径的和" class="headerlink" title="34.二叉树中和为某一值的路径Sum = 一条路径的和"></a>34.二叉树中和为某一值的路径Sum = 一条路径的和</h3><ul><li><blockquote><p>输入一棵二叉树和一个整数，打印出二叉树中节点值的和为输入整数的所有路径。从树的根节点开始往下一直到叶节点所经过的节点形成一条路径。</p></blockquote></li></ul><ul><li><blockquote><p>输入：<br><img src="/pictures/clipboard31.png" alt="img1"></p></blockquote></li><li><blockquote><p>方法：</p></blockquote></li></ul><ol><li>回溯法 + dfs</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//找到所有路</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;res;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">pathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;temp;</span><br><span class="line">backtrack(root, sum, temp);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line"><span class="comment">//终止条件</span></span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="comment">//做出选择</span></span><br><span class="line">arr.push_back(root-&gt;val);</span><br><span class="line">sum -= root-&gt;val;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (sum == <span class="number">0</span> &amp;&amp; root-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">res.push_back(arr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">backtrack(root-&gt;left, sum, arr);</span><br><span class="line">backtrack(root-&gt;right, sum, arr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//撤销选择</span></span><br><span class="line">arr.pop_back();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="35-复杂链表的深拷贝"><a href="#35-复杂链表的深拷贝" class="headerlink" title="35.复杂链表的深拷贝"></a>35.复杂链表的深拷贝</h3><ul><li><blockquote></blockquote><img src="/pictures/clipboard32.png" alt="img1"></li></ul><ul><li><blockquote><p>方法：</p></blockquote></li></ul><ol><li>哈希表拷贝节点</li><li>原地节点的变化：<ul><li>1.复制原指针A -&gt; B -&gt; C 变 A -&gt; A’-&gt; B -&gt; B’-&gt; C-&gt; C’</li><li>2.改变random指针指向，上一步复制的节点包含了random节点</li><li>3.断开链表，同时复原</li></ul></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">Node(<span class="keyword">int</span> _val) &#123;</span><br><span class="line">val = _val;</span><br><span class="line">next = <span class="literal">NULL</span>;</span><br><span class="line"><span class="built_in">random</span> = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//深拷贝：复制对象 浅拷贝：复制对象的指针</span></span><br><span class="line"><span class="function">Node* <span class="title">copyRandomList</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (head == <span class="literal">NULL</span>)<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">//原地复制链表,且仅将next指针连接起来，例如A-&gt;B-&gt;C变成A-&gt;A'-&gt;B-&gt;B'-&gt;C-&gt;C'</span></span><br><span class="line">Node* cur = head;</span><br><span class="line"><span class="keyword">while</span> (cur) &#123;</span><br><span class="line">Node* newNode = <span class="keyword">new</span> Node(cur-&gt;val);</span><br><span class="line">newNode-&gt;next = cur-&gt;next;</span><br><span class="line">cur-&gt;next = newNode;</span><br><span class="line">cur = newNode-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">cur = head;<span class="comment">//cur指针复位</span></span><br><span class="line"><span class="comment">//第二步复制random指针，A'、B'、C'指到对应的位置</span></span><br><span class="line"><span class="keyword">while</span> (cur) &#123;</span><br><span class="line"><span class="keyword">if</span> (cur-&gt;<span class="built_in">random</span>) cur-&gt;next-&gt;<span class="built_in">random</span> = cur-&gt;<span class="built_in">random</span>-&gt;next;</span><br><span class="line">cur = cur-&gt;next-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//第三步将链表断开，例如A-&gt;A'-&gt;B-&gt;B'-&gt;C-&gt;C'变为A'-&gt;B'-&gt;C',且注意这一步应当将原链表复原。</span></span><br><span class="line">Node* returnhead = head-&gt;next;<span class="comment">//A',返回的节点</span></span><br><span class="line"></span><br><span class="line">Node* copycur = head-&gt;next;   <span class="comment">//A'</span></span><br><span class="line">cur = head; <span class="comment">//A</span></span><br><span class="line"><span class="keyword">while</span> (cur) &#123;</span><br><span class="line">cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">cur = cur-&gt;next;</span><br><span class="line"><span class="keyword">if</span> (copycur-&gt;next) &#123;</span><br><span class="line">copycur-&gt;next = copycur-&gt;next-&gt;next;</span><br><span class="line">copycur = copycur-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> returnhead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="36-二叉搜索树与双向链表"><a href="#36-二叉搜索树与双向链表" class="headerlink" title="36.二叉搜索树与双向链表"></a>36.二叉搜索树与双向链表</h3><ul><li><blockquote><p>输入一棵<strong>二叉搜索树</strong>，将该二叉搜索树转换成一个排序的循环双向链表。</p></blockquote></li><li><p>要求不能创建任何新的节点，只能调整树中节点指针的指向。</p></li></ul><p>为了让您更好地理解问题，以下面的二叉搜索树为例：<br><img src="/pictures/clipboard33.png" alt="img1"></p><p>我们希望将这个二叉搜索树转化为双向循环链表。链表中的每个节点都有一个<strong>前驱和后继</strong>指针。对于双向循环链表，第一个节点的前驱是最后一个节点，最后一个节点的后继是第一个节点。</p><p>下图展示了上面的二叉搜索树转化成的链表。“head” 表示指向链表中有最小元素的节点。<br><img src="/pictures/clipboard34.png" alt="img1"></p><ul><li><blockquote><p>输入：</p></blockquote></li><li><blockquote><p>方法：</p></blockquote></li></ul><ol><li>二叉搜索树——左中右形式存储——利用中序将节点截取下来</li><li>辅助指针逐渐将节点串联起来</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node* <span class="title">treeToDoublyList</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;Node*&gt;arr;</span><br><span class="line"><span class="comment">//左中右</span></span><br><span class="line">Inorder(root, arr);</span><br><span class="line"></span><br><span class="line">Node* head = arr[<span class="number">0</span>];</span><br><span class="line">Node* pre = arr[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">Node* temp = arr[i];</span><br><span class="line">pre-&gt;right = temp;</span><br><span class="line">temp-&gt;left = pre;</span><br><span class="line">pre = temp;</span><br><span class="line">&#125;</span><br><span class="line">pre-&gt;right = head;</span><br><span class="line">head-&gt;left = pre;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Inorder</span><span class="params">(Node* root, <span class="built_in">vector</span>&lt;Node*&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root-&gt;left)</span><br><span class="line">Inorder(root-&gt;left, arr);</span><br><span class="line"></span><br><span class="line">arr.push_back(root);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (root-&gt;right)</span><br><span class="line">Inorder(root-&gt;right, arr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="37-序列化二叉树-——-重要"><a href="#37-序列化二叉树-——-重要" class="headerlink" title="37.序列化二叉树 —— 重要"></a>37.序列化二叉树 —— 重要</h3><ul><li><blockquote><p>方法：</p></blockquote></li></ul><ol><li>利用getline截取数值</li><li>前序、中序、后续、层序都是可以的。对应的反序列化即可。</li><li>这次使用前序遍历</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//序列化,利用先序遍历——中左右</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">serialize</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="string">"#,"</span>;</span><br><span class="line"><span class="built_in">string</span> res = to_string(root-&gt;val) + <span class="string">","</span>;</span><br><span class="line">res += serialize(root-&gt;left);</span><br><span class="line">res += serialize(root-&gt;right);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//反序列化</span></span><br><span class="line"><span class="function">TreeNode* <span class="title">deserialize</span><span class="params">(<span class="built_in">string</span> data)</span> </span>&#123;</span><br><span class="line"><span class="comment">//利用getline来截取string</span></span><br><span class="line"><span class="function"><span class="built_in">stringstream</span> <span class="title">arr</span><span class="params">(data)</span></span>;</span><br><span class="line"><span class="built_in">string</span> temp;</span><br><span class="line"></span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="built_in">string</span>&gt;q;</span><br><span class="line"><span class="keyword">while</span> (getline(arr, temp, <span class="string">','</span>)) &#123;</span><br><span class="line">q.push(temp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> helper(q);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">TreeNode* <span class="title">helper</span><span class="params">(<span class="built_in">queue</span>&lt;<span class="built_in">string</span>&gt;&amp;q)</span> </span>&#123;</span><br><span class="line"><span class="built_in">string</span> temp = q.front();</span><br><span class="line">q.pop();</span><br><span class="line"><span class="keyword">if</span> (temp == <span class="string">"#"</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">TreeNode* node = <span class="keyword">new</span> TreeNode(stoi(temp));</span><br><span class="line">node-&gt;left = helper(q);</span><br><span class="line">node-&gt;right = helper(q);</span><br><span class="line"><span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//序列化,层序构建二叉树</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> val;</span><br><span class="line">TreeNode *left;</span><br><span class="line">TreeNode *right;</span><br><span class="line">TreeNode(<span class="keyword">int</span> x) : val(x), left(<span class="literal">NULL</span>), right(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">serialize</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line"><span class="built_in">string</span> out;</span><br><span class="line"><span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">q.push(root);</span><br><span class="line">    </span><br><span class="line"><span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">TreeNode* tmp = q.front();</span><br><span class="line">q.pop();</span><br><span class="line"><span class="keyword">if</span> (tmp) &#123;</span><br><span class="line">out += to_string(tmp-&gt;val) + <span class="string">" "</span>;</span><br><span class="line">q.push(tmp-&gt;left);</span><br><span class="line">q.push(tmp-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">out += <span class="string">"# "</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode* <span class="title">deserialize</span><span class="params">(<span class="built_in">string</span> data)</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="built_in">stringstream</span> <span class="title">input</span><span class="params">(data)</span></span>;</span><br><span class="line"><span class="built_in">string</span> val;</span><br><span class="line"><span class="built_in">vector</span>&lt;TreeNode*&gt; vec;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (input &gt;&gt; val) &#123;</span><br><span class="line"><span class="keyword">if</span> (val == <span class="string">"#"</span>) &#123;</span><br><span class="line">vec.push_back(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">vec.push_back(<span class="keyword">new</span> TreeNode(stoi(val)));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> j = <span class="number">1</span>;                                          <span class="comment">// i每往后移动一位，j移动两位，j始终是当前i的左子下标</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; j &lt; vec.<span class="built_in">size</span>(); ++i) &#123;              <span class="comment">// 肯定是j先到达边界，所以这里判断j &lt; vec.size()</span></span><br><span class="line"><span class="keyword">if</span> (vec[i] == <span class="literal">NULL</span>) <span class="keyword">continue</span>;                   <span class="comment">// vec[i]为null时跳过。</span></span><br><span class="line"><span class="keyword">if</span> (j &lt; vec.<span class="built_in">size</span>()) vec[i]-&gt;left = vec[j++];    <span class="comment">// 当前j位置为i的左子树</span></span><br><span class="line"><span class="keyword">if</span> (j &lt; vec.<span class="built_in">size</span>()) vec[i]-&gt;right = vec[j++];   <span class="comment">// 当前j位置为i的右子树</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> vec[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="38-字符串的排列"><a href="#38-字符串的排列" class="headerlink" title="38.字符串的排列"></a>38.字符串的排列</h3><ul><li><blockquote><p>输入一个字符串，打印出该字符串中字符的所有排列。</p></blockquote></li></ul><p>你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。</p><ul><li><blockquote><p>输入：</p></blockquote></li><li><p>输入：s = “abc”</p></li><li><p>输出：[“abc”,”acb”,”bac”,”bca”,”cab”,”cba”]</p></li><li><blockquote><p>方法：</p></blockquote></li></ul><ol><li>回溯法 + 剪枝叶</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">permutation</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">sort(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br><span class="line">backtrace(res, <span class="string">""</span>, s);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtrace</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;res, <span class="built_in">string</span> tmp, <span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line"><span class="comment">//终止条件</span></span><br><span class="line"><span class="keyword">if</span> (tmp.<span class="built_in">size</span>() == s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">res.push_back(tmp);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line"><span class="comment">//排除不合法</span></span><br><span class="line"><span class="keyword">if</span> (s[i] == <span class="string">'#'</span> || (i &gt; <span class="number">0</span> &amp;&amp; s[i] == s[i - <span class="number">1</span>]))    <span class="keyword">continue</span>;</span><br><span class="line"><span class="comment">//做出选择</span></span><br><span class="line"><span class="keyword">char</span> t = s[i];</span><br><span class="line">tmp += t;</span><br><span class="line">s[i] = <span class="string">'#'</span>;</span><br><span class="line"><span class="comment">//回溯函数</span></span><br><span class="line">backtrace(res, tmp, s);</span><br><span class="line"><span class="comment">//撤销选择</span></span><br><span class="line">s[i] = t;</span><br><span class="line">tmp.pop_back();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="39-数组中出现次数超过一半的数字"><a href="#39-数组中出现次数超过一半的数字" class="headerlink" title="39.数组中出现次数超过一半的数字"></a>39.数组中出现次数超过一半的数字</h3><ul><li><blockquote><p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。</p></blockquote><p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p></li><li><blockquote><p>输入：</p></blockquote></li><li><p>输入: [1, 2, 3, 2, 2, 2, 5, 4, 2]</p></li><li><p>输出: 2</p></li></ul><ul><li><blockquote><p>方法：</p></blockquote></li></ul><ol><li>哈希表</li><li>摩尔投票法</li><li>sorted，return中间元素</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//摩尔投票法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">res = nums[i];</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (nums[i] != res)</span><br><span class="line">count--;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="40-最小的k个数"><a href="#40-最小的k个数" class="headerlink" title="40.    最小的k个数"></a>40.    最小的k个数</h3><ul><li><blockquote><p>输入整数数组 arr ，找出其中最小的 k 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。</p></blockquote></li><li><blockquote><p>输入：</p></blockquote></li><li><p>输入：arr = [3,2,1], k = 2</p></li><li><p>输出：[1,2] 或者 [2,1]</p></li><li><p>输入：arr = [0,1,2,1], k = 1</p></li><li><p>输出：[0]</p></li><li><blockquote><p>方法：</p></blockquote></li></ul><ol><li>各种排序</li><li>快排</li><li>归并排序等</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">getLeastNumbers</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;res(k, <span class="number">0</span>);</span><br><span class="line">sort(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>());</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != k; i++) &#123;</span><br><span class="line">res[i] = arr[i];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="41-数据流中的中位数"><a href="#41-数据流中的中位数" class="headerlink" title="41.数据流中的中位数"></a>41.数据流中的中位数</h3><ul><li><blockquote><p>如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。</p></blockquote></li><li><blockquote><p>输入：</p></blockquote></li><li><p>[2,3,4] 的中位数是 3</p></li><li><p>[2,3] 的中位数是 (2 + 3) / 2 = 2.5</p></li><li><blockquote><p>方法：</p></blockquote></li></ul><ol><li>利用优先队列</li><li>大根堆保存小于中位数部分，小根堆保存大于中位数部分</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//头文件 / #include &lt;functional&gt;</span></span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, <span class="built_in">std</span>::less&lt;<span class="keyword">int</span>&gt;&gt; maxStack;</span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, <span class="built_in">std</span>::greater&lt;<span class="keyword">int</span>&gt;&gt; minStack;</span><br><span class="line"><span class="comment">//小顶堆多放一个数字</span></span><br><span class="line"><span class="comment">//小顶堆存放大于中位数的数</span></span><br><span class="line"><span class="comment">//大顶堆存放小于中位数的数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line"><span class="comment">//小顶堆元素+1</span></span><br><span class="line"><span class="keyword">if</span> (maxStack.<span class="built_in">size</span>() == minStack.<span class="built_in">size</span>()) &#123;</span><br><span class="line">maxStack.push(num);</span><br><span class="line">num = maxStack.top();</span><br><span class="line">maxStack.pop();</span><br><span class="line">minStack.push(num);</span><br><span class="line">&#125;<span class="comment">//大顶堆元素+1</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">minStack.push(num);</span><br><span class="line">num = minStack.top();</span><br><span class="line">minStack.pop();</span><br><span class="line">maxStack.push(num);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">findMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> maxStack.<span class="built_in">size</span>() == minStack.<span class="built_in">size</span>() ?</span><br><span class="line">(<span class="keyword">double</span>)(minStack.top() + maxStack.top()) / <span class="number">2</span> : minStack.top();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="42-连续子数组的最大和"><a href="#42-连续子数组的最大和" class="headerlink" title="42.连续子数组的最大和"></a>42.连续子数组的最大和</h3><ul><li><blockquote><p>输入一个整型数组，数组里有正数也有负数。数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。</p></blockquote></li></ul><p>要求时间复杂度为O(n)。</p><ul><li><blockquote><p>输入：</p></blockquote></li><li><p>输入: nums = [-2,1,-3,4,-1,2,1,-5,4]</p></li><li><p>输出: 6</p></li><li><p>解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</p></li><li><blockquote><p>方法：</p></blockquote></li></ul><ol><li>dp动态规划</li><li>贪心算法</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line"><span class="comment">//贪心算法</span></span><br><span class="line"><span class="comment">// int res = nums[0];</span></span><br><span class="line"><span class="comment">// int sum = 0;</span></span><br><span class="line"><span class="comment">// for(auto it:nums)&#123;</span></span><br><span class="line"><span class="comment">//     if(sum &gt; 0)</span></span><br><span class="line"><span class="comment">//         sum +=it;</span></span><br><span class="line"><span class="comment">//     else&#123;</span></span><br><span class="line"><span class="comment">//         sum = it;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">//     res = max(sum ,res);    </span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">//return res;</span></span><br><span class="line"><span class="comment">//动态规划</span></span><br><span class="line"><span class="keyword">int</span> res = nums[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;dp(len + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; i++) &#123;</span><br><span class="line">dp[i] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>] + nums[i - <span class="number">1</span>], nums[i - <span class="number">1</span>]);</span><br><span class="line">res = <span class="built_in">max</span>(dp[i], res);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="43-1～n整数中1出现的次数"><a href="#43-1～n整数中1出现的次数" class="headerlink" title="43.1～n整数中1出现的次数"></a>43.1～n整数中1出现的次数</h3><ul><li><blockquote><p>输入一个整数 n ，求1～n这n个整数的十进制表示中1出现的次数。</p></blockquote></li></ul><p>例如，输入12，1～12这些整数中包含1 的数字有1、10、11和12，1一共出现了5次。</p><ul><li><blockquote><p>输入：</p></blockquote></li><li><p>输入：n = 12</p></li><li><p>输出：5</p></li><li><p>输入：n = 13</p></li><li><p>输出：6<br><img src="/pictures/clipboard35.png" alt="img1"></p></li><li><blockquote><p>方法：</p></blockquote></li></ul><ol><li>找规律</li><li>区分低位、高位、当前位、位因子</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countDigitOne</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">long</span> digit = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> high = n / <span class="number">10</span>, cur = n % <span class="number">10</span>, low = <span class="number">0</span>; <span class="comment">//1234 high_123 cur_4 low_0</span></span><br><span class="line"><span class="keyword">while</span> (high != <span class="number">0</span> || cur != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">// 高位 * 低位为1的个数</span></span><br><span class="line"><span class="comment">// 然后通过对当前位进行判断，找真实的为1的个数</span></span><br><span class="line"><span class="keyword">if</span> (cur == <span class="number">0</span>) res += high * digit;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (cur == <span class="number">1</span>) res += high * digit + low + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> res += (high + <span class="number">1</span>) * digit;</span><br><span class="line"></span><br><span class="line">low += cur * digit;</span><br><span class="line">cur = high % <span class="number">10</span>;</span><br><span class="line">high /= <span class="number">10</span>;</span><br><span class="line">digit *= <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="44-数字序列中某一位的数字"><a href="#44-数字序列中某一位的数字" class="headerlink" title="44.    数字序列中某一位的数字"></a>44.    数字序列中某一位的数字</h3><ul><li><blockquote><p>数字以0123456789101112131415…的格式序列化到一个字符序列中。在这个序列中，第5位（从下标0开始计数）是5，第13位是1，第19位是4，等等。</p></blockquote></li></ul><p>请写一个函数，求任意第n位对应的数字。</p><ul><li><blockquote><p>输入：</p></blockquote></li><li><p>输入：n = 3</p></li><li><p>输出：3</p></li><li><p>输入：n = 11</p></li><li><p>输出：0</p></li><li><blockquote><p>方法：</p></blockquote></li></ul><ol><li>找规律</li><li>范围 / 数量 / 位数 / 占位</li><li>1-9 / 9 / 1 /  9</li><li>10-99 / 90 / 2 /  180</li><li>100-999 / 900 / 3 /  2700</li><li>区分数量、位数、占多少位</li></ol><ul><li><blockquote><p>方法：</p></blockquote></li><li>n = 2901</li><li>2901 = 9 + 180 + 2700 + 12 </li><li>数据：= 1000 + （12-1） / 4 = 1002</li><li>具体定位：（12 - 1） % 4 = 3；</li><li>1002[3] = 2</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findNthDigit</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> digit = <span class="number">1</span>;   <span class="comment">// n所在数字的位数</span></span><br><span class="line"><span class="keyword">long</span> start = <span class="number">1</span>;  <span class="comment">// 数字范围开始的第一个数</span></span><br><span class="line"><span class="keyword">long</span> count = <span class="number">9</span>;  <span class="comment">// 占多少位</span></span><br><span class="line"><span class="comment">//找到所在位数的区间</span></span><br><span class="line"><span class="keyword">while</span> (n &gt; count) &#123;</span><br><span class="line">n -= count;</span><br><span class="line">digit++;</span><br><span class="line">start *= <span class="number">10</span>;</span><br><span class="line">count = digit * start * <span class="number">9</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> num = start + (n - <span class="number">1</span>) / digit; <span class="comment">//数据</span></span><br><span class="line"><span class="built_in">string</span> temp = to_string(num);   <span class="comment">//具体定位(n - 1) % digit</span></span><br><span class="line"><span class="keyword">return</span> temp[(n - <span class="number">1</span>) % digit] - <span class="string">'0'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="45-把数组排成最小的数"><a href="#45-把数组排成最小的数" class="headerlink" title="45.把数组排成最小的数"></a>45.把数组排成最小的数</h3><ul><li><blockquote><p>输入一个非负整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。</p></blockquote></li><li><blockquote><p>输入：</p></blockquote></li><li><p>输入: [10,2]</p></li><li><p>输出: “102”</p></li><li><p>输入: [3,30,34,5,9]</p></li><li><p>输出: “3033459”</p></li><li><blockquote><p>方法：</p></blockquote></li></ul><ol><li>利用sort排序</li><li>自定义compare比较函数</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">minNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; strs;</span><br><span class="line"><span class="built_in">string</span> res;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> num : nums)</span><br><span class="line">strs.push_back(to_string(num));</span><br><span class="line"></span><br><span class="line">sort(strs.<span class="built_in">begin</span>(), strs.<span class="built_in">end</span>(), compare);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> str : strs)</span><br><span class="line">res += str;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;a, <span class="keyword">const</span> <span class="built_in">string</span> &amp;b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> a + b &lt; b + a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="46-把数字翻译成字符串"><a href="#46-把数字翻译成字符串" class="headerlink" title="46.把数字翻译成字符串"></a>46.把数字翻译成字符串</h3><ul><li><blockquote><p>给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。</p></blockquote></li></ul><ul><li><blockquote><p>输入：</p></blockquote></li><li><p>输入: 12258</p></li><li><p>输出: 5</p></li><li><p>解释: 12258有5种不同的翻译，分别是”bccfi”, “bwfi”, “bczi”, “mcfi”和”mzi”</p></li><li><blockquote><p>方法：</p></blockquote></li></ul><ol><li>substr(i,len)/截取字符串</li><li>找规律</li><li>dp动态方程 dp[i] = dp[i - 1] / dp[i] = dp[i - 1] + p[i - 2];</li><li>‘10’ &lt;= temp &lt;= ‘25’:为什么是’10’，因为00：0、0，10：10和1、0.考虑拆分</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">translateNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line"><span class="built_in">string</span> t = to_string(num);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n = t.<span class="built_in">size</span>();</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">dp[i] = dp[i - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">auto</span> temp = t.substr(i - <span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">if</span> (temp &gt;= <span class="string">"10"</span>  &amp;&amp; temp &lt;= <span class="string">"25"</span>) &#123;</span><br><span class="line">dp[i] += dp[i - <span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="47-礼物的最大价值"><a href="#47-礼物的最大价值" class="headerlink" title="47.礼物的最大价值"></a>47.礼物的最大价值</h3><ul><li><blockquote><p>在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？</p></blockquote></li></ul><ul><li><blockquote><p>输入：<br>输入: </p></blockquote></li><li><p>[</p></li><li><p>[1,3,1],</p></li><li><p>[1,5,1],</p></li><li><p>[4,2,1]</p></li><li><p>]</p></li><li><p>输出: 12</p></li><li><p>解释: 路径 1→3→5→2→1 可以拿到最多价值的礼物</p></li><li><blockquote><p>方法：</p></blockquote></li></ul><ol><li>初始化</li><li>dp动态方程</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxValue</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line"><span class="comment">//dp[i][j]=max(dp[i-1][j],dp[i][j-1])</span></span><br><span class="line"><span class="keyword">int</span> n = grid.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">int</span> m = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;dp(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(m, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] + grid[i][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">dp[<span class="number">0</span>][i] = dp[<span class="number">0</span>][i - <span class="number">1</span>] + grid[<span class="number">0</span>][i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; m; j++) &#123;</span><br><span class="line">dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]) + grid[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[n - <span class="number">1</span>][m - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      <categories>
          
          <category> 剑指Offer </category>
          
          <category> 26 - 47 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>剑指Offer68 / # 01 - 25</title>
      <link href="/2020/07/20/jianzhioffer1/"/>
      <url>/2020/07/20/jianzhioffer1/</url>
      
        <content type="html"><![CDATA[<h1 id="01-25"><a href="#01-25" class="headerlink" title="01 - 25"></a>01 - 25</h1><hr><h3 id="3-数组中重复的数字"><a href="#3-数组中重复的数字" class="headerlink" title="3.数组中重复的数字"></a>3.数组中重复的数字</h3><ul><li><blockquote><p>在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。</p></blockquote></li><li><blockquote><p>输入：<br>[2, 3, 1, 0, 2, 5, 3]<br>输出：2 或 3 </p></blockquote></li><li><blockquote><p>方法：</p></blockquote></li></ul><ol><li>哈希表</li><li>sort后，进行查找</li><li>元素交换到其下标对应位置（最优解）</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findRepeatNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line"><span class="comment">//对时间和空间的要求</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1.哈希表  空间On，时间0n</span></span><br><span class="line"><span class="comment">// int len = nums.size();</span></span><br><span class="line"><span class="comment">// if(len&lt;=1)return 0;</span></span><br><span class="line"><span class="comment">// unordered_map&lt;int,int&gt;arr;</span></span><br><span class="line"><span class="comment">// for(int i = 0;i&lt;len;i++)&#123;</span></span><br><span class="line"><span class="comment">//     if(++arr[nums[i]] &gt; 1)&#123;</span></span><br><span class="line"><span class="comment">//         return nums[i];</span></span><br><span class="line"><span class="comment">//     &#125;    </span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// return 0;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.空间对元素进行排序，然后相邻元素是否重复 空间O（1），时间0（n*logn）</span></span><br><span class="line"><span class="comment">//sort(nums.begin(),nums.end());</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3.空间O（1），时间0（n）/ 把元素换到对应的下标</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (nums[i] != i) &#123;</span><br><span class="line"><span class="keyword">if</span> (nums[i] == nums[nums[i]])</span><br><span class="line"><span class="keyword">return</span> nums[i];</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">int</span> temp = nums[i];</span><br><span class="line">nums[i] = nums[temp];</span><br><span class="line">nums[temp] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="4-二维数组中的查找"><a href="#4-二维数组中的查找" class="headerlink" title="4.二维数组中的查找"></a>4.二维数组中的查找</h3><ul><li><blockquote><p>在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p></blockquote></li><li><blockquote><p>输入：</p></blockquote></li><li><p>[</p></li><li><p>[1,   4,  7, 11, 15],</p></li><li><p>[2,   5,  8, 12, 19],</p></li><li><p>[3,   6,  9, 16, 22],</p></li><li><p>[10, 13, 14, 17, 24],</p></li><li><p>[18, 21, 23, 26, 30]</p></li><li><p>]</p></li><li><p>给定 target = 5，返回 true。</p></li><li><p>给定 target = 20，返回 false。</p></li></ul><ul><li><blockquote><p>方法：</p></blockquote></li><li>特征：矩阵，从左至右，从上至下依次递增</li><li>使用：线性查找，从有右上角开始查询</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">findNumberIn2DArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (matrix.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="comment">//线性查找</span></span><br><span class="line"><span class="comment">//从右上角开始走，往左变小，往下变大</span></span><br><span class="line"><span class="keyword">int</span> m = matrix.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">int</span> n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">int</span> row = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> col = n - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (row &lt; m &amp;&amp; col &gt;= <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (matrix[row][col] == target)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (matrix[row][col] &gt; target)</span><br><span class="line">col--;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">row++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="5-替换空格"><a href="#5-替换空格" class="headerlink" title="5.替换空格"></a>5.替换空格</h3><ul><li><blockquote><p>请实现一个函数，把字符串 s 中的每个空格替换成”%20”。</p></blockquote></li><li><blockquote><p>输入：</p></blockquote></li></ul><p>输入：s = “We are happy.”</p><p>输出：”We%20are%20happy.”</p><ul><li><blockquote><p>方法：</p></blockquote></li></ul><ol><li>新的string，遍历后增加替换</li><li>string的成员函数replace，A.replace(i_开始的下标 , len_长度 , “替换的字符”)</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">replaceSpace</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line"><span class="comment">//需要而外开销</span></span><br><span class="line"><span class="comment">// string ans;</span></span><br><span class="line"><span class="comment">// for(int i = 0; i&lt;s.size(); i++) &#123;</span></span><br><span class="line"><span class="comment">//     if(s[i] == ' ') </span></span><br><span class="line"><span class="comment">//         ans += "%20" ;</span></span><br><span class="line"><span class="comment">//     else    </span></span><br><span class="line"><span class="comment">//         ans += s[i];</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// return ans;</span></span><br><span class="line"><span class="comment">//不需要而外开销</span></span><br><span class="line"><span class="keyword">if</span> (s.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> s;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (s[i] == <span class="string">' '</span>)</span><br><span class="line">s.replace(i, <span class="number">1</span>, <span class="string">"%20"</span>);<span class="comment">//s.replace(开始下标，结束下标，替换元素)</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="6-从头到尾打印链表"><a href="#6-从头到尾打印链表" class="headerlink" title="6.从头到尾打印链表"></a>6.从头到尾打印链表</h3><ul><li><blockquote><p>输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。</p></blockquote></li><li><blockquote><p>输入：</p></blockquote></li><li><p>输入：head = [1,3,2]</p></li><li><p>输出：[2,3,1]</p></li><li><blockquote><p>方法：</p></blockquote></li></ul><ol><li>利用deque</li><li>利用vector（倒置初始化）/ reserve</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">reversePrint</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line"><span class="comment">// deque&lt;int&gt; deq;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  while(head!=NULL)&#123;</span></span><br><span class="line"><span class="comment">//      deq.push_front(head-&gt;val);</span></span><br><span class="line"><span class="comment">//      head = head-&gt;next;</span></span><br><span class="line"><span class="comment">//  &#125;</span></span><br><span class="line"><span class="comment">// vector&lt;int&gt;arr(deq.begin(),deq.end());</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; deq;</span><br><span class="line"><span class="keyword">while</span> (head != <span class="literal">NULL</span>) &#123;</span><br><span class="line">deq.push_back(head-&gt;val);</span><br><span class="line">head = head-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;arr(deq.rbegin(), deq.rend());</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="7-重建二叉树"><a href="#7-重建二叉树" class="headerlink" title="7.    重建二叉树"></a>7.    重建二叉树</h3><ul><li><blockquote><p>输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</p></blockquote></li><li><blockquote><p>输入：</p></blockquote></li><li><p>前序遍历 preorder = [3,9,20,15,7]</p></li><li><p>中序遍历 inorder = [9,3,15,20,7]</p></li><li><blockquote><p>方法：</p></blockquote></li><li><p>反复利用数组的下标初始化</p></li><li><p>先序——定根</p></li><li><p>中序——定区间</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> build(preorder, inorder, <span class="number">0</span>, <span class="number">0</span>, preorder.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">&#125;                          <span class="comment">//前序数组、中序数组、前序根节点位置、中序划分区间、中序划分区间</span></span><br><span class="line"><span class="function">TreeNode* <span class="title">build</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder, <span class="keyword">int</span> root, <span class="keyword">int</span> start, <span class="keyword">int</span> <span class="built_in">end</span>)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (start &gt; <span class="built_in">end</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">//先序定根</span></span><br><span class="line">TreeNode* tree = <span class="keyword">new</span> TreeNode(preorder[root]);</span><br><span class="line"></span><br><span class="line">   <span class="comment">//中序定两侧子树</span></span><br><span class="line"><span class="comment">//定位根节点在中序的位置</span></span><br><span class="line"><span class="keyword">int</span> i = start;</span><br><span class="line"><span class="keyword">while</span> (i &lt; <span class="built_in">end</span> &amp;&amp;preorder[root] != inorder[i])</span><br><span class="line">i++;</span><br><span class="line"><span class="comment">//根据前序—根    //根据中序—区间</span></span><br><span class="line">tree-&gt;left = build(preorder, inorder, root + <span class="number">1</span>, start, i - <span class="number">1</span>);</span><br><span class="line">tree-&gt;right = build(preorder, inorder, root + <span class="number">1</span> + i - start, i + <span class="number">1</span>,  <span class="built_in">end</span>);</span><br><span class="line"><span class="keyword">return</span> tree;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="9-用两个栈实现队列"><a href="#9-用两个栈实现队列" class="headerlink" title="9.用两个栈实现队列"></a>9.用两个栈实现队列</h3><ul><li><blockquote><p>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )</p></blockquote></li><li><blockquote><p>输入：略</p></blockquote></li></ul><ul><li><blockquote><p>方法：</p></blockquote></li></ul><ol><li>利用两个栈</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt;s1;</span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt;s2;</span><br><span class="line"><span class="comment">//利用两个栈，加的时候，先将s1的放入s2, 然会加s1，s2的再回来</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">appendTail</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (!s1.empty()) &#123;</span><br><span class="line"><span class="keyword">int</span> temp = s1.top();</span><br><span class="line">s2.push(temp);</span><br><span class="line">s1.pop();</span><br><span class="line">&#125;</span><br><span class="line">s1.push(value);</span><br><span class="line"><span class="keyword">while</span> (!s2.empty()) &#123;</span><br><span class="line"><span class="keyword">int</span> temp = s2.top();</span><br><span class="line">s1.push(temp);</span><br><span class="line">s2.pop();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">deleteHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (s1.empty())</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> temp = s1.top();</span><br><span class="line">s1.pop();</span><br><span class="line"><span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="10-1-斐波那契数列"><a href="#10-1-斐波那契数列" class="headerlink" title="10-1.斐波那契数列"></a>10-1.斐波那契数列</h3><ul><li><blockquote><p>写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项。斐波那契数列的定义如下：</p></blockquote></li></ul><p>F(0) = 0,   F(1) = 1</p><p>F(N) = F(N - 1) + F(N - 2), 其中 N &gt; 1.</p><ul><li><blockquote><p>输入：</p></blockquote></li></ul><p>输入：n = 2<br>输出：1</p><p>输入：n = 5<br>输出：5</p><ul><li><blockquote><p>方法：</p></blockquote></li></ul><ol><li>dp方程</li><li>a = a + b、b = a - b</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="comment">//第一种</span></span><br><span class="line"><span class="comment">// if(n==0)return 0;                </span></span><br><span class="line"><span class="comment">// if(n&lt;=2)return 1;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// vector&lt;int&gt;dp(n+1,0);</span></span><br><span class="line"><span class="comment">// dp[0] = 0;</span></span><br><span class="line"><span class="comment">// dp[1] = 1;</span></span><br><span class="line"><span class="comment">// for(int i =2;i&lt;n+1;i++)&#123;</span></span><br><span class="line"><span class="comment">//     dp[i] = (dp[i-1]+dp[i-2])%1000000007;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// return dp[n];</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第二种</span></span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (n &lt;= <span class="number">2</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">a = a + b;</span><br><span class="line">b = a - b;<span class="comment">//b存储前一个数的值</span></span><br><span class="line">a %= <span class="number">1000000007</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="10-2-青蛙跳台阶问题"><a href="#10-2-青蛙跳台阶问题" class="headerlink" title="10-2 .青蛙跳台阶问题"></a>10-2 .青蛙跳台阶问题</h3><ul><li><blockquote><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。</p></blockquote></li></ul><p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p><ul><li><blockquote><p>同上</p></blockquote></li></ul><hr><h3 id="11-旋转数组的最小数字"><a href="#11-旋转数组的最小数字" class="headerlink" title="11.    旋转数组的最小数字"></a>11.    旋转数组的最小数字</h3><ul><li><blockquote><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。  </p></blockquote></li></ul><ul><li><blockquote><p>输入：<br>输入：[3,4,5,1,2]<br>输出：1</p></blockquote></li></ul><p>输入：[2,2,2,0,1]<br>输出：0</p><ul><li><blockquote><p>解：就是找到最小的那个数，就是导致数组旋转</p></blockquote></li><li><blockquote><p>方法：</p></blockquote></li></ul><ol><li>二分法</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; numbers)</span> </span>&#123;</span><br><span class="line"><span class="comment">//二分查找</span></span><br><span class="line"><span class="keyword">if</span> (numbers.<span class="built_in">size</span>() == <span class="number">1</span>)<span class="keyword">return</span> numbers[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">int</span> L = <span class="number">0</span>, R = numbers.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (L &lt; R) &#123;</span><br><span class="line"><span class="comment">//寻找最小的数在哪个区间，再加以考虑</span></span><br><span class="line"><span class="keyword">int</span> mid = (L + R) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (numbers[mid] &lt; numbers[R]) &#123;  </span><br><span class="line">R = mid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (numbers[mid] &gt; numbers[R]) &#123;</span><br><span class="line">L = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">R--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> numbers[L];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="12-矩阵中的路径"><a href="#12-矩阵中的路径" class="headerlink" title="12.矩阵中的路径"></a>12.矩阵中的路径</h3><ul><li><blockquote><p>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。例如，在下面的3×4的矩阵中包含一条字符串“bfce”的路径（路径中的字母用加粗标出）。</p></blockquote></li></ul><ul><li><blockquote><p>输入：</p></blockquote></li><li>[[“a”,<strong>“b”</strong>,”c”,”e”],</li><li>[“s”,<strong>“f”</strong>,<strong>“c”</strong>,”s”],</li><li>[“a”,”d”,<strong>“e”</strong>,”e”]]</li><li>“bfce” ，true</li></ul><ul><li><blockquote><p>方法：</p></blockquote></li><li>遍历数组</li><li>回溯，辅助数组vis，dfs</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">exist</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="built_in">string</span> <span class="keyword">word</span>)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> len = board.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">if</span> (len == <span class="number">0</span> || board[<span class="number">0</span>].<span class="built_in">size</span>() == <span class="number">0</span> || <span class="keyword">word</span>.empty())<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt;vis(len, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(board[<span class="number">0</span>].<span class="built_in">size</span>(), <span class="literal">true</span>));<span class="comment">//辅助数组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; board[<span class="number">0</span>].<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (board[i][j] == <span class="keyword">word</span>[<span class="number">0</span>]) &#123;</span><br><span class="line"><span class="keyword">if</span> (dfs(i, j, board, <span class="keyword">word</span>, <span class="number">0</span>, vis))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="built_in">string</span> <span class="keyword">word</span>, <span class="keyword">int</span> length, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt;&amp;vis)</span> </span>&#123;</span><br><span class="line"><span class="comment">//回溯的返回条件</span></span><br><span class="line"><span class="keyword">if</span> (length == <span class="keyword">word</span>.<span class="built_in">size</span>())</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="comment">//排除不合法</span></span><br><span class="line"><span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= board.<span class="built_in">size</span>() || j &lt; <span class="number">0</span> || j &gt;= board[<span class="number">0</span>].<span class="built_in">size</span>() || vis[i][j] == <span class="literal">false</span> || board[i][j] != <span class="keyword">word</span>[length])</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//做出选择</span></span><br><span class="line">vis[i][j] = <span class="literal">false</span>;</span><br><span class="line"><span class="comment">//回溯函数，有真则真</span></span><br><span class="line"><span class="keyword">bool</span> res = dfs(i, j + <span class="number">1</span>, board, <span class="keyword">word</span>, length + <span class="number">1</span>, vis) || dfs(i, j - <span class="number">1</span>, board, <span class="keyword">word</span>, length + <span class="number">1</span>, vis) ||</span><br><span class="line">dfs(i + <span class="number">1</span>, j, board, <span class="keyword">word</span>, length + <span class="number">1</span>, vis) || dfs(i - <span class="number">1</span>, j, board, <span class="keyword">word</span>, length + <span class="number">1</span>, vis);</span><br><span class="line"><span class="comment">//撤销选择</span></span><br><span class="line">vis[i][j] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="13-机器人的运动范围"><a href="#13-机器人的运动范围" class="headerlink" title="13.    机器人的运动范围"></a>13.    机器人的运动范围</h3><ul><li><blockquote><p>地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？</p></blockquote></li></ul><ul><li><blockquote><p>输入：<br>输入：m = 2, n = 3, k = 1<br>输出：3</p></blockquote></li></ul><p>输入：m = 3, n = 1, k = 0<br>输出：1</p><ul><li><blockquote><p>方法：</p></blockquote></li></ul><ol><li>典型的BFS，但是只有两个方向需要注意</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (x) &#123;</span><br><span class="line">res += x % <span class="number">10</span>;</span><br><span class="line">x /= <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!k) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;vis(m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line">vis[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">queue</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; Q;</span><br><span class="line">Q.push(make_pair(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dx[<span class="number">2</span>] = &#123; <span class="number">0</span>, <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> dy[<span class="number">2</span>] = &#123; <span class="number">1</span>, <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (!Q.empty()) &#123;</span><br><span class="line"><span class="keyword">auto</span>[x, y] = Q.front();</span><br><span class="line">Q.pop();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line"><span class="keyword">int</span> tx = dx[i] + x;</span><br><span class="line"><span class="keyword">int</span> ty = dy[i] + y;</span><br><span class="line"><span class="keyword">if</span> (tx &gt;= <span class="number">0</span> &amp;&amp; tx &lt; m &amp;&amp; ty &gt;= <span class="number">0</span> &amp;&amp; ty &lt; n &amp;&amp;</span><br><span class="line"><span class="built_in">get</span>(tx) + <span class="built_in">get</span>(ty) &lt; k + <span class="number">1</span> &amp;&amp; vis[tx][ty] == <span class="number">0</span>) &#123;</span><br><span class="line">Q.push(make_pair(tx, ty));</span><br><span class="line">vis[tx][ty] = <span class="number">1</span>;</span><br><span class="line">ans++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="14-1-剪绳子"><a href="#14-1-剪绳子" class="headerlink" title="14-1.剪绳子"></a>14-1.剪绳子</h3><ul><li><blockquote><p>给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]…k[m-1] 。请问 k[0]<em>k[1]</em>…*k[m-1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p></blockquote></li></ul><ul><li><blockquote><p>输入：<br>输入: 2<br>输出: 1<br>解释: 2 = 1 + 1, 1 × 1 = 1</p></blockquote></li></ul><p>输入: 10<br>输出: 36<br>解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36</p><ul><li><blockquote><p>解：只有绳子大于4的时候，才需要剪开可以乘积变大</p></blockquote><ul><li>1  /  1  0</li><li>2  /  1*1=1</li><li>3  /  1*2=2</li><li>4  /  2*2=4</li><li>5  /  2*3=5  //开始变化</li></ul></li><li><blockquote><p>方法：</p></blockquote></li></ul><ol><li>找规律</li><li>dp动态规划</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cuttingRope</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="comment">//1.贪心算法，找规律，拆分成3的倍数乘积是最大的</span></span><br><span class="line"><span class="comment">// if (n &lt; 4)return n - 1;</span></span><br><span class="line"><span class="comment">// int a = n / 3, b = n % 3;</span></span><br><span class="line"><span class="comment">// if (b == 0)return a = pow(3, a);</span></span><br><span class="line"><span class="comment">// if (b == 1)return a = pow(3, a-1) * 4;</span></span><br><span class="line"><span class="comment">// if (b == 2)return a = pow(3, a) * 2;</span></span><br><span class="line"><span class="comment">// return a;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.动态规划</span></span><br><span class="line"><span class="comment">//只有大于4的绳子才有分的必要 ，4分成2*2没有变化，5分成2*3可以变大</span></span><br><span class="line"><span class="keyword">if</span> (n &lt; <span class="number">4</span>)<span class="keyword">return</span> n - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">4</span>)<span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">dp[<span class="number">1</span>] = <span class="number">1</span>;<span class="comment">//绳长度为1的最大乘积</span></span><br><span class="line">dp[<span class="number">2</span>] = <span class="number">2</span>;<span class="comment">//绳长度为2的最大乘积</span></span><br><span class="line">dp[<span class="number">3</span>] = <span class="number">3</span>;<span class="comment">//绳长度为3的最大乘积</span></span><br><span class="line">dp[<span class="number">4</span>] = <span class="number">4</span>;<span class="comment">//绳长度为4的最大乘积</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">5</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> maxNum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i / <span class="number">2</span>; j++) &#123;</span><br><span class="line">maxNum = <span class="built_in">max</span>(maxNum, dp[i - j] * dp[j]);</span><br><span class="line">&#125;</span><br><span class="line">dp[i] = maxNum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="14-2-剪绳子-II"><a href="#14-2-剪绳子-II" class="headerlink" title="14-2.剪绳子 II"></a>14-2.剪绳子 II</h3><ul><li><blockquote><p>同上</p></blockquote></li></ul><hr><h3 id="15-二进制中1的个数"><a href="#15-二进制中1的个数" class="headerlink" title="15.二进制中1的个数"></a>15.二进制中1的个数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (n) &#123;</span><br><span class="line"><span class="keyword">if</span> (n &amp; <span class="number">1</span>)</span><br><span class="line">res++;</span><br><span class="line">n = n &gt;&gt; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="16-数值的整数次方"><a href="#16-数值的整数次方" class="headerlink" title="16.数值的整数次方"></a>16.数值的整数次方</h3><ul><li><blockquote><p>实现函数double Power(double base, int exponent)，求base的exponent次方。不得使用库函数，同时不需要考虑大数问题。</p></blockquote></li></ul><ul><li><blockquote><p>输入：</p></blockquote></li></ul><p>输入: 2.00000, 10<br>输出: 1024.00000</p><p>输入: 2.10000, 3<br>输出: 9.26100</p><p>输入: 2.00000, -2<br>输出: 0.25000<br>解释: 2-2 = 1/22 = 1/4 = 0.25</p><ul><li><blockquote><p>方法：</p></blockquote></li></ul><ol><li>dfs————拆分拆分 / 化繁为简</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> x;</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">1</span> / x;</span><br><span class="line"><span class="keyword">double</span> half = myPow(x, n / <span class="number">2</span>);</span><br><span class="line"><span class="keyword">double</span> add = myPow(x, n % <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> half * half*add;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="17-打印从1到最大的n位数"><a href="#17-打印从1到最大的n位数" class="headerlink" title="17.打印从1到最大的n位数"></a>17.打印从1到最大的n位数</h3><ul><li><blockquote><p>输入数字 n，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。</p></blockquote></li><li><blockquote><p>输入：<br>输入: n = 1<br>输出: [1,2,3,4,5,6,7,8,9]</p></blockquote></li><li><blockquote><p>主要考大数问题，用字符串模拟加法 到了这，这题变得毫无意义</p></blockquote></li><li><blockquote><p>方法：</p></blockquote><ul><li>字符串解决大数问题 </li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">printNumbers</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n &lt;= <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">number</span><span class="params">(n, <span class="string">'0'</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">9</span>; i++) &#123;</span><br><span class="line">number[<span class="number">0</span>] = i + <span class="string">'0'</span>;</span><br><span class="line">permutionNum(number, n, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">permutionNum</span><span class="params">(<span class="built_in">string</span> &amp;number, <span class="keyword">int</span> length, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (index == length) &#123;</span><br><span class="line">saveNum(number);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">number[index] = <span class="string">'0'</span> + i;</span><br><span class="line">permutionNum(number, length, index + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">saveNum</span><span class="params">(<span class="built_in">string</span> number)</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">tempStr</span><span class="params">(number.<span class="built_in">size</span>(), <span class="string">'0'</span>)</span></span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; stoi(number) &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"><span class="keyword">if</span> (number != tempStr)</span><br><span class="line">res.push_back(stoi(number));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bigAdd</span><span class="params">(<span class="built_in">string</span> num1, <span class="built_in">string</span> num2, <span class="built_in">string</span> &amp;res)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> len1 = num1.length() - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> len2 = num2.length() - <span class="number">1</span>;</span><br><span class="line">res = <span class="string">""</span>;</span><br><span class="line"><span class="keyword">while</span> (len1 &gt;= <span class="number">0</span> || len2 &gt;= <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">int</span> a = len1 &gt;= <span class="number">0</span> ? num1[len1--] - <span class="string">'0'</span> : <span class="number">0</span>;<span class="comment">//从最后一位开始相加，不够的补0</span></span><br><span class="line"><span class="keyword">int</span> b = len2 &gt;= <span class="number">0</span> ? num2[len2--] - <span class="string">'0'</span> : <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> tmp = a + b + carry;</span><br><span class="line">carry = tmp / <span class="number">10</span>;<span class="comment">//进位</span></span><br><span class="line">res = to_string(<span class="keyword">long</span> <span class="keyword">long</span>(tmp % <span class="number">10</span>)) + res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (carry) &#123;<span class="comment">//如果最高位有进位，加上</span></span><br><span class="line">res = to_string(<span class="keyword">long</span> <span class="keyword">long</span>(carry)) + res;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="18-删除链表的节点"><a href="#18-删除链表的节点" class="headerlink" title="18.删除链表的节点"></a>18.删除链表的节点</h3><ul><li><blockquote><p>给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。</p></blockquote></li></ul><p>返回删除后的链表的头节点。</p><ul><li><blockquote><p>输入：</p></blockquote></li><li><p>输入: head = [4,5,1,9], val = 5</p></li><li><p>输出: [4,1,9]</p></li><li><p>解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.</p></li><li><p>输入: head = [4,5,1,9], val = 1</p></li><li><p>输出: [4,5,9]</p></li><li><p>解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9.</p></li><li><blockquote><p>方法：</p></blockquote></li></ul><ol><li><p>原题剑指1：给定头节点和要删除的节点（快速删除）</p><ul><li>删除要删除节点的下一个节点，将下一个节点的值赋给前一个结点</li><li>当最后一个节点为空，还是需要从头遍历</li></ul></li><li><p>原题剑指2：删除链表中的重复节点</p><ul><li>使用两个辅助指针实现</li></ul></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">deleteNode</span><span class="params">(ListNode* head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (head == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line"><span class="keyword">if</span> (head-&gt;val == val)</span><br><span class="line"><span class="keyword">return</span> head-&gt;next;</span><br><span class="line"></span><br><span class="line"><span class="comment">//保存头节点</span></span><br><span class="line">ListNode* pre = head;</span><br><span class="line"><span class="comment">//开始</span></span><br><span class="line">ListNode* temp = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">while</span> (head-&gt;next &amp;&amp; head) &#123;</span><br><span class="line">temp = head;</span><br><span class="line">head = head-&gt;next;</span><br><span class="line"><span class="keyword">if</span> (head-&gt;val == val) &#123;</span><br><span class="line">temp-&gt;next = head-&gt;next;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="19-正则表达式匹配"><a href="#19-正则表达式匹配" class="headerlink" title="19.  正则表达式匹配"></a>19.  正则表达式匹配</h3><ul><li><blockquote><p>请实现一个函数用来匹配包含’. ‘和’<em>‘的正则表达式。模式中的字符’.’表示任意一个字符，而’</em>‘表示它前面的字符可以出现任意次（含0次）。在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”ab<em>ac</em>a”匹配，但与”aa.a”和”ab*a”均不匹配。</p></blockquote></li></ul><ul><li><blockquote><p>输入:</p></blockquote></li><li><p>s = “aa”</p></li><li><p>p = “a”</p></li><li><p>输出: false</p></li><li><p>解释: “a” 无法匹配 “aa” 整个字符串。</p></li><li><blockquote><p>输入:</p></blockquote></li><li><p>s = “aa”</p></li><li><p>p = “a*”</p></li><li><p>输出: true</p></li><li><p>解释: 因为 ‘*’ 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 ‘a’。因此，字符串 “aa” 可被视为 ‘a’ 重复了一次。</p></li></ul><ul><li><blockquote><p>方法：</p></blockquote></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (p.empty()) <span class="keyword">return</span> s.empty();</span><br><span class="line"><span class="keyword">if</span> (p[<span class="number">1</span>] == <span class="string">'*'</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> isMatch(s, p.substr(<span class="number">2</span>)) || (!s.empty() &amp;&amp; (s[<span class="number">0</span>] == p[<span class="number">0</span>] || p[<span class="number">0</span>] == <span class="string">'.'</span>))</span><br><span class="line">&amp;&amp; isMatch(s.substr(<span class="number">1</span>), p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> !s.empty() &amp;&amp; (s[<span class="number">0</span>] == p[<span class="number">0</span>] || p[<span class="number">0</span>] == <span class="string">'.'</span>) &amp;&amp; (isMatch(s.substr(<span class="number">1</span>), p.substr(<span class="number">1</span>)));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="20-表示数值的字符串"><a href="#20-表示数值的字符串" class="headerlink" title="20.表示数值的字符串"></a>20.表示数值的字符串</h3><ul><li><blockquote></blockquote></li><li><blockquote><p>输入：</p></blockquote></li></ul><ul><li><blockquote><p>方法：</p></blockquote></li></ul><ol><li>哈希表</li><li>sort后，进行查找</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h3 id="21-调整数组顺序使奇数位于偶数前面"><a href="#21-调整数组顺序使奇数位于偶数前面" class="headerlink" title="21.调整数组顺序使奇数位于偶数前面"></a>21.调整数组顺序使奇数位于偶数前面</h3><ul><li><blockquote><p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。</p></blockquote></li><li><blockquote><p>输入：</p></blockquote></li><li><p>输入：nums = [1,2,3,4]</p></li><li><p>输出：[1,3,2,4] </p></li><li><p>注：[3,1,2,4] 也是正确的答案之一。</p></li></ul><ul><li><blockquote><p>方法：</p></blockquote></li></ul><ol><li>一次快排</li><li>快排需要注意：while右边先写</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">exchange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line"><span class="comment">//一次快速排序</span></span><br><span class="line"><span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> L = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> R = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (L != R) &#123;</span><br><span class="line"><span class="keyword">while</span> (L &lt; R &amp;&amp;nums[L] % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">L++;</span><br><span class="line"><span class="keyword">while</span> (L &lt; R &amp;&amp;nums[R] % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">R--;</span><br><span class="line"><span class="keyword">if</span> (L &lt; R) &#123;</span><br><span class="line"><span class="keyword">int</span> temp = nums[R];</span><br><span class="line">nums[R] = nums[L];</span><br><span class="line">nums[L] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="22-链表中倒数第k个节点"><a href="#22-链表中倒数第k个节点" class="headerlink" title="22.链表中倒数第k个节点"></a>22.链表中倒数第k个节点</h3><ul><li><blockquote><p>输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。例如，一个链表有6个节点，从头节点开始，它们的值依次是1、2、3、4、5、6。这个链表的倒数第3个节点是值为4的节点。</p></blockquote></li></ul><ul><li><blockquote><p>输入：</p></blockquote></li><li><p>给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 k = 2.</p></li><li><p>返回链表 4-&gt;5.</p></li><li><blockquote><p>方法：</p></blockquote></li></ul><ol><li>vector保存所有结点</li><li>快慢指针，快指针先走K，然后慢指针开始走，sum - k = 要走的步数。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">getKthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">ListNode* fast = head;</span><br><span class="line">ListNode* slow = head;</span><br><span class="line"><span class="keyword">while</span> (k &amp;&amp; fast) &#123;</span><br><span class="line">fast = fast-&gt;next;</span><br><span class="line">k--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (fast) &#123;</span><br><span class="line">fast = fast-&gt;next;</span><br><span class="line">slow = slow-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="24-反转链表"><a href="#24-反转链表" class="headerlink" title="24.反转链表"></a>24.反转链表</h3><ul><li><blockquote><p>1.递归遍历到最后一个节点开始反转</p></blockquote></li><li><blockquote><p>2.辅助指针逐步反转</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">ListNode* temp = head-&gt;next;</span><br><span class="line">ListNode* newH = reverseList(temp);</span><br><span class="line"></span><br><span class="line">temp-&gt;next = head;</span><br><span class="line">head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> newH;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ListNode* reverseList(ListNode* head) &#123;</span></span><br><span class="line"><span class="comment">//     if(head==NULL || head-&gt;next==NULL)</span></span><br><span class="line"><span class="comment">//         return head;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     ListNode* newH =NULL;</span></span><br><span class="line"><span class="comment">//     ListNode* cur =head;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     while(cur)&#123;</span></span><br><span class="line"><span class="comment">//         ListNode* temp= cur-&gt;next;</span></span><br><span class="line"><span class="comment">//         cur-&gt;next = newH;</span></span><br><span class="line"><span class="comment">//         newH = cur;</span></span><br><span class="line"><span class="comment">//         cur = temp;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">//     return newH;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="25-合并两个排序的链表"><a href="#25-合并两个排序的链表" class="headerlink" title="25.合并两个排序的链表"></a>25.合并两个排序的链表</h3><ul><li><blockquote><p>输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。</p></blockquote></li><li><blockquote><p>输入：</p></blockquote></li><li><p>输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4</p></li><li><p>输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</p></li><li><blockquote><p>方法：</p></blockquote></li></ul><ol><li>类似归并排序，归的时候，逐步组成一个有序集合</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">ListNode* pre = <span class="literal">NULL</span>;</span><br><span class="line">ListNode* head = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">if</span> (l1 == <span class="literal">NULL</span>)<span class="keyword">return</span> l2;</span><br><span class="line"><span class="keyword">if</span> (l2 == <span class="literal">NULL</span>)<span class="keyword">return</span> l1;</span><br><span class="line"><span class="keyword">if</span> (l1-&gt;val &lt;= l2-&gt;val) &#123;</span><br><span class="line">pre = l1;</span><br><span class="line">l1 = l1-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">pre = l2;</span><br><span class="line">l2 = l2-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">head = pre;</span><br><span class="line"><span class="keyword">while</span> (l1&amp;&amp;l2) &#123;</span><br><span class="line"><span class="keyword">if</span> (l1-&gt;val &lt;= l2-&gt;val) &#123;</span><br><span class="line">pre-&gt;next = l1;</span><br><span class="line">pre = pre-&gt;next;</span><br><span class="line">l1 = l1-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">pre-&gt;next = l2;</span><br><span class="line">pre = pre-&gt;next;</span><br><span class="line">l2 = l2-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (l1)</span><br><span class="line">pre-&gt;next = l1;</span><br><span class="line"><span class="keyword">if</span> (l2)</span><br><span class="line">pre-&gt;next = l2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      <categories>
          
          <category> 剑指Offer </category>
          
          <category> 01 - 25 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>剑指Offer68 / 目录</title>
      <link href="/2020/07/20/jianzhioffer/"/>
      <url>/2020/07/20/jianzhioffer/</url>
      
        <content type="html"><![CDATA[<p><font size=5> 树</font> </p><ul><li>7.<strong>重建二叉树</strong></li><li>26.<strong>判断是不是树的子结构</strong></li><li>27.<strong>二叉树的镜像</strong></li><li>28.<strong>对称的二叉树</strong></li><li>32-1.<strong>从上到下打印二叉树</strong>—层序遍历</li><li>33.<strong>二叉搜索树的后序遍历序列</strong></li><li>34.<strong>二叉树中和为某一值的路径</strong>（回溯）</li><li>37.<strong>序列化二叉树</strong></li><li>54.<strong>二叉搜索树的第k大节点</strong>(利用中序遍历)</li><li>55-1.<strong>二叉树的深度</strong>（最大高度）</li><li>55-2.<strong>判断是否平衡二叉树</strong>（仅高度）</li><li>55-拓展.<strong>二叉树路径和是否为Sum</strong></li><li>55-拓展2.<strong>求二叉树的最大直径</strong></li><li>68-1.<strong>二叉搜索树的最近公共祖先</strong></li><li>68-2.<strong>二叉树的最近公共祖先</strong></li></ul><p><font size=5> 链表</font> </p><ul><li>22.<strong>链表中倒数第k个节点</strong>（快先走）</li><li>35.<strong>复杂链表的复制</strong>（深拷贝）</li><li>52.<strong>两个链表的第一个公共节点</strong></li></ul><p><font size=5> 二分法</font> </p><ul><li>11.旋转数组的最小数字</li><li>53-1.在排序数组中查找数字出现次数</li><li>53-2.0～n-1中缺失的数字</li></ul><p><font size=5>滑动窗口</font> </p><ul><li>48.最长不含重复字符的子字符串</li><li>57-1.和为s的两个数字</li><li>57-2.和为s的连续正数序列</li></ul><p><font size=5> dfs深度遍历</font> </p><ul><li>12.矩阵中的路径，满足 bfce 的路径</li><li>16.数值的整数次方pow</li></ul><p><font size=5> bfs广度遍历</font> </p><ul><li>13.机器人的运动范围</li></ul><p><font size=5> DP动态规划</font> </p><ul><li>10.斐波那契数列 / 青蛙跳</li><li>42.连续子数组的最大和（经典）</li><li>46.把数字翻译成字符串（规律+DP / 0对应a）</li><li>47.礼物的最大价值</li><li>60.n个骰子的点数的概率</li></ul><p><font size=5> STL容器</font> </p><ul><li>6.从头到尾打印链表（deque）</li><li>9.用两个栈实现队列（stack）</li><li>30.包含min函数的栈（stack）</li><li>31.栈的压入、弹出序列（stack）</li><li>41.数据流中的中位数（优先队列priority_queue/大小顶堆）</li><li>59-1.<strong>滑动窗口的最大值</strong>（deque）</li><li>59-2.<strong>队列的最大值</strong>（deque）</li></ul><p><font size=5> 回溯法</font> </p><ul><li>12.矩阵中的路径，满足string = bfce的路 </li><li>34.二叉树中和为某一值的路径</li><li>38.字符串排列的所以可能性（难点在于剪枝）</li></ul><p><font size=5> 位运算</font> </p><ul><li>15.二进制中1的个数</li><li>56-1.数组中数字出现的次数(异或)</li></ul><p><font size=5> 快慢指针</font> </p><ul><li>22.链表中倒数第k个节点 / 快先走</li></ul><p><font size=5> 归并算法</font> </p><ul><li>51.数组中的逆序对</li></ul><hr><h1 id="01-25"><a href="#01-25" class="headerlink" title="01 - 25"></a><a href="https://zuizichuan.cn/2020/07/20/jianzhioffer1/">01 - 25</a></h1><h3 id="3-数组中重复的数字"><a href="#3-数组中重复的数字" class="headerlink" title="3.数组中重复的数字"></a><a href="https://zuizichuan.cn/2020/07/20/jianzhioffer1/#3-%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97">3.数组中重复的数字</a></h3><ul><li><blockquote><p>题目：数组长度n，元素大小0—n-1，查找重复元素</p></blockquote></li><li><blockquote><p>交换对应元素至下标（最优解）</p></blockquote></li></ul><h3 id="4-二维顺序数组的查找"><a href="#4-二维顺序数组的查找" class="headerlink" title="4.二维顺序数组的查找 "></a><a href="https://zuizichuan.cn/2020/07/20/jianzhioffer1/#4-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE">4.二维顺序数组的查找 </a></h3><ul><li><blockquote><p>题目：行有序、列有序，查找数组中元素</p></blockquote></li><li><blockquote><p>右上角开始查找，类似二分查找row++，col–。</p></blockquote></li></ul><h3 id="5-替换空格"><a href="#5-替换空格" class="headerlink" title="5.替换空格 "></a><a href="https://zuizichuan.cn/2020/07/20/jianzhioffer1/#5-%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC">5.替换空格 </a></h3><ul><li><blockquote><p>题目：s = “We are happy.”——》”We%20are%20happy.”</p></blockquote></li><li><blockquote><p>s.replace(i, 1,”%20”);</p></blockquote></li><li><blockquote><p>replace(start, len , string change);</p></blockquote></li><li><blockquote><p>上题目只替换len=1长度元素</p></blockquote></li></ul><h3 id="6-从头到尾打印链表"><a href="#6-从头到尾打印链表" class="headerlink" title="6.从头到尾打印链表 "></a><a href="https://zuizichuan.cn/2020/07/20/jianzhioffer1/#6-%E4%BB%8E%E5%A4%B4%E5%88%B0%E5%B0%BE%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8">6.从头到尾打印链表 </a></h3><ul><li><blockquote><p>方法1.利用vector—vector<int>vis(deq.rbegin(),deq.rend())</p></blockquote></li><li><blockquote><p>方法2.利用deque </p></blockquote></li><li><blockquote><p>头：push_front() pop_front()/ 【1、2、3】尾：push_back() -pop_back()</p></blockquote></li><li><blockquote><p>双向队列经典问题：维护数组最大值：头MAX，尾进然后比较</p></blockquote></li><li><blockquote><p><a href="https://zichuan365.github.io/2020/08/10/LeetCode-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E9%97%AE%E9%A2%98/#239-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC%EF%BC%88%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E8%A6%81%E6%B1%82%EF%BC%89" target="_blank" rel="noopener">https://zichuan365.github.io/2020/08/10/LeetCode-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E9%97%AE%E9%A2%98/#239-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC%EF%BC%88%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E8%A6%81%E6%B1%82%EF%BC%89</a></p></blockquote></li></ul><h3 id="7-重建二叉树"><a href="#7-重建二叉树" class="headerlink" title="7.重建二叉树 "></a><a href="https://zuizichuan.cn/2020/07/20/jianzhioffer1/#7-%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91">7.重建二叉树 </a></h3><ul><li><blockquote><p>方法：前序定根，中序定区间</p></blockquote></li><li><blockquote><p>return build(preorder,inorder,0,   0,inorder.size()-1);</p></blockquote></li><li><blockquote><p>对应：先序数组、中序数组、root节点，begin，end;</p></blockquote></li></ul><h3 id="9-用两个栈实现队列"><a href="#9-用两个栈实现队列" class="headerlink" title="9.用两个栈实现队列 "></a><a href="https://zuizichuan.cn/2020/07/20/jianzhioffer1/#9-%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97">9.用两个栈实现队列 </a></h3><ul><li><blockquote><p>方法：利用辅助栈</p></blockquote></li><li><blockquote><p>通过一个栈来换一下手</p></blockquote></li></ul><h3 id="10-1-斐波那契数列"><a href="#10-1-斐波那契数列" class="headerlink" title="10-1.斐波那契数列"></a><a href="https://zuizichuan.cn/2020/07/20/jianzhioffer1/#10-1-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97">10-1.斐波那契数列</a></h3><ul><li><blockquote><p>方法1.dp方程</p></blockquote></li><li><blockquote><p>方法2.a = a + b；b = a - b；//b用来保存前值</p></blockquote></li></ul><h3 id="10-2-青蛙跳台阶问题"><a href="#10-2-青蛙跳台阶问题" class="headerlink" title="10-2 .青蛙跳台阶问题"></a><a href="https://zuizichuan.cn/2020/07/20/jianzhioffer1/#10-2-%E9%9D%92%E8%9B%99%E8%B7%B3%E5%8F%B0%E9%98%B6%E9%97%AE%E9%A2%98">10-2 .青蛙跳台阶问题</a></h3><ul><li><blockquote><p>方法1.dp方程</p></blockquote></li><li><blockquote><p>方法2.a = a + b；b = a - b；//b用来保存前值</p></blockquote></li></ul><h3 id="11-旋转数组的最小数字"><a href="#11-旋转数组的最小数字" class="headerlink" title="11.旋转数组的最小数字 "></a><a href="https://zuizichuan.cn/2020/07/20/jianzhioffer1/#11-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97">11.旋转数组的最小数字 </a></h3><ul><li><blockquote><p>有序数组部分颠倒，就是找到最小的那个数</p></blockquote></li><li><blockquote><p>典型的：二分查找</p></blockquote></li><li><blockquote><p>二分的关键：mid区间的取值判断</p></blockquote></li></ul><h3 id="12-矩阵中的路径BFCE"><a href="#12-矩阵中的路径BFCE" class="headerlink" title="12.矩阵中的路径BFCE "></a><a href="https://zuizichuan.cn/2020/07/20/jianzhioffer1/#12-%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84">12.矩阵中的路径BFCE </a></h3><ul><li><blockquote><p>每个节点都需要尝试，典型的回溯问题，再加上DFS深度遍历</p></blockquote></li></ul><h3 id="13-机器人的运动范围"><a href="#13-机器人的运动范围" class="headerlink" title="13.机器人的运动范围 "></a><a href="https://zuizichuan.cn/2020/07/20/jianzhioffer1/#13-%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4">13.机器人的运动范围 </a></h3><ul><li><blockquote><p>典型BFS广度遍历的题目</p></blockquote></li><li><blockquote><p>auto [x, y] = Q.front();</p></blockquote></li></ul><h3 id="14-1-剪绳子"><a href="#14-1-剪绳子" class="headerlink" title="14-1.剪绳子 "></a><a href="https://zuizichuan.cn/2020/07/20/jianzhioffer1/#14-1-%E5%89%AA%E7%BB%B3%E5%AD%90">14-1.剪绳子 </a></h3><ul><li><blockquote><p>方法1.找规律,以3划分的乘积是最大的</p></blockquote></li><li><blockquote><p>方法2.DP动态规划,dp[1] = 1;dp[2] = 2;dp[3] = 3;dp[4] = 4;</p></blockquote></li></ul><h3 id="15-二进制中1的个数"><a href="#15-二进制中1的个数" class="headerlink" title="15.二进制中1的个数"></a><a href="https://zuizichuan.cn/2020/07/20/jianzhioffer1/#15-%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0">15.二进制中1的个数</a></h3><ul><li><blockquote><p>位运算</p></blockquote></li></ul><h3 id="16-数值的整数次方"><a href="#16-数值的整数次方" class="headerlink" title="16.数值的整数次方 "></a><a href="https://zuizichuan.cn/2020/07/20/jianzhioffer1/#16-%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9">16.数值的整数次方 </a></h3><ul><li><blockquote><p>dfs——拆分拆分 / 化繁为简</p></blockquote></li></ul><h3 id="17-String的大数打印"><a href="#17-String的大数打印" class="headerlink" title="17.String的大数打印"></a><a href="https://zuizichuan.cn/2020/07/20/jianzhioffer1/#17-%E6%89%93%E5%8D%B0%E4%BB%8E1%E5%88%B0%E6%9C%80%E5%A4%A7%E7%9A%84n%E4%BD%8D%E6%95%B0">17.String的大数打印</a></h3><ul><li><blockquote><p>String大数问题，用字符串模拟数字</p></blockquote></li></ul><h3 id="18-删除链表的节点"><a href="#18-删除链表的节点" class="headerlink" title="18.删除链表的节点"></a><a href="https://zuizichuan.cn/2020/07/20/jianzhioffer1/#18-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E8%8A%82%E7%82%B9">18.删除链表的节点</a></h3><ul><li><blockquote><p>原题剑指1：给定头节点和要删除的节点（快速删除） / 删除要删除节点的下一个节点，将删除节点的值赋给前一个结点。</p></blockquote></li><li><blockquote><p>原题剑指2：删除链表中的重复节点 / 使用两个辅助指针实现</p></blockquote></li></ul><h3 id="19-正则表达式匹配（困难未做）"><a href="#19-正则表达式匹配（困难未做）" class="headerlink" title="19.正则表达式匹配（困难未做）"></a>19.正则表达式匹配（困难未做）</h3><h3 id="20-表示数值的字符串（中等未做）"><a href="#20-表示数值的字符串（中等未做）" class="headerlink" title="20.表示数值的字符串（中等未做）"></a>20.表示数值的字符串（中等未做）</h3><h3 id="21-调整数组顺序使奇数位于偶数前面"><a href="#21-调整数组顺序使奇数位于偶数前面" class="headerlink" title="21.调整数组顺序使奇数位于偶数前面"></a><a href="https://zuizichuan.cn/2020/07/20/jianzhioffer1/#21-%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2">21.调整数组顺序使奇数位于偶数前面</a></h3><ul><li><blockquote><p>一次快排、快排需要注意：while右边先写</p></blockquote></li></ul><h3 id="22-链表中倒数第k个节点"><a href="#22-链表中倒数第k个节点" class="headerlink" title="22.链表中倒数第k个节点 "></a><a href="https://zuizichuan.cn/2020/07/20/jianzhioffer1/#22-%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9">22.链表中倒数第k个节点 </a></h3><ul><li><blockquote><p>方法1.vector保存所有结点</p></blockquote></li><li><blockquote><p>方法2.快慢指针，快指针先走K，然后慢指针开始走，sum - k = 要走的步数</p></blockquote></li></ul><h3 id="24-反转链表"><a href="#24-反转链表" class="headerlink" title="24.反转链表 "></a><a href="https://zuizichuan.cn/2020/07/20/jianzhioffer1/#24-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8">24.反转链表 </a></h3><ul><li><blockquote><p>方法1.辅助指针</p></blockquote></li><li><blockquote><p>方法2.dfs递归遍历到最后一个节点开始反转</p></blockquote></li></ul><h3 id="25-合并两个排序的链表"><a href="#25-合并两个排序的链表" class="headerlink" title="25.合并两个排序的链表 "></a><a href="https://zuizichuan.cn/2020/07/20/jianzhioffer1/#25-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8">25.合并两个排序的链表 </a></h3><ul><li><blockquote><p>类似归并排序，归的时候，逐步组成一个有序集合，双指针</p></blockquote></li></ul><hr><hr><h1 id="26-47"><a href="#26-47" class="headerlink" title="26 - 47"></a><a href="https://zuizichuan.cn/2020/07/20/jianzhioffer2/">26 - 47</a></h1><h3 id="26-判断是不是树的子结构"><a href="#26-判断是不是树的子结构" class="headerlink" title="26.判断是不是树的子结构 "></a><a href="https://zuizichuan.cn/2020/07/20/jianzhioffer2/#26-%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84">26.判断是不是树的子结构 </a></h3><ul><li><blockquote><p>1.首先：每个节点都有可能是树的子结构，所以需要遍历树的左子树，右子树，所以是 ||</p></blockquote></li><li>主函数：return dfs(father,son) || isSubStructure(father-&gt;left,son) || isSubStructure(father-&gt;right,son);</li><li><blockquote><p>2.然后：当单个节点满足，是要延顺下去的每个节点满足,所以是&amp;&amp;</p></blockquote></li><li>DFS函数：return dfs(father-&gt;left,son-&gt;left) &amp;&amp; dfs(father-&gt;right,son-&gt;right);</li></ul><h3 id="27-二叉树的镜像"><a href="#27-二叉树的镜像" class="headerlink" title="27.二叉树的镜像 "></a><a href="https://zuizichuan.cn/2020/07/20/jianzhioffer2/#27-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F">27.二叉树的镜像 </a></h3><ul><li><blockquote><p>方法一DFS：直接进行节点交换，然后再次遍历左右节点</p></blockquote></li><li><blockquote><p>方法二层序遍历：利用queue</p></blockquote><ul><li>需要注意 if(tmp-&gt;left) q.push(tmp-&gt;left);</li><li>需要注意 if(tmp-&gt;right) q.push(tmp-&gt;right);</li></ul></li></ul><h3 id="28-对称的二叉树"><a href="#28-对称的二叉树" class="headerlink" title="28.对称的二叉树 "></a><a href="https://zuizichuan.cn/2020/07/20/jianzhioffer2/#28-%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91">28.对称的二叉树 </a></h3><ul><li><blockquote><p>首先：空树为真，左等于右为真</p></blockquote></li><li><blockquote><p>然后：</p></blockquote><ul><li>两空树：真，一空一不空树：假，值不相等：假</li><li>需要判断的是<strong>左子树的左</strong>和<strong>右子树的右</strong>是否相等</li><li>需要判断的是<strong>左子树的右</strong>和<strong>右子树的左</strong>是否相等</li></ul></li></ul><h3 id="29-顺时针打印矩阵"><a href="#29-顺时针打印矩阵" class="headerlink" title="29.顺时针打印矩阵"></a><a href="https://zuizichuan.cn/2020/07/20/jianzhioffer2/#29-%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5">29.顺时针打印矩阵</a></h3><ul><li><blockquote><p>边界判断：上下左右，逐渐缩小范围</p></blockquote></li></ul><h3 id="30-包含min函数的栈"><a href="#30-包含min函数的栈" class="headerlink" title="30.包含min函数的栈"></a><a href="https://zuizichuan.cn/2020/07/20/jianzhioffer2/#30-%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88">30.包含min函数的栈</a></h3><ul><li><blockquote><p>空间换时间，入栈两个</p></blockquote></li></ul><h3 id="31-栈的压入、弹出序列"><a href="#31-栈的压入、弹出序列" class="headerlink" title="31.栈的压入、弹出序列 "></a><a href="https://zuizichuan.cn/2020/07/20/jianzhioffer2/#31-%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E3%80%81%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97">31.栈的压入、弹出序列 </a></h3><ul><li><blockquote><p>利用辅助栈，当辅助栈内的数据 = pop数组的数据需要弹出。</p></blockquote></li></ul><h3 id="32-1-从上到下打印二叉树"><a href="#32-1-从上到下打印二叉树" class="headerlink" title="32-1.从上到下打印二叉树 "></a><a href="https://zuizichuan.cn/2020/07/20/jianzhioffer2/#32-1-%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91">32-1.从上到下打印二叉树 </a></h3><ul><li><blockquote><p>利用队列的层序遍历</p></blockquote></li><li><blockquote><p>关键点：</p></blockquote><ul><li>int size = q.size() 然后for(int i =0;i&lt;size;i++)</li><li>if(q-&gt;left)加入；if(q-&gt;right)加入  </li></ul></li><li><blockquote><p>初始化可以vector(arr.rbegin().arr.rend());</p></blockquote></li></ul><h3 id="33-二叉搜索树的后序遍历序列"><a href="#33-二叉搜索树的后序遍历序列" class="headerlink" title="33.二叉搜索树的后序遍历序列"></a><a href="https://zuizichuan.cn/2020/07/20/jianzhioffer2/#33-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97">33.二叉搜索树的后序遍历序列</a></h3><ul><li><blockquote><p>二叉搜索树：左 &lt; 中 &lt; 右</p></blockquote></li><li><blockquote><p>后序遍历：左 右 中</p></blockquote><ul><li>输入：后序遍历数组，left，root</li><li>所以找到：后序遍历：左 index 右的区分下标，满足右&gt;root值。这个区间满足</li><li>再次检查别的区间：<strong>后序遍历数组</strong> 的左、右子树是否满足</li><li>return dfs(postorder,left,i-1)&amp;&amp;dfs(postorder,i,root-1);</li></ul></li></ul><h3 id="34-二叉树中和为某一值的路径"><a href="#34-二叉树中和为某一值的路径" class="headerlink" title="34.二叉树中和为某一值的路径"></a><a href="https://zuizichuan.cn/2020/07/20/jianzhioffer2/#34-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84Sum-%E4%B8%80%E6%9D%A1%E8%B7%AF%E5%BE%84%E7%9A%84%E5%92%8C">34.二叉树中和为某一值的路径</a></h3><ul><li><blockquote><p>首先：需要遍历到最后一个节点为NULL，才符合条件</p></blockquote><ul><li>root == NULL的情况下才会返回</li><li>root == sum &amp;&amp; root-&gt;left==NULL &amp;&amp; root-&gt;right==NULL才满足条件</li></ul></li></ul><h3 id="35-复杂链表的复制"><a href="#35-复杂链表的复制" class="headerlink" title="35.复杂链表的复制 "></a><a href="https://zuizichuan.cn/2020/07/20/jianzhioffer2/#35-%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E6%B7%B1%E6%8B%B7%E8%B4%9D">35.复杂链表的复制 </a></h3><ul><li><blockquote><p>1.复制原指针A -&gt; B -&gt; C 变 A -&gt; A’-&gt; B -&gt; B’-&gt; C-&gt; C’</p></blockquote></li><li><blockquote><p>2.改变random指针指向，上一步复制的节点包含了random节点</p></blockquote></li><li><blockquote><p>3.断开链表，同时复原</p></blockquote></li></ul><h3 id="36-二叉搜索树与双向链表"><a href="#36-二叉搜索树与双向链表" class="headerlink" title="36.二叉搜索树与双向链表"></a><a href="https://zuizichuan.cn/2020/07/20/jianzhioffer2/#36-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8">36.二叉搜索树与双向链表</a></h3><ul><li><blockquote><p>二叉搜索树——左中右形式存储——利用中序将节点截取下来</p></blockquote></li></ul><h3 id="37-序列化二叉树-层序困难"><a href="#37-序列化二叉树-层序困难" class="headerlink" title="37.序列化二叉树(层序困难)"></a><a href="https://zuizichuan.cn/2020/07/20/jianzhioffer2/#37-%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91-%E2%80%94%E2%80%94-%E9%87%8D%E8%A6%81">37.序列化二叉树(层序困难)</a></h3><ul><li><blockquote><p>利用getline截取数值</p></blockquote></li><li><blockquote><p>前序、中序、后续、层序都是可以的。对应的反序列化即可。</p></blockquote></li></ul><h3 id="38-字符串排列的所以可能性"><a href="#38-字符串排列的所以可能性" class="headerlink" title="38.字符串排列的所以可能性"></a><a href="https://zuizichuan.cn/2020/07/20/jianzhioffer2/#38-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97">38.字符串排列的所以可能性</a></h3><ul><li><blockquote><p>回溯法 + 剪枝</p></blockquote><ul><li>1.先排序，便于找到重复的元素位置</li><li>2.做出选择：char —&gt; #，撤销选择： # —&gt; char</li><li>3.关键的剪纸操作难点在于：<ul><li>if (s[i] == ‘#’ || (i &gt; 0 &amp;&amp; s[i] == s[i - 1]))  continue;</li></ul></li></ul></li></ul><h3 id="39-数组中出现次数超过一半的数字"><a href="#39-数组中出现次数超过一半的数字" class="headerlink" title="39.数组中出现次数超过一半的数字 "></a><a href="https://zuizichuan.cn/2020/07/20/jianzhioffer2/#39-%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97">39.数组中出现次数超过一半的数字 </a></h3><ul><li><blockquote><p>摩尔投票法——极限一换一</p></blockquote></li></ul><h3 id="40-最小的K个数"><a href="#40-最小的K个数" class="headerlink" title="40.最小的K个数 "></a><a href="https://zuizichuan.cn/2020/07/20/jianzhioffer2/#40-%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0">40.最小的K个数 </a></h3><ul><li><blockquote><p>各种排序</p></blockquote></li></ul><h3 id="41-数据流中的中位数"><a href="#41-数据流中的中位数" class="headerlink" title="41.数据流中的中位数 "></a><a href="https://zuizichuan.cn/2020/07/20/jianzhioffer2/#41-%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0">41.数据流中的中位数 </a></h3><ul><li><blockquote><p>优先队列：元素经过队列过一次手，大根堆存小的一半数，小根堆存大的一半数</p></blockquote><ul><li>priority_queue&lt;int, vector<int>, std::less<int>&gt; maxStack;</li><li>priority_queue&lt;int, vector<int>, std::greater<int>&gt; minStack;</li></ul></li></ul><h3 id="42-连续子数组的最大和"><a href="#42-连续子数组的最大和" class="headerlink" title="42.连续子数组的最大和"></a><a href="https://zuizichuan.cn/2020/07/20/jianzhioffer2/#42-%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C">42.连续子数组的最大和</a></h3><ul><li><blockquote><p>dp动态规划 / 变负反转</p></blockquote></li><li><blockquote><p>贪心算法</p></blockquote></li></ul><h3 id="43-1～n整数中1出现的次数"><a href="#43-1～n整数中1出现的次数" class="headerlink" title="43.1～n整数中1出现的次数 "></a><a href="https://zuizichuan.cn/2020/07/20/jianzhioffer2/#43-1%EF%BD%9En%E6%95%B4%E6%95%B0%E4%B8%AD1%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0">43.1～n整数中1出现的次数 </a></h3><ul><li><blockquote><p>找规律，然后区分低位、高位、当前位、位因子</p></blockquote></li></ul><h3 id="44-连续数字中的第N个数"><a href="#44-连续数字中的第N个数" class="headerlink" title="44.连续数字中的第N个数"></a><a href="https://zuizichuan.cn/2020/07/20/jianzhioffer2/#44-%E6%95%B0%E5%AD%97%E5%BA%8F%E5%88%97%E4%B8%AD%E6%9F%90%E4%B8%80%E4%BD%8D%E7%9A%84%E6%95%B0%E5%AD%97">44.连续数字中的第N个数</a></h3><ul><li><blockquote><p>找规律，范围 / 数量 / 位数 / 占位的情况，从而总结。</p></blockquote></li></ul><h3 id="45-把数组中所有整数排成最小的连续数"><a href="#45-把数组中所有整数排成最小的连续数" class="headerlink" title="45.把数组中所有整数排成最小的连续数 "></a><a href="https://zuizichuan.cn/2020/07/20/jianzhioffer2/#45-%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0">45.把数组中所有整数排成最小的连续数 </a></h3><ul><li><blockquote><p>利用sort排序，自定义sort函数，重写Compare</p></blockquote></li></ul><h3 id="46-把数字翻译成字符串"><a href="#46-把数字翻译成字符串" class="headerlink" title="46.把数字翻译成字符串"></a><a href="https://zuizichuan.cn/2020/07/20/jianzhioffer2/#46-%E6%8A%8A%E6%95%B0%E5%AD%97%E7%BF%BB%E8%AF%91%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2">46.把数字翻译成字符串</a></h3><ul><li><blockquote><p>DP动态方程： dp[i] = dp[i - 1] / dp[i] = dp[i - 1] + p[i - 2];</p></blockquote></li></ul><h3 id="47-礼物的最大价值"><a href="#47-礼物的最大价值" class="headerlink" title="47.礼物的最大价值"></a><a href="https://zuizichuan.cn/2020/07/20/jianzhioffer2/#47-%E7%A4%BC%E7%89%A9%E7%9A%84%E6%9C%80%E5%A4%A7%E4%BB%B7%E5%80%BC">47.礼物的最大价值</a></h3><ul><li><blockquote><p>典型的dp动态方程</p></blockquote></li></ul><hr><h1 id="48-68"><a href="#48-68" class="headerlink" title="48 - 68"></a><a href="https://zuizichuan.cn/2020/07/20/jianzhioffer3/">48 - 68</a></h1><h3 id="48-最长不含重复字符的子字符串"><a href="#48-最长不含重复字符的子字符串" class="headerlink" title="48.最长不含重复字符的子字符串 "></a>48.<a href="https://zuizichuan.cn/2020/07/20/jianzhioffer3/#48-%E6%9C%80%E9%95%BF%E4%B8%8D%E5%90%AB%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2">最长不含重复字符的子字符串 </a></h3><ul><li><blockquote><p>经典滑动窗口</p></blockquote></li></ul><h3 id="49-丑数"><a href="#49-丑数" class="headerlink" title="49. 丑数 "></a>49. <a href="https://zuizichuan.cn/2020/07/20/jianzhioffer3/#49-%E4%B8%91%E6%95%B0">丑数 </a></h3><ul><li><blockquote><p>丑数本身是丑数，丑数是在丑数的基础上*2 或 *3 或 *5</p></blockquote></li><li><blockquote><p>所以我们在三个丑数数组中选取最小的数来组成，三个变量a、b、c</p></blockquote></li></ul><h3 id="50-第一个只出现一次的字符"><a href="#50-第一个只出现一次的字符" class="headerlink" title="50. 第一个只出现一次的字符"></a>50. <a href="https://zuizichuan.cn/2020/07/20/jianzhioffer3/#50-%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6">第一个只出现一次的字符</a></h3><ul><li><blockquote><p>哈希表统计</p></blockquote></li></ul><h3 id="51-数组中的逆序对"><a href="#51-数组中的逆序对" class="headerlink" title="51.数组中的逆序对"></a>51.<a href="https://zuizichuan.cn/2020/07/20/jianzhioffer3/#51-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9">数组中的逆序对</a></h3><ul><li><blockquote><p>归并来做，部分的res相互叠加，计算出最后的res。</p></blockquote></li></ul><h3 id="52-两个链表的第一个公共节点"><a href="#52-两个链表的第一个公共节点" class="headerlink" title="52. 两个链表的第一个公共节点 "></a>52. <a href="https://zuizichuan.cn/2020/07/20/jianzhioffer3/#52-%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E8%8A%82%E7%82%B9">两个链表的第一个公共节点 </a></h3><ul><li><blockquote><p>a + c + b = b + c + a程序员的浪漫</p></blockquote></li></ul><h3 id="53-1-在排序数组中查找数字出现次数"><a href="#53-1-在排序数组中查找数字出现次数" class="headerlink" title="53-1. 在排序数组中查找数字出现次数"></a>53-1. <a href="https://zuizichuan.cn/2020/07/20/jianzhioffer3/#53-1-%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E6%95%B0%E5%AD%97%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0">在排序数组中查找数字出现次数</a></h3><ul><li><blockquote><p>二分法！！有序一般都是二分法</p></blockquote></li></ul><h3 id="53-2-0～n-1中缺失的数字"><a href="#53-2-0～n-1中缺失的数字" class="headerlink" title="53-2. 0～n-1中缺失的数字"></a>53-2. <a href="https://zuizichuan.cn/2020/07/20/jianzhioffer3/#53-2-0%EF%BD%9En-1%E4%B8%AD%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97">0～n-1中缺失的数字</a></h3><ul><li><blockquote><p>二分法，但是最后的判断很难。找到最左边不等于下标的数。</p></blockquote></li></ul><h3 id="54-二叉搜索树的第k大节点"><a href="#54-二叉搜索树的第k大节点" class="headerlink" title="54. 二叉搜索树的第k大节点 "></a>54. <a href="https://zuizichuan.cn/2020/07/20/jianzhioffer3/#54-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%AC%ACk%E5%A4%A7%E8%8A%82%E7%82%B9">二叉搜索树的第k大节点 </a></h3><ul><li><blockquote><p>利用搜索二叉树的中序遍历得到顺序数组</p></blockquote></li><li><blockquote><p>更加优秀的，直接利用倒置的中序遍历，反向从大到小开始遍历。</p></blockquote></li></ul><h3 id="55-1-二叉树的深度"><a href="#55-1-二叉树的深度" class="headerlink" title="55-1.二叉树的深度 "></a>55-1.<a href="https://zuizichuan.cn/2020/07/20/jianzhioffer3/#55-1-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6">二叉树的深度 </a></h3><ul><li><blockquote><p>dfs求取树的深度，往下+1就可以了</p></blockquote></li></ul><h3 id="55-2-判断是否平衡二叉树（仅高度）"><a href="#55-2-判断是否平衡二叉树（仅高度）" class="headerlink" title="55-2. 判断是否平衡二叉树（仅高度）"></a>55-2. <a href="https://zuizichuan.cn/2020/07/20/jianzhioffer3/#55-2-%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91">判断是否平衡二叉树（仅高度）</a></h3><ul><li><blockquote><p>首先：每个节点需要满足高度差要求</p></blockquote></li><li><blockquote><p>然后：每个节点都需要满足左右子树</p></blockquote></li></ul><h3 id="55-拓展-二叉树路径和是否为Sum"><a href="#55-拓展-二叉树路径和是否为Sum" class="headerlink" title="55-拓展 二叉树路径和是否为Sum"></a>55-拓展 二叉树路径和是否为Sum</h3><ul><li><blockquote><p>首先：只要有一个到头的节点，那么就是有路径为Sum</p></blockquote></li><li><blockquote><p>只有：左为空，右为空，同时Sum值符合，return true。</p></blockquote><ul><li>如果节点为空，return false； </li></ul></li></ul><h3 id="55-拓展2-求二叉树的最大直径"><a href="#55-拓展2-求二叉树的最大直径" class="headerlink" title="55-拓展2 求二叉树的最大直径"></a>55-拓展2 求二叉树的最大直径</h3><ul><li><blockquote><p>首先：不一定根节点为最大直径节点，所以每次需要比较</p></blockquote></li><li><blockquote><p>然后：同时每个节点的最大直径为，max（左树的左、左树的右）+ max（右树的左、右树的右）</p></blockquote><ul><li>所以每个节点：return max（L、R）+1</li></ul></li></ul><h3 id="56-1-数组中数字出现的次数"><a href="#56-1-数组中数字出现的次数" class="headerlink" title="56-1. 数组中数字出现的次数 "></a>56-1. <a href="https://zuizichuan.cn/2020/07/20/jianzhioffer3/#56-1-%E6%95%B0%E7%BB%84%E4%B8%AD%E6%95%B0%E5%AD%97%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0">数组中数字出现的次数 </a></h3><ul><li><blockquote><p>方法一：哈希表</p></blockquote></li><li><blockquote><p>方法二：位运算</p></blockquote></li><li><blockquote><p>A&amp;(-A)：结果最低位</p></blockquote></li></ul><h3 id="56-2-数组中数字出现的次数变形"><a href="#56-2-数组中数字出现的次数变形" class="headerlink" title="56-2.数组中数字出现的次数变形"></a>56-2.<a href="https://zuizichuan.cn/2020/07/20/jianzhioffer3/#56-2-%E6%95%B0%E7%BB%84%E4%B8%AD%E6%95%B0%E5%AD%97%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0-II">数组中数字出现的次数变形</a></h3><ul><li><blockquote><p>方法一：哈希表</p></blockquote></li><li><blockquote><p>方法二：位运算</p></blockquote></li><li><blockquote><p>统计那个没出现N次的为，取余取不到那就是那个位置。</p></blockquote></li></ul><h3 id="57-1-和为s的两个数字"><a href="#57-1-和为s的两个数字" class="headerlink" title="57-1.  和为s的两个数字 "></a>57-1.  <a href="https://zuizichuan.cn/2020/07/20/jianzhioffer3/#57-1-%E6%95%B0%E7%BB%84%E4%B8%AD%E5%92%8C%E4%B8%BAs%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97">和为s的两个数字 </a></h3><ul><li><blockquote><p>方法一：哈希表</p></blockquote></li><li><blockquote><p>方法二：滑动区间：left = 0；right = nums.size()；</p></blockquote></li></ul><h3 id="57-2-和为s的连续正数序列"><a href="#57-2-和为s的连续正数序列" class="headerlink" title="57-2.  和为s的连续正数序列"></a>57-2.  <a href="https://zuizichuan.cn/2020/07/20/jianzhioffer3/#57-2-%E5%92%8C%E4%B8%BAs%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%AD%A3%E6%95%B0%E5%BA%8F%E5%88%97">和为s的连续正数序列</a></h3><ul><li><blockquote><p>方法一：哈希表</p></blockquote></li><li><blockquote><p>方法二：滑动区间</p></blockquote></li></ul><h3 id="58-1-翻转单词顺序-stringstream"><a href="#58-1-翻转单词顺序-stringstream" class="headerlink" title="58-1. 翻转单词顺序 / stringstream"></a>58-1. <a href="https://zuizichuan.cn/2020/07/20/jianzhioffer3/#58-1-%E7%BF%BB%E8%BD%AC%E5%8D%95%E8%AF%8D%E9%A1%BA%E5%BA%8F">翻转单词顺序 / stringstream</a></h3><ul><li><blockquote><p>getline分割字符 / cin&gt;&gt;s的区别</p></blockquote></li><li><blockquote><p>stringstream</p></blockquote></li></ul><h3 id="58-2-左旋转字符串-substr"><a href="#58-2-左旋转字符串-substr" class="headerlink" title="58-2. 左旋转字符串 / substr"></a>58-2. <a href="https://zuizichuan.cn/2020/07/20/jianzhioffer3/#58-2-%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2">左旋转字符串 / substr</a></h3><ul><li><blockquote><p>substr（i，len）</p></blockquote></li><li><blockquote><p>i:从0开始，起始下标</p></blockquote></li></ul><h3 id="59-1-滑动窗口的最大值"><a href="#59-1-滑动窗口的最大值" class="headerlink" title="59-1. 滑动窗口的最大值"></a>59-1. <a href="https://zuizichuan.cn/2020/07/20/jianzhioffer3/#59-1-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC%E2%80%94%E2%80%94%E5%88%A9%E7%94%A8deque%E7%BB%B4%E6%8A%A4%EF%BC%88%E8%BF%9E%E7%BB%AD%E5%8C%BA%E9%97%B4%EF%BC%89">滑动窗口的最大值</a></h3><ul><li><blockquote><p>利用deque维护</p></blockquote><ul><li>头部存储最大元素（同时也是老元素），存放的是元素的下标index，从而识别出是否超出窗口范围</li><li>元素从尾部进入，逐一比较，然后删除<ul><li>然后装入queue，再次判断转入res</li></ul></li></ul></li></ul><h3 id="59-2-队列的最大值"><a href="#59-2-队列的最大值" class="headerlink" title="59-2. 队列的最大值"></a>59-2. <a href="https://zuizichuan.cn/2020/07/20/jianzhioffer3/#59-2-%E9%98%9F%E5%88%97%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC">队列的最大值</a></h3><ul><li><blockquote><p>利用deque维护</p></blockquote></li></ul><h3 id="60-n个骰子的点数"><a href="#60-n个骰子的点数" class="headerlink" title="60. n个骰子的点数"></a>60. <a href="https://zuizichuan.cn/2020/07/20/jianzhioffer3/#60-n%E4%B8%AA%E9%AA%B0%E5%AD%90%E7%9A%84%E7%82%B9%E6%95%B0-%EF%BC%88%E9%9A%BE%EF%BC%89">n个骰子的点数</a></h3><ul><li><blockquote><p>DP动态规划</p></blockquote></li></ul><h3 id="61-扑克牌中的顺子"><a href="#61-扑克牌中的顺子" class="headerlink" title="61.  扑克牌中的顺子"></a>61.  <a href="https://zuizichuan.cn/2020/07/20/jianzhioffer3/#61-%E6%89%91%E5%85%8B%E7%89%8C%E4%B8%AD%E7%9A%84%E9%A1%BA%E5%AD%90">扑克牌中的顺子</a></h3><ul><li><blockquote><p>顺序比较</p></blockquote></li></ul><h3 id="62-圆圈中最后剩下的数字-约瑟夫环问题"><a href="#62-圆圈中最后剩下的数字-约瑟夫环问题" class="headerlink" title="62. 圆圈中最后剩下的数字 / 约瑟夫环问题"></a>62. <a href="https://zuizichuan.cn/2020/07/20/jianzhioffer3/#62-%E5%9C%86%E5%9C%88%E4%B8%AD%E6%9C%80%E5%90%8E%E5%89%A9%E4%B8%8B%E7%9A%84%E6%95%B0%E5%AD%97%EF%BC%88%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF%E9%97%AE%E9%A2%98%EF%BC%89">圆圈中最后剩下的数字 / 约瑟夫环问题</a></h3><ul><li><blockquote><p>约瑟夫环问题，f（m，n）=【f（m - 1，n）+ n】 % m</p></blockquote></li></ul><h3 id="63-股票的最大利润"><a href="#63-股票的最大利润" class="headerlink" title="63. 股票的最大利润"></a>63. <a href="https://zuizichuan.cn/2020/07/20/jianzhioffer3/#63-%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E5%A4%A7%E5%88%A9%E6%B6%A6">股票的最大利润</a></h3><ul><li><blockquote><p>dp动态规划</p></blockquote></li><li><blockquote><p>记录之前的最小价格即可</p></blockquote></li></ul><h3 id="64-求1-2-…-n-利用sizeof"><a href="#64-求1-2-…-n-利用sizeof" class="headerlink" title="64. 求1+2+…+n / 利用sizeof"></a>64. <a href="https://zuizichuan.cn/2020/07/20/jianzhioffer3/#64-%E6%B1%821-2-%E2%80%A6-n">求1+2+…+n / 利用sizeof</a></h3><ul><li><blockquote><p>利用sizeof</p></blockquote></li></ul><h3 id="65-不用加减乘除做加法"><a href="#65-不用加减乘除做加法" class="headerlink" title="65. 不用加减乘除做加法 "></a>65. <a href="https://zuizichuan.cn/2020/07/20/jianzhioffer3/#65-%E4%B8%8D%E7%94%A8%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E5%81%9A%E5%8A%A0%E6%B3%95">不用加减乘除做加法 </a></h3><ul><li><blockquote><p>位运算，&amp;进位和^非进位</p></blockquote></li><li>while(b){  </li><li>int temp = (unsigned int)(a &amp; b) &lt;&lt; 1;   //c:进位和————双1才1</li><li>a ^= b;                //a:非进位和——单1才1</li><li>b = temp;                 //b = 进位</li><li>}</li><li>return a;</li></ul><h3 id="66-构建乘积数组-左乘、然后再右乘"><a href="#66-构建乘积数组-左乘、然后再右乘" class="headerlink" title="66. 构建乘积数组 / 左乘、然后再右乘"></a>66. <a href="https://zuizichuan.cn/2020/07/20/jianzhioffer3/#66-%E6%9E%84%E5%BB%BA%E4%B9%98%E7%A7%AF%E6%95%B0%E7%BB%84">构建乘积数组 / 左乘、然后再右乘</a></h3><ul><li><blockquote><p>先左乘，再右乘O（n）</p></blockquote></li></ul><h3 id="67-把字符串转换成整数-isdigit-char-函数"><a href="#67-把字符串转换成整数-isdigit-char-函数" class="headerlink" title="67. 把字符串转换成整数 / isdigit( char )函数 "></a>67. <a href="https://zuizichuan.cn/2020/07/20/jianzhioffer3/#67-%E6%8A%8A%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%88%90%E6%95%B4%E6%95%B0">把字符串转换成整数 / isdigit( char )函数 </a></h3><ul><li><blockquote><p>利用函数isdigit（）</p></blockquote></li></ul><h3 id="68-1-二叉搜索树的最近公共祖先"><a href="#68-1-二叉搜索树的最近公共祖先" class="headerlink" title="68-1. 二叉搜索树的最近公共祖先"></a>68-1. <a href="https://zuizichuan.cn/2020/07/20/jianzhioffer3/#68-1-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88">二叉搜索树的最近公共祖先</a></h3><ul><li><blockquote><p>利用二叉搜索树的特性：左 &lt; 中 &lt; 右</p></blockquote></li><li><blockquote><p>p、q都小于找右</p></blockquote></li><li><blockquote><p>p、q都大于找左</p></blockquote></li><li><blockquote><p>否则就是正好</p></blockquote></li></ul><h3 id="68-2-二叉树的最近公共祖先"><a href="#68-2-二叉树的最近公共祖先" class="headerlink" title="68-2.二叉树的最近公共祖先 "></a>68-2.<a href="https://zuizichuan.cn/2020/07/20/jianzhioffer3/#68-2-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88">二叉树的最近公共祖先 </a></h3><ul><li><blockquote><p>首先：每个节点都有可能是祖先，依次往下遍历找到相对应的节点</p></blockquote></li><li><blockquote><p>当L &amp;&amp; R都有值的时候，返回root。</p></blockquote></li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> 剑指Offer </category>
          
          <category> 目录 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++ / 输入输出模板</title>
      <link href="/2020/07/19/baseC/"/>
      <url>/2020/07/19/baseC/</url>
      
        <content type="html"><![CDATA[<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul><li>cin后getline失效<ul><li>加上cin.ignore(); //重新清空流数据</li></ul></li><li>isalpha()  //判断是否字母</li><li>isdigit()    //判断是否数字</li><li>include&lt; cctype &gt;</li></ul><h2 id="常用头文件"><a href="#常用头文件" class="headerlink" title="常用头文件"></a>常用头文件</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;     //INT_MAX的头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br></pre></td></tr></table></figure><h2 id="单个字符输入"><a href="#单个字符输入" class="headerlink" title="单个字符输入"></a>单个字符输入</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a1 = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a1;</span><br><span class="line"><span class="built_in">string</span> a2 = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a2;</span><br></pre></td></tr></table></figure><h2 id="单行数据的输入"><a href="#单行数据的输入" class="headerlink" title="单行数据的输入"></a>单行数据的输入</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> arr[<span class="number">100</span>];</span><br><span class="line"><span class="built_in">cin</span>.getline(arr, <span class="number">10</span>);<span class="comment">//获取第10个字符之前，指针现在指在第10个字符那里</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; arr &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> _string;<span class="comment">//获取整行元素</span></span><br><span class="line">getline(<span class="built_in">cin</span>, _string);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; _string &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><ul><li><blockquote><p>string 转  int  / string.c_str();</p></blockquote></li><li><blockquote><p>int 转 string / to_string();</p></blockquote></li></ul><h2 id="利用getline截取字符串流的数据"><a href="#利用getline截取字符串流的数据" class="headerlink" title="利用getline截取字符串流的数据"></a>利用getline截取字符串流的数据</h2><h3 id="1-2-3-4-5-6转换为vector-1，2，3，4，5，6"><a href="#1-2-3-4-5-6转换为vector-1，2，3，4，5，6" class="headerlink" title="1,2,3,4,5,6转换为vector{1，2，3，4，5，6}"></a>1,2,3,4,5,6转换为vector<int>{1，2，3，4，5，6}</h3> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s;</span><br><span class="line">getline(<span class="built_in">cin</span>, s);</span><br><span class="line"><span class="function"><span class="built_in">stringstream</span> <span class="title">ss</span><span class="params">(s)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; resTemp;</span><br><span class="line">res.<span class="built_in">clear</span>();</span><br><span class="line"><span class="built_in">string</span> temp;</span><br><span class="line"><span class="keyword">while</span> (getline(ss, temp, <span class="string">','</span>))</span><br><span class="line">&#123;</span><br><span class="line">res.push_back(temp);</span><br><span class="line">resTemp.push_back(stoi(temp, <span class="number">0</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二维数组的输入"><a href="#二维数组的输入" class="headerlink" title="二维数组的输入"></a>二维数组的输入</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二维数组的输入</span></span><br><span class="line"><span class="comment">//2 3</span></span><br><span class="line"><span class="comment">//110 100</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">arry2input</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> rows = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> cols = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入行"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; rows;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入列"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; cols;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;<span class="built_in">array</span>;<span class="comment">//定义二维数组</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v;</span><br><span class="line"><span class="built_in">array</span>.<span class="built_in">clear</span>();</span><br><span class="line"><span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//在cin后面使用getline：需要忽略换行符后可以读取数据</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cin</span>.ignore();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入数值"</span> &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//连续的 111 000 111</span></span><br><span class="line"><span class="comment">//char num[100];</span></span><br><span class="line"><span class="comment">//cin.getline(num, rows*cols);</span></span><br><span class="line"><span class="built_in">string</span> num;</span><br><span class="line">getline(<span class="built_in">cin</span>, num);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">v.<span class="built_in">clear</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols; j++) &#123;</span><br><span class="line">v.push_back(num[i++] - <span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">array</span>.push_back(v);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> learn </category>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode / 97. 交错字符串</title>
      <link href="/2020/07/18/leetcode4/"/>
      <url>/2020/07/18/leetcode4/</url>
      
        <content type="html"><![CDATA[<h2 id="97-交错字符串"><a href="#97-交错字符串" class="headerlink" title=" 97. 交错字符串"></a><font size=6> 97. 交错字符串</font></h2><p> <code>题目</code></p><ul><li>给定三个字符串 s1, s2, s3, 验证 s3 是否是由 s1 和 s2 交错组成的。</li></ul><p><code>例题</code></p><p>输入: s1 = “aabcc”, s2 = “dbbca”, s3 = “aadbbcbcac”</p><p>输出: true</p><p>输入: s1 = “aabcc”, s2 = “dbbca”, s3 = “aadbbbaccc”</p><p>输出: false</p><p><code>理解</code>：字符串问题用动态规划，逐步思考和上一个字符串的关系</p><ul><li><blockquote><p>字符串画表，进行路径规划</p></blockquote></li><li><blockquote><p>dp[i][j] = dp[i-1][j]&amp;&amp;s1[i-1]==s3[i+j-1] || dp[i][j-1]&amp;&amp;s2[j-1]==s3[i+j-1];</p></blockquote></li></ul><p><font size=7> 画表画表</font> </p><p><code>解题</code></p><p><img src="/pictures/clipboard19.png" alt="img1"></p><ul><li>初始化列表</li><li>路径规划——两条路径，前提条件的保证和选择</li><li>dp[i][j] = <code>dp[i-1][j]&amp;&amp;s1[i-1]==s3[i+j-1]</code> || <code>dp[i][j-1]&amp;&amp;s2[j-1]==s3[i+j-1]</code></li></ul><hr><p><code>代码</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isInterleave</span><span class="params">(<span class="built_in">string</span> s1, <span class="built_in">string</span> s2, <span class="built_in">string</span> s3)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (s1.<span class="built_in">size</span>() + s2.<span class="built_in">size</span>() != s3.<span class="built_in">size</span>())</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n = s1.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">int</span> m = s2.<span class="built_in">size</span>();</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt;dp(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(m + <span class="number">1</span>, <span class="literal">false</span>));</span><br><span class="line"></span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n + <span class="number">1</span>; i++) &#123;</span><br><span class="line">dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] &amp;&amp; s1[i - <span class="number">1</span>] == s3[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m + <span class="number">1</span>; i++) &#123;</span><br><span class="line">dp[<span class="number">0</span>][i] = dp[<span class="number">0</span>][i - <span class="number">1</span>] &amp;&amp; s2[i - <span class="number">1</span>] == s3[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n + <span class="number">1</span>; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; m + <span class="number">1</span>; j++) &#123;</span><br><span class="line">dp[i][j] = dp[i - <span class="number">1</span>][j] &amp;&amp; s1[i - <span class="number">1</span>] == s3[i + j - <span class="number">1</span>] || </span><br><span class="line">            dp[i][j - <span class="number">1</span>] &amp;&amp; s2[j - <span class="number">1</span>] == s3[i + j - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[n][m];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="类似题目"><a href="#类似题目" class="headerlink" title="类似题目"></a>类似题目</h2><h2 id="416-分割等和子集"><a href="#416-分割等和子集" class="headerlink" title=" 416. 分割等和子集"></a><font size=6> 416. 分割等和子集</font></h2><p> <code>题目</code></p><ul><li>给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</li></ul><p><code>例题</code></p><p>输入: [1, 5, 11, 5]</p><p>输出: true</p><p>解释: 数组可以分割成 [1, 5, 5] 和 [11].</p><p>输入: [1, 2, 3, 5]</p><p>输出: false</p><p>解释: 数组不能分割成两个元素和相等的子集.</p><p><code>理解</code>：让集合元素相加 target = sum / 2</p><ul><li><blockquote><p>动态规划：对于依次使用集合中元素，考虑所有能组合成的可能性</p></blockquote></li><li><blockquote><p>dp[ i ][ j ] = dp[ i-1 ][ j ]  ||   nums[ i ]==j || dp[ i-1 ][ j - nums[i]] </p></blockquote></li></ul><p>1.上可以，下不加也一定可以<br>2.当num[i] =j时也一定可以<br>3.当 j&gt;nums[i]时，dp[i-1][j-nums[i]]也为真时，其也为真<br><font size=7> 画表画表</font><br><img src="/pictures/clipboard20.png" alt="img1"></p><ul><li>初始化列表</li><li>路径规划——三种可能，前提条件的保证和选择<br><code>代码</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canPartition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line"><span class="comment">//求取target</span></span><br><span class="line"><span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">if</span> (n &lt;= <span class="number">1</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it : nums) &#123;</span><br><span class="line">sum += it;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (sum % <span class="number">2</span> == <span class="number">1</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">int</span> target = sum / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt;dp(n, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(target + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重要：可能会忽略这种情况</span></span><br><span class="line"><span class="comment">//第一行只有这种情况</span></span><br><span class="line"><span class="keyword">if</span> (nums[<span class="number">0</span>] &lt;= target) &#123;</span><br><span class="line">dp[<span class="number">0</span>][nums[<span class="number">0</span>]] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; target + <span class="number">1</span>; j++) &#123;</span><br><span class="line"></span><br><span class="line">dp[i][j] = dp[i - <span class="number">1</span>][j];<span class="comment">//1.对前值得继承</span></span><br><span class="line"><span class="keyword">if</span> (nums[i] &lt;= j) &#123;</span><br><span class="line">dp[i][j] = dp[i - <span class="number">1</span>][j] || dp[i - <span class="number">1</span>][j - nums[i]];</span><br><span class="line">&#125;   <span class="comment">//三种情况:2.j-num[i]=0,肯定行</span></span><br><span class="line">&#125;       <span class="comment">//          3.再减去nums[i],也是行的</span></span><br><span class="line"><span class="keyword">if</span> (dp[i][target]) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[n - <span class="number">1</span>][target];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="72-编辑距离"><a href="#72-编辑距离" class="headerlink" title=" 72. 编辑距离"></a><font size=6> 72. 编辑距离</font></h2><p><code>题目</code>：给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。</p><ul><li>你可以对一个单词进行如下三种操作：</li><li>插入一个字符</li><li>删除一个字符</li><li>替换一个字符</li></ul><p><code>例题</code><br><img src="/pictures/clipboard21.png" alt="img1"></p><p><code>解题</code></p><ul><li><blockquote><p>三种移动方法：1.删除 2. 替换 3.插入</p></blockquote></li><li><blockquote><p>删除和替换和插入操作数是一样的为1，但是当插入的新字符 = 对应字符，操作数为0</p></blockquote></li></ul><p><img src="/pictures/clipboard22.png" alt="img1"></p><ul><li><blockquote><p>1.初始化  dp[i][0] = i;</p></blockquote></li><li><blockquote><p>2.</p></blockquote></li><li><p>int temp1 = dp[i-1][j] + 1;</p></li><li><p>int temp2 = dp[i][j-1] + 1;</p></li><li><p>int temp3 = dp[i-1][j-1];</p></li><li><p>if(word1[i-1]!= word2[j-1])temp3++;</p></li></ul><ul><li>dp[i][j] = min(temp1,min(temp2,temp3));  </li></ul><p><code>代码</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(<span class="built_in">string</span> word1, <span class="built_in">string</span> word2)</span> </span>&#123;</span><br><span class="line"><span class="comment">//word1转换为word2</span></span><br><span class="line"><span class="keyword">int</span> len1 = word1.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">int</span> len2 = word2.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (len1*len2 == <span class="number">0</span>)<span class="keyword">return</span> <span class="built_in">max</span>(len1, len2);</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;dp(len1 + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(len2 + <span class="number">1</span>));<span class="comment">//都要+1  dp[0][0]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len1 + <span class="number">1</span>; i++) &#123;</span><br><span class="line">dp[i][<span class="number">0</span>] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len2 + <span class="number">1</span>; i++) &#123;</span><br><span class="line">dp[<span class="number">0</span>][i] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len1 + <span class="number">1</span>; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; len2 + <span class="number">1</span>; j++) &#123;</span><br><span class="line"><span class="keyword">int</span> temp1 = dp[i - <span class="number">1</span>][j] + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> temp2 = dp[i][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> temp3 = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">if</span> (word1[i - <span class="number">1</span>] != word2[j - <span class="number">1</span>])</span><br><span class="line">temp3++;</span><br><span class="line">dp[i][j] = <span class="built_in">min</span>(temp1, <span class="built_in">min</span>(temp2, temp3));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[len1][len2];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="1143-最长公共子串"><a href="#1143-最长公共子串" class="headerlink" title=" 1143. 最长公共子串"></a><font size=6> 1143. 最长公共子串</font></h2><p><code>题目</code><br>给定两个字符串 text1 和 text2，返回这两个字符串的最长公共子序列的长度。</p><p>例如，”ace” 是 “abcde” 的子序列，但 “aec” 不是 “abcde” 的子序列。</p><ul><li>输入：text1 = “abcde”, text2 = “ace” </li><li>输出：3  </li><li>解释：最长公共子序列是 “ace”，它的长度为 3。</li></ul><ul><li>输入：text1 = “abc”, text2 = “def”</li><li>输出：0</li><li>解释：两个字符串没有公共子序列，返回 0。</li></ul><ol><li><strong>初始化dp [0][ i ] = 0  dp [ j ][0] = 0</strong></li><li>dp方程     </li></ol><p>if（text1[ i-1 ]=text2[ j-1]）</p><p>dp[ i ][ j ] = dp[i-1 ][ j-1 ] +1;</p><p>else </p><p>dp[ i ][ j ] = max(dp[i-1 ][ j ],dp[i ][ j-1 ];)<br><img src="/pictures/clipboard23.png" alt="img1"></p><p><code>代码</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(<span class="built_in">string</span> text1, <span class="built_in">string</span> text2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> m = text1.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">int</span> n = text2.<span class="built_in">size</span>();</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;dp(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m + <span class="number">1</span>; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n + <span class="number">1</span>; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (text1[i - <span class="number">1</span>] == text2[j - <span class="number">1</span>])</span><br><span class="line">dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">dp[i][j] = <span class="built_in">max</span>(dp[i][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[m][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="718-最长重复子数组"><a href="#718-最长重复子数组" class="headerlink" title=" 718.最长重复子数组"></a><font size=6> 718.最长重复子数组</font></h2><p><code>题目</code>：<br>给两个整数数组 A 和 B ，返回两个数组中公共的、长度最长的子数组的长度。<br><code>例题</code>：</p><ul><li>输入：</li><li>A: [1,2,3,2,1]</li><li>B: [3,2,1,4,7]</li><li>输出：3</li><li>解释：</li><li>长度最长的公共子数组是 [3, 2, 1] 。<br><img src="/pictures/clipboard24.png" alt="img1"></li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
          <category> 97.交错字符串 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ / 基础概念问题</title>
      <link href="/2020/07/17/C-base/"/>
      <url>/2020/07/17/C-base/</url>
      
        <content type="html"><![CDATA[<h2 id="分类—小点"><a href="#分类—小点" class="headerlink" title="分类—小点"></a>分类—小点</h2><ul><li><p>1.内置类型无默认构造函数，需要显示的初始化</p><ul><li>int *p = new int；//未初始化</li><li>int *p = new int（）；//初始化0</li></ul></li><li><p>2.生命周期，作用域定义：——变量的生存时间，变量的使用范围</p></li><li><p>3.常量引用的作用：传引用不会新创建一个新变量然后进行拷贝，而是直接传对象，速度快，同时保证了在函数内部无法对对象进行修改。</p></li><li><p>4.protested的作用：完全为了子类服务。能在子类继承父类后，保证父类中对象能被子类访问的同时，不被类外成员访问。</p></li><li><p>5.野指针：指针指向了不合理的地址。（指向释放了的资源，指向未被初始化的对象）</p></li><li><p>6.函数指针：是指向函数的指针。每个函数都有一个入口地址，函数指针就指向该地址。有了该指针变量就可以调用该函数了。</p></li><li><p>7.静态函数和虚函数区别：静态函数编译前已经确定，虚函数动态绑定。 </p></li></ul><h2 id="关键字、动态内存"><a href="#关键字、动态内存" class="headerlink" title="关键字、动态内存"></a>关键字、动态内存</h2><h3 id="1-补码的作用即表示"><a href="#1-补码的作用即表示" class="headerlink" title="1.补码的作用即表示"></a>1.补码的作用即表示</h3><ul><li><p>计算机中全是加运算，补码的是为了将计算机中的减法化为加法，这样只需要考虑加法就可以了。</p></li><li><p>相当于完成了数字，0到255和-128到127的映射关系。</p><ol><li><p>tip:-128只有补码 1000 0000</p></li><li><p>负数的补码：符号位不变，取反，+1</p><ul><li><p>-8</p></li><li><p>原码：1000 1000</p></li><li><p>反码：1111 0111</p></li><li><p>补码：1111 1110</p></li></ul></li></ol></li></ul><hr><h3 id="2-float和double如何取0"><a href="#2-float和double如何取0" class="headerlink" title="2.float和double如何取0"></a>2.float和double如何取0</h3><ul><li>float有效数字为6位。double有效数字为10位。</li><li>我们利用 fabs(float x)函数来求取浮点数的<strong>绝对值</strong>，从而进行比较<ul><li>if(fabs(x)&lt; 0.000001)</li></ul></li></ul><hr><h3 id="3-C-关键字-运算符（操作符）"><a href="#3-C-关键字-运算符（操作符）" class="headerlink" title="3.C++关键字 /  运算符（操作符）"></a>3.C++关键字 /  运算符（操作符）</h3><ul><li>关键字<br><img src="/pictures/clipboard25.png" alt="img1"></li></ul><ul><li>运算符/操作符<ul><li>自增自减 ++ / –</li><li>关系操作符 &lt; 、&gt; 、&lt;= 、&gt;=</li><li>逻辑运算符号 &amp;&amp; 和 ||</li><li>位操作符<ul><li>按位与 &amp;  ——双1才1</li><li>按位或 | ——有1则1  </li><li>按位异或 ^ ——不同1，相同0</li><li>取反 ~  </li><li>左移&lt;&lt;   乘以2</li><li>右移&gt;&gt;   除以2</li></ul></li></ul></li></ul><hr><h3 id="4-malloc-free和new-delete的区别"><a href="#4-malloc-free和new-delete的区别" class="headerlink" title="4.malloc/free和new/delete的区别"></a>4.malloc/free和new/delete的区别</h3><ol><li>malloc/free是库函数，需要库支持，而new/delete是C++的关键字，需要编译器支持</li><li>new相比malloc<strong>内置sizeof</strong>、<strong>类型转换</strong>、<strong>安全检查等</strong>功能，更简单更安全</li><li>new/delete可以分别调用构造和析构函数，而malloc/free不可以</li><li>分配内存失败，前者返回NULL，后者抛出异常</li></ol><hr><h3 id="5-如何减少因为手动申请和释放内存，带来的内存碎片"><a href="#5-如何减少因为手动申请和释放内存，带来的内存碎片" class="headerlink" title="5.如何减少因为手动申请和释放内存，带来的内存碎片"></a>5.如何减少因为手动申请和释放内存，带来的内存碎片</h3><ul><li>采用内存池来实现内存的管理（先从内存池中拿，不够的话再去申请新的）</li><li>定义：内存池是一种内存分配的方式。在申请动态内存时，预先申请分配一些内存块做备用。如果申请内存就从内存池中拿内存块分配，不够再申请新的内存。</li><li>优点：尽量避免内存碎片，提高内存分配效率</li></ul><hr><h3 id="6-C-怎么定义常量，常量存放在哪个位置"><a href="#6-C-怎么定义常量，常量存放在哪个位置" class="headerlink" title="6.C++怎么定义常量，常量存放在哪个位置"></a>6.C++怎么定义常量，常量存放在哪个位置</h3><ul><li>E栈区—存放函数局部变量，形参和函数返回值等</li><li>D堆区—存放 malloc 和 new 自己开辟的内存————手动申请和释放</li><li>C静态区（全局区）—存放静态变量和全局变量</li><li>B常量区—存放常量，如：10，字符串常量等等</li><li>A代码区—存放程序代码</li></ul><p>局部变量：栈区  </p><p>全局常量：全局区 / 静态区，对于全局变量，编译期一般不分配内存，放在符号表中以提高访问效率</p><p>字符串常量：常量区</p><hr><h2 id="指针-、const、static、extern"><a href="#指针-、const、static、extern" class="headerlink" title="指针*、const、static、extern"></a>指针*、const、static、extern</h2><h3 id="1-引用和指针的区别"><a href="#1-引用和指针的区别" class="headerlink" title="1.引用和指针的区别"></a>1.引用和指针的区别</h3><ol><li>指针是对象的地址，有自己的空间，<ul><li>所以初始化指针可以为NULL。而引用是对象的别名，没有自己内存空间，必须实例化。</li></ul></li><li>有指向指针的指针，但是没有引用的引用，引用的对象必须是实体</li><li>使用时：<ul><li>3.1指针可以改变指向别的对象，而引用不可以改变</li><li>3.2引用可以直接操作对象，而指针需要解引</li><li>3.3引用++，和指针++意义完全不同</li></ul></li><li>如果返回动态分配的对象或者内存，必须使用指针，引用可能产生内存泄漏</li></ol><hr><h3 id="2-指针作为参数传递时：const修饰函数形参指针"><a href="#2-指针作为参数传递时：const修饰函数形参指针" class="headerlink" title="2.指针作为参数传递时：const修饰函数形参指针"></a>2.指针作为参数传递时：const修饰函数形参指针</h3><ul><li>告诉函数传入的形参不会发生变化。</li><li>当传入的是地址的话，最好使用const形参，否则const指针不能做实参。这样可以增加函数的<strong>兼容性</strong><ul><li>既兼容常指针和非常指针两种类型<strong>int* <em><em>和 *</em>const int</em></strong></li></ul></li></ul><hr><h3 id="3-类中的const—const成员函数，const类成员变量"><a href="#3-类中的const—const成员函数，const类成员变量" class="headerlink" title="3.类中的const—const成员函数，const类成员变量"></a>3.类中的const—const成员函数，const类成员变量</h3><ul><li><p>const成员变量：类内定义，只在每个类对象初始化时候定义，<strong>不能直接初始化，依靠初始化成员</strong>。</p></li><li><p>static成员变量：类内定义，类外实现。</p></li><li><p>const成员函数：他暂时修改了类中this指针的状态，顶层和底层都为const指针，所以所指向的对象都无法修改。为有些不改变值的函数提供便利。</p><hr></li></ul><h3 id="4-顶层const和底层const"><a href="#4-顶层const和底层const" class="headerlink" title="4.顶层const和底层const"></a>4.顶层const和底层const</h3><p>const    *pi————底层const——指针指向常量</p><p>*pi   const   ————顶层const——指针为常指针</p><ul><li><blockquote><p>作用1：</p></blockquote><ul><li><strong>常量的底层const</strong>   不能赋值给  <strong>非常量的底层const</strong></li><li>非常量的底层const  = 常量的底层const   <strong>错误</strong>   </li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num_c = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p_c = &amp;num_c;  <span class="comment">//p_c为底层const的指针</span></span><br><span class="line"><span class="comment">//int *p_d = p_c;  //错误，不能将底层const指针赋值给非底层const指针</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p_d = p_c; <span class="comment">//正确，可以将底层const指针复制给底层const指针</span></span><br></pre></td></tr></table></figure><ul><li><blockquote><p>作用2：</p></blockquote><ul><li>const_cast只能移除底层const对象的特性</li><li>底层const指针不能赋值给非底层const指针。</li></ul></li></ul><p>const_cast强制类型转换，只能移除底层const。</p><hr><h3 id="5-extern关键词的作用"><a href="#5-extern关键词的作用" class="headerlink" title="5.extern关键词的作用"></a>5.extern关键词的作用</h3><ul><li>关键词extern用于声明全局变量和全局函数，让编译器可以跨文件找到他</li><li>为了<strong>兼容C++和C的混合编译</strong>。由于<strong>C++增加了重载函数</strong>，编译器会将函数名和形参生成一个中间变量，而C编译器不会考虑这个问题。为了解决编译器的兼容问题。</li></ul><hr><h3 id="6-static关键词的作用"><a href="#6-static关键词的作用" class="headerlink" title="6.static关键词的作用"></a>6.static关键词的作用</h3><ul><li><blockquote><p>类外：</p></blockquote><ul><li>隐藏函数，避免冲突——static变量和函数对其他源文件是隐藏的</li><li>静态对象只需要一次赋值，减少工作量</li><li>静态变量具有<strong>持久性</strong>，在程序退出时才会释放</li></ul></li><li><blockquote><p>类内：</p></blockquote><ul><li>类中静态函数和成员变量是为整个类服务，不与单个类对象服务</li><li>静态成员变量类内声明，类外定义</li><li>类静态函数无需初始化类对象，直接可以调用。同时无类中非静态成员，需要通过辅助指针来实现全类的访问。（写过相机的类，回调函数为static）</li></ul></li></ul><hr><h2 id="C-11特性、类、多态"><a href="#C-11特性、类、多态" class="headerlink" title="C++11特性、类、多态"></a>C++11特性、类、多态</h2><h3 id="1-C-的封装、继承、多态"><a href="#1-C-的封装、继承、多态" class="headerlink" title="1.C++的封装、继承、多态"></a>1.C++的封装、继承、多态</h3><ul><li><p>封装的作用：规定访问权限，保证数据的完整性和安全性。同时让代码更加直观</p></li><li><p>继承的作用：继承是多态的前提，是C++面向对象的重要体现，泛型编程的前提保证</p><ul><li>在父类的基础上定义子类，<strong>升级和改造父类的功能</strong>，实现<strong>代码复用</strong>，可以很好的提高<strong>代码的复用率</strong>。 </li></ul></li><li><p>多态的作用：多态分为静态多态和动态多态。</p><ul><li>前者：主要依靠函数重载和函数模板、类模板实现。<ul><li>后者：依靠子类对父类虚函数的重写，在使用父类指针指向子类对象时函数的动态绑定实现。</li><li>结果：提高代码的拓展性和维护性</li></ul></li></ul></li></ul><hr><h3 id="2-左值引用和右值引用"><a href="#2-左值引用和右值引用" class="headerlink" title="2.左值引用和右值引用"></a>2.左值引用和右值引用</h3><ul><li><blockquote><p>左值引用：首先有明确地址的为左值，无的明确地址为右值。</p></blockquote><ul><li>我们可以<strong>利用左值引用将左值转换为右值</strong>，这样就可以直接将左值引用作为函数的形参输入，避免一些不要要的临时对象拷贝和构造。</li></ul></li></ul><ul><li><blockquote><p>右值引用：顾名思义，是对右值的引用，还是右值</p></blockquote><ul><li>C++利用右值引用是为了<strong>减少对象初始化时</strong>，所属需要的时间。<strong>我们可以理解成复制和剪切的关系。</strong> </li><li>通过<strong>移动构造</strong>，利用生命值周期短的右值来初始化对象。避免了不必要的构造和拷贝构造，释放等步骤。（指针直接指向自己）</li></ul></li><li><blockquote><p>补充：</p></blockquote><ul><li>有些生命周期短的右值，可以通过move函数，将其变为右值，从而移动构造。</li><li>完美转发：函数输入的是左值或右值，输出值还保持原来的特性，它是完美的。</li></ul></li></ul><hr><h3 id="3-vector中push-back-和emplace-back-区别"><a href="#3-vector中push-back-和emplace-back-区别" class="headerlink" title="3.vector中push_back()和emplace_back()区别"></a>3.vector中push_back()和emplace_back()区别</h3><ul><li><p>C++中未加入右值引用时候，我们常常利用push_back来给容器插入元素：</p><ul><li>1.构造函数——构造这个临时变量</li><li>2.拷贝构造——将元素拷贝入容器</li><li>3.释放临时变量</li></ul></li><li><p>加入右值引用后，push_back优化版本：</p><ul><li>1.构造函数——构造这个临时变量</li><li>2.移动构造——将元素转移到容器，无需释放</li></ul></li><li><p>emplace_back()</p><ul><li>容器内原地构造——不需要拷贝和移动，节省了资源开销</li></ul></li></ul><hr><h3 id="4-泛型编程（静态多态）"><a href="#4-泛型编程（静态多态）" class="headerlink" title="4.泛型编程（静态多态）"></a>4.泛型编程（静态多态）</h3><ul><li><p>泛型编程指的是满足<strong>多种类型</strong>的<strong>代码编写方式</strong>。静态的多态</p></li><li><p>在C++中，<strong>模板</strong>是泛型编程的基础，模板是创建函数和类的公式。</p></li><li><blockquote><p>我们常用的泛型编程方式是，函数重载，函数模板和类模板</p></blockquote><ul><li>标准函数库中的容器、迭代器、算法都是泛型编程很好的例子。</li></ul></li></ul><hr><h3 id="5-C-四种cast类型转换"><a href="#5-C-四种cast类型转换" class="headerlink" title="5.C++四种cast类型转换"></a>5.C++四种cast类型转换</h3><ol><li><p>const_cast    ————        用于移除类型const特性</p></li><li><p>static_cast       ————     只能用于满足隐式类型转换间的类型，当用于类型下行转换时，不安全，如有的const类型无法转换。</p></li><li><p>dynamic_cast            ————用于父类指针向子类指针的转换，只能用于含有虚函数的类，只能转指针和引用，包含继承检查，所以是安全的</p></li><li><p>reinterpret_cast    ————    几乎什么都能转换，但是不安全</p></li></ol><hr><h3 id="6-C-四种智能指针"><a href="#6-C-四种智能指针" class="headerlink" title="6.C++四种智能指针"></a>6.C++四种智能指针</h3><ul><li>作用：都是为了更好的管理堆上的资源——自动释放内存资源</li><li>方法：将指针放入管理的对象中，类似析构函数的调用，保证局部对象被析构从而释放资源</li><li>最常用：shared_ptr</li></ul><ol><li>auto_ptr，只能管理一个对象，不能在容器中使用</li><li>shared_ptr（引用计数型），但是要避免成环<ul><li>优点：解决了多个智能指针间共享对象所有权的问题，也满足了容器对元素的要求，可以在STL容器中使用。</li></ul></li><li>weak_ptr（弱引用，share的助手，配合share使用），解决share死锁问题</li><li>unique_ptr（独占型指针，只允许同一时间内一个智能指针指向该对象。当unique_ptr被销毁，其所指的对象也被销毁。显示了一种独占的思想）</li></ol><hr><h3 id="7-父类析构函数为什么需要虚函数，而析构函数不是？"><a href="#7-父类析构函数为什么需要虚函数，而析构函数不是？" class="headerlink" title="7.父类析构函数为什么需要虚函数，而析构函数不是？"></a>7.父类析构函数为什么需要虚函数，而析构函数不是？</h3><ul><li><blockquote><p>是为了更好的释放子类，防止在释放内存时产生内存泄漏。当父类指针指向子类时，如果父类析构函数不是虚函数，会导致子类释放释放的不彻底，导致内存泄漏</p></blockquote></li><li><blockquote><p>同时虚函数也会产生额外的内存开销，所以没必要是不用的。</p></blockquote></li><li><blockquote><p>虚函数的实现：</p></blockquote><ul><li>在有虚函数的类中，类的最开始部分是一个虚函数表的指针，表中存放了虚函数的地址。</li></ul></li><li><p>重写虚函数时会替换虚函数表中的地址）</p></li><li><p>子类继承父类时也会继承其虚函数表，当子类重写父类中虚函数时，会将继承到的虚函数地址重新替换为新的重写地址。</p></li></ul><hr><h3 id="8-说一下析构函数？"><a href="#8-说一下析构函数？" class="headerlink" title="8.说一下析构函数？"></a>8.说一下析构函数？</h3><ul><li><blockquote><p>析构函数在类对象消亡的时候，自动调用，用于释放内存。</p></blockquote><ul><li>析构函数名称和构造函数相同，前方加取反号，不带任何返回值，不能被重载。</li><li>作为父类的类，析构函数必须是虚函数，防止内存泄漏</li><li>构造和析构的顺序依次ABBA。（A父类B子类）</li></ul></li></ul><hr><h3 id="9-说一下重载和重写？"><a href="#9-说一下重载和重写？" class="headerlink" title="9.说一下重载和重写？"></a>9.说一下重载和重写？</h3><ul><li><blockquote><p>都是C++多态的实现方式</p></blockquote><ul><li>区别在于重载是静态编译时的多态性，而重写是运行时动态的多态性。</li><li>重载在<strong>一个类中</strong>：函数名相同的函数，但是形参列表不同。返回值没有要求。</li><li>重写<strong>子类父类中</strong>：子类继承父类，对父类中的虚函数进行重新定义。</li></ul></li></ul><hr><h3 id="10-说一下多态？"><a href="#10-说一下多态？" class="headerlink" title="10.说一下多态？"></a>10.说一下多态？</h3><ul><li>多态主要分为静态和动态两种。</li><li>静态多态主要靠重载和C++模板来实现，在编译时已经确定，需要程序员实例化。</li><li>动态多态主要靠虚函数来实现，虚函数在运行期间动态绑定子类对象。</li></ul><p>实现了动态联编，使程序运行效率更高，更容易维护和操作。</p><hr><h3 id="11-说一下RTTI—Run-time-type-identification"><a href="#11-说一下RTTI—Run-time-type-identification" class="headerlink" title="11.说一下RTTI—Run time type identification"></a>11.说一下RTTI—Run time type identification</h3><ul><li>RTTI意思：运行时类型识别—（静态类型在程序运行时，不会发生变化，所以不需要）</li><li>C++引入这个机制：目的让程序在运行能够根据父类的指针或引用  来获得该指针或引用所指对象的实际类型。</li><li>C++主要通过typeid运算符和dynamic_cast运算符来表现</li><li>typeid：返回其表达式或类型名的实际类型</li><li>dynamic_cast：实现父类指针与子类指针相互转换（向下），若失败返回NULL—转换存在不安全，其可以保证</li></ul><hr><h3 id="12-拷贝构造函数Person-A（a）和拷贝赋值函数-A-B-的形参可以进行值传递吗"><a href="#12-拷贝构造函数Person-A（a）和拷贝赋值函数-A-B-的形参可以进行值传递吗" class="headerlink" title="12.拷贝构造函数Person A（a）和拷贝赋值函数 A = B 的形参可以进行值传递吗"></a>12.拷贝构造函数Person A（a）和拷贝赋值函数 A = B 的形参可以进行值传递吗</h3><ul><li><blockquote><p>不可以，（必须是引用&amp;）这样的话会无限循环下去。</p></blockquote><ul><li>原因：为了调用拷贝构造进行<strong>值传递</strong>，必须创建它的副本，这样导致无线调用构造函数，导致栈溢出</li></ul></li></ul><hr><h3 id="13-说一下C-——struct和class的区别"><a href="#13-说一下C-——struct和class的区别" class="headerlink" title="13.说一下C++——struct和class的区别"></a>13.说一下C++——struct和class的区别</h3><ul><li>在实际的使用中：</li><li>我们常常：struct适合看成一个数据结构的实现体——零件信息，而class适合看成一个对象的实现体——相机类，各种接口。</li></ul><ol><li>默认继承权限和访问权限：</li></ol><ul><li>struct：public</li><li>class：private</li></ul><ol start="2"><li>类模板等关键字也只能使用class</li><li>C++保留struct是为了更好得去兼容C语言</li></ol><hr><h3 id="14-说一下C-11有哪些新特性"><a href="#14-说一下C-11有哪些新特性" class="headerlink" title="14.说一下C++11有哪些新特性"></a>14.说一下C++11有哪些新特性</h3><ol><li>auto关键字，编译器可以根据初始值自动推导出参数类型</li><li>nullptr关键字，减少二义性，C++中的空指针关键字，用于区分NULL和0</li><li>智能指针，shared_ptr,auto_ptr，用于解决内存管理问题</li><li>初始化列表，对类进行初始化</li><li>右值引用：基于右值引用可以实现移动 语句和完美转发，消除没有必要的资源拷贝，资源开销</li><li>atomic原子操作用于多线程资源互斥操作</li><li>新增STL容器array以及tuple</li><li>匿名函数</li></ol><hr><h3 id="15-为什么构造函数不能是虚函数？"><a href="#15-为什么构造函数不能是虚函数？" class="headerlink" title="15.为什么构造函数不能是虚函数？"></a>15.为什么构造函数不能是虚函数？</h3><ul><li><blockquote><p>存储角度：首先虚函数是通过<strong>虚函数表来调用的</strong>，而对象还没有实例化，根本不存在虚函数表，如何去调用函数。</p></blockquote></li><li><blockquote><p>使用角度：虚函数是在类型不明确的情况下，通过父类指针指向子类对象从而实现虚函数的重写。但是构造函数是需要在类型明确的情况下调用的，两者是矛盾的。（一个明确类型，一个不是）</p></blockquote></li></ul>]]></content>
      
      
      <categories>
          
          <category> learn </category>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode / 35. 搜索插入位置</title>
      <link href="/2020/07/17/leetcode3/"/>
      <url>/2020/07/17/leetcode3/</url>
      
        <content type="html"><![CDATA[<h2 id="35-搜索插入位置"><a href="#35-搜索插入位置" class="headerlink" title=" 35. 搜索插入位置"></a><font size=6> 35. 搜索插入位置</font></h2><p> <code>题目</code></p><ul><li>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</li></ul><hr><p><code>理解</code>：最基础的二分搜索</p><ul><li><blockquote><p>while(left &lt; right)</p></blockquote></li><li><blockquote><p>int mid = (right +left) &gt;&gt; 1 —————————-  向下取整</p></blockquote></li><li><blockquote><p>if(target &lt; num[mid])  left = mid + 1;—————-这样不会陷入死循环</p></blockquote></li><li><blockquote><p>else right = mid;</p></blockquote></li></ul><p><code>例题</code></p><p>输入: [1,3,5,6], 5</p><p>输出: 2</p><p>输入: [1,3,5,6], 2</p><p>输出: 1</p><p><code>解题</code></p><ul><li><blockquote><p>二分法</p></blockquote></li></ul><hr><p><code>代码</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(len==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(target &gt; nums[len - <span class="number">1</span>])<span class="keyword">return</span> len;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = len - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="comment">//int mid = (left + right) &gt;&gt;1;   //向下取整 </span></span><br><span class="line">            <span class="keyword">int</span> mid = left + (right-left)/<span class="number">2</span>; </span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target)&#123;</span><br><span class="line">                <span class="keyword">return</span> mid ;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; target)&#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
          <category> 35.搜索插入位置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分查找 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode / 785. 判断二分图</title>
      <link href="/2020/07/16/leetcode2/"/>
      <url>/2020/07/16/leetcode2/</url>
      
        <content type="html"><![CDATA[<h2 id="785-判断二分图"><a href="#785-判断二分图" class="headerlink" title=" 785. 判断二分图"></a><font size=6> 785. 判断二分图</font></h2><p> <code>题目</code></p><ul><li><p>给定一个无向图graph，当这个图为二分图时返回true。</p></li><li><p>如果我们能将一个图的节点集合分割成两个独立的子集A和B，并使图中的每一条边的两个节点一个来自A集合，一个来自B集合，我们就将这个图称为二分图。</p></li><li><p>graph将会以邻接表方式给出，graph[i]表示图中与节点i相连的所有节点。每个节点都是一个在0到graph.length-1之间的整数。这图中没有自环和平行边： graph[i] 中不存在i，并且graph[i]中没有重复的值。</p></li></ul><hr><p><code>理解</code>：graph[i]代表i结点所相连接的所有节点</p><p><code>二分图理解</code>：</p><ul><li>二分图：顶点由两个<strong>集合A</strong>和<strong>集合B</strong>组成，且所有边的两个顶点正好分别处于两个集合里</li><li>更形象化地去表示：我们可以用两种颜色代表这两个集合，相邻的顶点不能是同一种颜色</li><li>下图右边例子：<ol><li>对顶点0来说，1、2、3和它相邻所以不同色，</li><li>对顶点1，2来说，1和2因此同色，不是二分图</li></ol></li></ul><p><img src="/pictures/clipboard17.png" alt="img1"></p><p><strong>总结</strong>：将点到点的集合——划分为不相交的两个子集（点在两个子集和里），同时所对应的两个   顶点i  和  顶点j  分别在不同的集合中。</p><p><code>例题</code></p><p><img src="/pictures/clipboard18.png" alt="img1"></p><p><code>解题</code></p><ul><li><blockquote><p>动态规划：题解如上，分个数讨论，依次从1、2、3、4往上，在前者的基础上讨论现在的可能情况</p></blockquote></li></ul><hr><p><code>代码</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//-1——未染色</span></span><br><span class="line"><span class="comment">// 0——染为0</span></span><br><span class="line"><span class="comment">// 1——染为1</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isBipartite</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; graph)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = graph.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v</span><span class="params">(n, <span class="number">-1</span>)</span></span>;        <span class="comment">// 给所有节点标记为 -1（未染色）</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123; <span class="comment">// 依次遍历每一个节点</span></span><br><span class="line"><span class="keyword">if</span> (v[i] == <span class="number">-1</span>) &#123; <span class="comment">// 未染色入栈进行操作</span></span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">q.push(i);</span><br><span class="line">v[i] = <span class="number">0</span>;   <span class="comment">//将其染为0</span></span><br><span class="line"><span class="keyword">while</span> (!q.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> cur = q.front();                <span class="comment">//当前节点颜色</span></span><br><span class="line"><span class="keyword">int</span> cur_neighbor = (v[cur] == <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>);<span class="comment">// 记录接下来相邻节点要染的另一种颜色    </span></span><br><span class="line">q.pop();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> node_neighbor : graph[cur]) <span class="comment">// 遍历节点node的相邻节点</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (v[node_neighbor] == <span class="number">-1</span>)   <span class="comment">//没染色，进行染色，同时入栈</span></span><br><span class="line">&#123;</span><br><span class="line">q.push(node_neighbor);</span><br><span class="line">v[node_neighbor] = cur_neighbor;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (v[node_neighbor] != cur_neighbor) <span class="comment">//染色了，若颜色相同，说明在同一个子集里</span></span><br><span class="line"><span class="comment">// 相邻节点染色 不是 cur_neighbor</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
          <category> 785.判断二分图 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode / 120. 三角形最小路径和</title>
      <link href="/2020/07/16/leetcode1/"/>
      <url>/2020/07/16/leetcode1/</url>
      
        <content type="html"><![CDATA[<h2 id="120-三角形最小路径和"><a href="#120-三角形最小路径和" class="headerlink" title=" 120.三角形最小路径和"></a><font size=6> 120.三角形最小路径和</font></h2><p> <code>题目</code></p><ul><li>给定一个整数 n，求以 1 … n 为节点组成的二叉搜索树有多少种？</li></ul><p><code>例题</code></p><ul><li><p>[</p></li><li><p>[ <strong>2</strong> ],</p></li><li><p>[<strong>3</strong> , 4 ],</p></li><li><p>[6 , <strong>5</strong> , 7 ],</p></li><li><p>[ 4 , <strong>1</strong>  ,8 , 3 ]</p></li><li><p>]</p></li></ul><p>自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。</p><p><code>解题</code></p><ul><li><blockquote><p>动态规划：从上或者从下依次往上遍历，直到走到终点，比较最短的路程。</p></blockquote></li></ul><p><img src="/pictures/clipboard14.png" alt="img1"></p><ul><li><blockquote><p>可以发现：从上—除了两侧的只有一条路来  /  从下—都是有两条路来</p></blockquote></li><li><p>从上到下</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">第一个：res[i][0] = res[i-1][0] + triangle[i][0];</span><br><span class="line">中间的：res[i][j] = triangle[i][j] + min(res[i-1][j-1],res[i-1][j]);</span><br><span class="line">最后个：res[i][i]  = res[i-1][i-1] + triangle[i][i];</span><br></pre></td></tr></table></figure><ul><li>从下到上</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">triangle[i][j] += min(triangle[i+1][j],triangle[i+1][j+1]);</span><br></pre></td></tr></table></figure><hr><p><code>代码</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minimumTotal</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; triangle)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> lenX = triangle.<span class="built_in">size</span>();</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;res(lenX, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(lenX, <span class="number">0</span>));</span><br><span class="line">res[<span class="number">0</span>][<span class="number">0</span>] = triangle[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; lenX; i++) &#123;</span><br><span class="line"><span class="comment">//第一个数据</span></span><br><span class="line"><span class="keyword">int</span> temp = i;</span><br><span class="line">res[i][<span class="number">0</span>] = res[i - <span class="number">1</span>][<span class="number">0</span>] + triangle[i][<span class="number">0</span>];</span><br><span class="line"><span class="comment">//中间数据</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; temp; j++) &#123;</span><br><span class="line">res[i][j] = triangle[i][j] + <span class="built_in">min</span>(res[i - <span class="number">1</span>][j - <span class="number">1</span>], res[i - <span class="number">1</span>][j]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//最后一个数据</span></span><br><span class="line">res[i][temp] = res[i - <span class="number">1</span>][temp - <span class="number">1</span>] + triangle[i][temp];</span><br><span class="line">&#125;</span><br><span class="line">sort(res.back().<span class="built_in">begin</span>(), res.back().<span class="built_in">end</span>());</span><br><span class="line"><span class="keyword">return</span> res.back()[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minimumTotal</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; triangle)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = triangle.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; j++) &#123;</span><br><span class="line">triangle[i][j] += <span class="built_in">min</span>(triangle[i + <span class="number">1</span>][j], triangle[i + <span class="number">1</span>][j + <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> triangle[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
          <category> 120.三角形最小路径和 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode / 96. 不同的二叉搜索树</title>
      <link href="/2020/07/16/leetcode/"/>
      <url>/2020/07/16/leetcode/</url>
      
        <content type="html"><![CDATA[<h2 id="96-不同的二叉搜索树"><a href="#96-不同的二叉搜索树" class="headerlink" title=" 96. 不同的二叉搜索树"></a><font size=6> 96. 不同的二叉搜索树</font></h2><p> <code>题目</code></p><ul><li>给定一个整数 n，求以 1 … n 为节点组成的二叉搜索树有多少种？</li></ul><p><code>例题</code></p><p><img src="/pictures/clipboard15.png" alt="img1"></p><p><code>解题</code></p><ul><li><blockquote><p>动态规划：题解如上，分个数讨论，依次从1、2、3、4往上，在前者的基础上讨论现在的可能情况</p></blockquote></li></ul><hr><p><code>代码</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">2</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;dp(n + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="comment">//求dp[3]——— 02 11 20</span></span><br><span class="line">dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">dp[i] += dp[j] * dp[i - j - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><ul><li><blockquote><p>类似题型</p></blockquote></li></ul><h2 id="22-括号的生成"><a href="#22-括号的生成" class="headerlink" title=" 22.括号的生成"></a><font size=6> 22.括号的生成</font></h2><p> <code>题目</code></p><ul><li>数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。</li></ul><p><code>例题</code></p><ul><li>输入：n = 3</li><li>输出：</li></ul><p><img src="/pictures/clipboard16.png" alt="img1"></p><p><code>代码</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> &#123; <span class="string">""</span> &#125;;</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">1</span>)<span class="keyword">return</span> &#123; <span class="string">"()"</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt;dp(n + <span class="number">1</span>);</span><br><span class="line">dp[<span class="number">0</span>] = &#123; <span class="string">""</span> &#125;;</span><br><span class="line">dp[<span class="number">1</span>] = &#123; <span class="string">"()"</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">string</span> p : dp[j]) &#123;     <span class="comment">//左和右的不同组合，添加到vector中去，使用vector添加</span></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">string</span> q : dp[i - j - <span class="number">1</span>]) &#123;</span><br><span class="line"><span class="built_in">string</span> str = <span class="string">"("</span> + p + <span class="string">")"</span> + q;</span><br><span class="line">dp[i].push_back(str);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
          <category> 96.不同的二叉搜索树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基础概念 / 计算机网络</title>
      <link href="/2020/07/14/714/"/>
      <url>/2020/07/14/714/</url>
      
        <content type="html"><![CDATA[<h2 id="计算机网络的核心就是网络协议（如TCP-IP协议）"><a href="#计算机网络的核心就是网络协议（如TCP-IP协议）" class="headerlink" title="计算机网络的核心就是网络协议（如TCP / IP协议）"></a>计算机网络的核心就是网络协议（如TCP / IP协议）</h2><p>网络协议：规定着网络中<strong>数据交换</strong>的规则。用户间的数据终端是不同的，所以必须建立在一定的标准上计算机才能在网络中交互。</p><p>————<strong>建立网络通信规则、实现用户间的交互</strong>————</p><p><img src="/pictures/clipboard6.png" alt="img1"><br><img src="/pictures/clipboard7.png" alt="img1"></p><ol start="7"><li>应用层：为操作系统或网络应用程序提供访问网络的服务接口—提供进程访问网络的接口</li><li>表示层：对传送的数据进行处理，包括转换、压缩、加密等，以保证被其他应用层理解（数据表示）</li><li>会话`：在传输层基础上，帮助进程建立、管理对话——主机间通信</li><li>传输层：通过流量控制、差错控制等，健壮IP协议不可靠的传输，同时实现进程间端口到端口的传输</li><li>网络层：在数据链路层基础上，提供主机端到端的传输服务—路径选择、优化传输IP数据报</li><li>数据链路层：数据组合成块，提供网络层到网络层的数据帧传输</li><li>物理层：提供硬件支持，解决通讯设备间的物理差异，将数据转换为比特流传输</li></ol><hr><h2 id="网络层的划分"><a href="#网络层的划分" class="headerlink" title="网络层的划分"></a>网络层的划分</h2><p>为了让不同型号的计算机可以互相通信，提出了开放系统互连 / 参考模型。即OSI / RM模型。Open system interconnect / Reference Model。</p><p>主要有七层，从下到上：物理层、数据链路层、网络层、传输层、会话表示应用层。</p><p><strong>开放系统互连，OSI各层的划分</strong></p><hr><h3 id="物理层："><a href="#物理层：" class="headerlink" title="物理层："></a>物理层：</h3><p> <strong>提供硬件支持，消除设备差异，转化为比特流传输</strong></p><p> <code>定义</code>：硬件层，给上层接口提供物理传输媒介，解决不同通讯设备间的信号差异，将数据转换为比特流传输。</p><p> <code>设备</code>：集线器（扩大信号、增加接口）、中继器（扩大信号）</p><hr><h3 id="数据链路层："><a href="#数据链路层：" class="headerlink" title="数据链路层："></a>数据链路层：</h3><p> <strong>提供网络层到网络层的数据帧传输（帧转发）</strong></p><p> <code>定义</code>：为网络层提供可靠的数据传输，将网络层数据可靠传输到目标网络层。</p><p><code>方法</code>：如何数据组合成块，数据链路层我们将数据称为frame帧，在两个网络实体间提供数据链路的建立、维持和释放的管理。</p><p><code>总结</code>：物理寻址，数据成帧，帧转发</p><p><code>设备</code>：网桥（连接LAN之间）、交换机（连接LAN之间）——帧转发</p><hr><h3 id="网络层："><a href="#网络层：" class="headerlink" title="网络层："></a>网络层：</h3><p>数据链路层的基础上，实现主机间<strong>端到端</strong>的数据传输（<code>路径选择</code>、<code>优化传输</code>） </p><p> <code>定义</code>：网络层的目的是实现两个系统之间的端到端的传输，具体功能包括寻址和路由选择、连接的建立、保持和终止等。它提供的服务使传输层不需要了解网络中的数据传输和交换技术。</p><p><code>主要协议</code>：IP协议、地址解析协议ARP、逆RARP，英特网报文协议ICMP、英特网管组协议IGMP</p><p><code>方法</code>：对子网数据包进行路由选择、选择最优达到主机的路径。同时依靠分组交换等技术优化传输。</p><p><code>设备</code>：路由器       传输数据单位：数据包packet——IP数据报</p><h4 id="1-什么是IP协议、IP地址、IP数据报"><a href="#1-什么是IP协议、IP地址、IP数据报" class="headerlink" title="1.什么是IP协议、IP地址、IP数据报"></a>1.什么是IP协议、IP地址、IP数据报</h4><p><code>IP协议</code>：即互联网协议，是TCP / IP协议中的网络层。其目是是为了提高互联网的可拓展性。<br>1.实现互联网的大规模互联互通  2.分割网络应用和网络技术，便于两者的独立发展。根据端到端的设计原则，IP为主机提供一种无连接、不可靠、尽力而为的数据传输。</p><p><code>IP地址</code>：IP协议提供的一种<strong>地址格式</strong>，为互联网上的每一台主机分配一个<strong>逻辑地址</strong>，屏蔽物理地址的差异。32/128</p><p><code>IP数据报</code>：IP协议传输的数据单位，无确认数据包是否完整、按顺序发送等，是不可靠的。包含了发送地址、目标地址。<br>IP地址——电话号码        路由器——电信局的交换机</p><hr><h4 id="2-IP地址的表示"><a href="#2-IP地址的表示" class="headerlink" title="2.IP地址的表示"></a>2.IP地址的表示</h4><ul><li><p>IP地址 = 网络地址 + 主机地址。</p></li><li><p>网络号：用于识别主机所在网络区域    </p></li><li><p>主机号：识别该网络中的哪一台主机<br><img src="/pictures/clipboard8.png" alt="img1"></p><table><thead><tr><th>概念</th><th>特征</th><th>网络范围</th><th>默认子网掩码</th></tr></thead><tbody><tr><td>A类地址</td><td>0XXX  XXXX</td><td>0——127.x.x.x</td><td>255.0.0.0/8</td></tr><tr><td>B类地址</td><td>0XXX  XXXX</td><td>128——191.x.x.x</td><td>255.255.0.0/16</td></tr><tr><td>C类地址</td><td>0XXX  XXXX</td><td>192——223.x.x.x</td><td>255.255.255.0/24</td></tr><tr><td>D类地址</td><td>1110    XXXX</td><td>192——223.x.x.x</td><td>用于组播</td></tr><tr><td>E类地址</td><td>1111    0XXX</td><td>192——223.x.x.x</td><td>用于科研保留</td></tr></tbody></table></li></ul><ul><li><p>127.0.0.1是回环地址，用预测是本地通信。</p></li><li><p>子网掩码：明确区分出IP地址的两部分——网络地址和主机地址（1网络地址、0主机地址）</p></li><li><p>广播地址：专门向网络中所有工作站发送信息的地址</p></li></ul><hr><h4 id="3-IP地址的计算"><a href="#3-IP地址的计算" class="headerlink" title="3.IP地址的计算"></a>3.IP地址的计算</h4><ol><li>区分网络号和主机号——根据子网掩码</li><li>网络地址 =  IP地址 &amp; 子网掩码（全1）  </li><li>广播地址 = 网络地址的基础上，主机位地址全变1</li><li>子网主机个数 = 2^(主机地址位数) - 2（网络地址+广播地址）</li></ol><ul><li>第一个主机IP = 网络地址 + 1</li><li>最后一个主机IP = 广播地址 - 1</li></ul><p><strong>例题1：202.112.14.137/255.255.255.224，计算对应网络地址、广播地址、主机数</strong></p><p>202.112.14.137  ——202_112_14_1000 1001</p><p>255.255.255.224——255_255_255_1110 0000</p><p>网络地址：IP地址的前27位——202.112.14.1000 0000——202.112.14.128</p><p>广播地址：202.112.14.1001 1111</p><p>主机数：2的5次 - 2 = 30台</p><p><strong>例题2：206.110.4 .0/18被划分成16个子网，每个子网掩码多少台主机？</strong></p><p><strong>子网划分的目的</strong>：子网的划分通过不同的子网掩码——解决IPv4地址的紧缺</p><p>解题：206.110.4 .0/18——主机数量 2^(32-18) / 16 = 2^(10)</p><hr><h4 id="3-网络层的地址解析协议"><a href="#3-网络层的地址解析协议" class="headerlink" title="3.网络层的地址解析协议"></a>3.网络层的地址解析协议</h4><p>  <code>ARP地址解析协议</code>——IP地址求MAC地址：主机对网络上的所有主机进行广播，发送包含IP地址的地址解析请求，并保存获得反馈mac地址，从而主机间便可以通信。</p><p><code>RARP逆地址解析协议</code>——向服务器问询自己MAC地址对应的IP地址</p><hr><h4 id="4-网络层的路由选择协议"><a href="#4-网络层的路由选择协议" class="headerlink" title="4.网络层的路由选择协议"></a>4.网络层的路由选择协议</h4><p>  <code>路由选择协议定义</code>：两台非直连的计算机经过几个网络通信时，需要路由器来找寻一条最优化的路线。</p><p><code>RIP路由信息协议</code>：用于网络设备之间交换路由信息，是向量-距离路由选择算法在局域网上的：自接实现。</p><p><code>OSPF开放式最短路经优先协议</code>：OSPF采用的是一种链路-状态算法，并因此克服了RIP协议和其他采用距离矢量算法协议的方法。</p><p>路由协议包括：</p><ul><li><p>IGP内部网关协议——RIP协议_UDP，OSPF协议_IP报文</p></li><li><p>EGP外部网关协议——BGP协议_TCP</p><hr><h4 id="5-ICMP和IGMP—IP协的子协议"><a href="#5-ICMP和IGMP—IP协的子协议" class="headerlink" title="5.ICMP和IGMP—IP协的子协议"></a>5.ICMP和IGMP—IP协的子协议</h4></li></ul><p><code>ICMP—Internet控制报文协议</code>：它是TCP/IP协议簇的一个子协议，用于在IP主机、路由器之间传递控制消息。</p><p><code>IGMP—Internet 组管理协议称为IGMP协议</code>：是因特网协议家族中的一个组播协议。该协议运行在主机和组播路由器之间。IGMP协议共有三个版本，即IGMPv1、v2 和v3。</p><hr><h3 id="传输层："><a href="#传输层：" class="headerlink" title="传输层："></a>传输层：</h3><p>  网络层实现了<strong>端口到端口</strong>的数据传输，而传输层则更近一步提供进程间端口到端口的连接通信。</p><p>  <strong>流量控制（滑动窗口，拥塞窗口）、差错控制（确认重传）、健壮IP不可靠传输</strong></p><ul><li><p>定义：</p><ul><li><p>A_单个主机运行多个进程，所以传输层具有复用和分用功能。</p></li><li><p>B_传输层具有流量控制、差错控制来保证数据传输的可靠性。</p></li><li><p>C_解决和健壮网络层提供的不可靠服务（重复、丢包）</p></li></ul></li><li><p>主要协议：TCP协议（传输控制协议），UDP协议（用户数据报协议）</p></li><li><p>设备：网关，又称协议转换器——用于高层协议不同的网络互联。（数据重新打包，满足不同网络的互联）</p></li></ul><p>实质上是一个网络通向其他网络的IP地址。<br>比如有网络A和网络B，网络A的IP地址范围为“192.168.1.1_192. 168.1.254”，子网掩码为255.255.255.0；网络B的IP地址范围为“192.168.2.1_192.168.2.254”，子网掩码为255.255.255.0。而要实现这两个网络之间的通信，则必须通过网关。</p><hr><h4 id="1-说一下啊TCP-IP协议"><a href="#1-说一下啊TCP-IP协议" class="headerlink" title="1.说一下啊TCP / IP协议"></a>1.说一下啊TCP / IP协议</h4><p>TCP / IP协议是互联网最基本的协议，由网络层的IP协议和传输层的TCP协议组成。</p><p>简单来说：他们分工明确，网络层的IP协议负责数据端到端的传输，将数据从源地址传递到目标地址。</p><p>在此基础上，传输层的TCP协议通过流量控制、差错控制等，健壮IP协议不可靠的传输，同时进一步的实现进程间端口到端口的传输。</p><p>TCP协议：</p><ol><li><p>面向端口到端口的通信协议，通过三次握手建立连接和四次挥手结束连接。</p></li><li><p>是一种可靠的数据流服务，采用“确认重传”技术来实现传输的可靠性。TCP还采用一种称为“滑动窗口”的方式进行流量控制，所谓窗口实际表示接收能力，用以限制发送方的发送速度。</p><p> ————稳定可靠，确认重传，流量控制，快速重传。</p><hr><h4 id="2-TCP报文"><a href="#2-TCP报文" class="headerlink" title="2.TCP报文"></a>2.TCP报文</h4><p><img src="/pictures/clipboard9.png" alt="img1"></p></li></ol><h4 id="3-TCP建立和断开连接—握手握的是双方数据原点的序列号seq"><a href="#3-TCP建立和断开连接—握手握的是双方数据原点的序列号seq" class="headerlink" title="3.TCP建立和断开连接—握手握的是双方数据原点的序列号seq"></a>3.TCP建立和断开连接—握手握的是双方数据原点的序列号seq</h4><p>  <img src="/pictures/clipboard10.png" alt="img1"></p><ul><li><p>ACK:”acknowledge”确认号；SYN:”synchronize”请求同步标志；</p></li><li><p>FIN：”Finally”结束标志；seq:序列号——————都带有序列号</p></li></ul><p><font size=6>建立连接：三次握手</font></p><p>A            SYN  seq=x    -》                     B               </p><p>A        《- ACK  seq=x+1   SYN  seq=y           B     </p><p>A            ACK  seq=y+1    -》                B      </p><ul><li><p><strong>总结</strong>：</p></li><li><p>客户端向服务发送<strong>请求</strong>连接报文,并*<em>同步起始序列号 *</em> </p></li><li><p>服务器收到后，回复<strong>确认</strong>报文，并*<em>同步起始序列号 *</em> </p></li><li><p>客户端收到后也发送<strong>确认</strong>报文。连接建立</p></li></ul><p>**<font size=6>为什么要三次握手？——面向字节的连接，依靠序列号</font> **</p><p>所以建立可靠的连接，需要确认客户端和服务器的起始序列号。而二次握手只确认了客户端的起始序列号。所以不能保证可靠的连接。</p><p><strong>例子</strong>：——客户端请求延迟、服务器回复丢失导致开始无限发送</p><ul><li><p>原理：客户端发送延迟</p></li><li><p>1.浪费资源——客户端发送的请求连接包由于传输问题阻塞，延时传递到了，此时服务器还是会和其建立连接。但是客户端已经放弃了这个连接，而服务器则会为这个连接浪费资源。</p></li><li><p>原理：服务器确认报文丢失</p></li><li><p>2.服务器资源发生死锁——客户端请求连接，服务器回应建立连接。但是服务器的应答传送失败。而服务器认为传递成功，开始传递数据，客户端则不会接收。服务器无线重复发送，资源形成死锁。  </p></li></ul><hr><p>**<font size=6> 断开连接：四次挥手</font> **<br><img src="/pictures/clipboard11.png" alt="img1"></p><ul><li><p>A                FIN  seq=x+2    -》            B</p></li><li><p>A             《- ACK  seq=x+3                B</p></li><li><p>A             《- FIN  seq=y+1                B</p></li><li><p>A                ACK  seq=y+2    -》            B</p></li><li><p>四次挥手：————主动关闭方</p><ul><li><p>1.客户端向服务器发送FIN报文，请求中断——表示我的数据传输完成了</p></li><li><p>2.服务器向客户端发送确认报文——表示当我的数据传输完了再中断</p></li><li><p>客户端进入FIN_WAIT——终止等待状态</p></li><li><p>3.服务器向客户端发送FIN报文——表示我的数据也传输完了</p></li><li><p>4.客户端向服务器发送确认报文，——表示可以断开连接</p></li><li><p>客户端进入TIME_WAIT状态，等待2MSL，确认服务器是否收到了确认报文。如果没收到，客户端会再次发送FIN指令。所以服务器先关闭，后客户端再关闭。</p></li></ul></li></ul><p><strong>重要：如果没有TIME_WAIT状态，最后一次ACK丢失，客户端直接CLOSE，服务器会一直发送FIN</strong></p><p>MSL——报文最大生存周期</p><p>**<font size=6> 为什么要四次挥手？</font> **</p><p>因为服务器和客户端双方<strong>都可以发送和接收数据</strong>，是<strong>全双工模式</strong>，接收到FIN时意味一方完成了数据的收发，但是另一方未知。所以需要保证双方的发送和接收数据都完成了才能断开连接。</p><p>使用TCP的协议：FTP文本传输协议，Telent远程登陆协议，SMTP简单邮件传输协议，POP3邮箱协议，HTTP协议等。</p><hr><h4 id="4-UDP协议——用户数据协议-TCP协议—传输控制协议"><a href="#4-UDP协议——用户数据协议-TCP协议—传输控制协议" class="headerlink" title="4.UDP协议——用户数据协议 / TCP协议—传输控制协议"></a>4.UDP协议——用户数据协议 / TCP协议—传输控制协议</h4><ul><li>UDP协议是用户数据协议，是面向无连接的通讯协议。由于通讯不需要连接，所以可以实现广播发送。</li><li>UDP不需要接收方确认，属于不可靠的连接，可能产生丢包等现象。UDP信息包8个字节，TCP20字节。</li><li>UDP和TCP同属一层，但是它不管数据包的顺序，错误或重发。其主要面向的是那些以查询—应答的服务，如NFS（共享文件）、视频直播等。</li></ul><p>两者区别：</p><ol><li>TCP面向连接的，<strong>可靠的字节流服务</strong></li><li>UDP面向无连接的，<strong>不可靠的数据报服务</strong>——只知道：接收端IP和端口，所以每次只能读取一个报文数据</li></ol><hr><h4 id="5-传输层——NAT协议——网络地址转换协议"><a href="#5-传输层——NAT协议——网络地址转换协议" class="headerlink" title="5.传输层——NAT协议——网络地址转换协议"></a>5.传输层——NAT协议——网络地址转换协议</h4><p>NAT网络协议属于接入广域网的一种技术，将私有地址转换为IP地址，广泛运用于各种互联网接入上。</p><p>网关利用网络地址转换协议，<strong>有效地解决了IP地址不够地问题</strong>，同时也可以避免计算机收到网络的攻击。——（对外隐藏内部IP地址，减少IP减少IP地址产生的费用）</p><ul><li>A类 10.0.0.0/8， 即10.0.0.0–10.255.255.255</li><li>B类 172.16.0.0/12， 即172.16.0.0–172.31.255.255</li><li>C类 192.168.0.0/ 16， 即192.168.0.0–192.168.255.255</li></ul><hr><h3 id="会话层（建立管理对话）、表示层（为应用层翻译）："><a href="#会话层（建立管理对话）、表示层（为应用层翻译）：" class="headerlink" title="会话层（建立管理对话）、表示层（为应用层翻译）："></a>会话层（建立管理对话）、表示层（为应用层翻译）：</h3><p><code>会话层</code>：在传输层基础上，<strong>帮助进程建立并管理对话。</strong></p><p><code>表示层</code>：<strong>对传送的数据进行操作</strong>，包括转换、加密、压缩等，以保证被其他应用层理解。</p><h3 id="应用层："><a href="#应用层：" class="headerlink" title="应用层："></a>应用层：</h3><p><code>定义</code>：为网络进程提供访问网络的接口。同时规定应用在通讯时，所需遵守的协议</p><p><code>数据传输单位</code>：报文</p><p><code>主要协议</code>：FTP文件传送协议，Telnet远程登陆协议，DNS域名解析协议，SMTP邮件传送协议，POP3邮局协议，HTTP超文本传输协议。</p><hr><p><strong>DNS域名解析协议—应用层</strong></p><ul><li><p>DNS域名解析协议：简单来说就是将URL域名转换为IP地址。</p></li><li><p>域名是由圆点分开的一串字母单词组成的，每个域名都对应一个唯一的IP地址。<br>DNS服务器之间传输时使用TCP，而客户端与DNS服务器之间传输时用的是UDP</p></li></ul><hr><p><strong>DHCP协议—应用层协议，使用UDP协议</strong></p><ul><li><p>DHCP动态主机设置协议（Dynamic Host Configuration Protocol）是一个局域网的网络协议，使用UDP协议工作。</p></li><li><p>主要有两个用途：<strong>给内部网络或网络服务供应商自动分配IP地址</strong>，给用户或者内部网络管理员作为对所有计算机作中央管理的手段。</p></li></ul><hr><p><strong>HTTP协议 / 超文本传输协议</strong></p><ul><li><p>是互联网上运用最广泛的一种协议，所有万维网的数据通信必须遵守它。</p></li><li><p>是一个客户端与服务器请求和应答的标准。</p></li><li><p>我们通过浏览器等工具发起http请求到指定服务器，然后获取我们所想要浏览的信息。</p></li></ul><hr><h2 id="具体问题"><a href="#具体问题" class="headerlink" title="具体问题"></a>具体问题</h2><h3 id="问题：1-HTTP协议包括哪些请求？"><a href="#问题：1-HTTP协议包括哪些请求？" class="headerlink" title="问题：1.HTTP协议包括哪些请求？"></a>问题：1.HTTP协议包括哪些请求？</h3><p>主要包括四种和服务器交互的方法：GET、POST、PUT、DELETE</p><p><strong>GET、POST区别：</strong></p><p>理解方式：货车和运输公司的关系，货物放在车顶，车厢内，允许不允许超载，卸货</p><ul><li><p>HTTP协议是基于TCP/IP协议的，GET和POST本质上都是TCP连接。但是其在请求方式上存在差异。</p></li><li><p>GET请求的数据存放在请求URL中，而POST存放在请求包体中</p></li><li><p>一般浏览器对请求URL长度有限制，所以导致GET请求获取的数据一般比POST少</p></li><li><p>同时由于请求数据暴露，所以使得GET的安全性也较低。</p></li><li><p>同时GET请求产生一个TCP数据报，而POST产生两个，对于验证数据的完整性更好。</p></li></ul><p>GET——请求header和请求data一起发送——返回200</p><p>POST——请求header先发送——返回100——再发送请求data——返回200</p><hr><h3 id="2-HTTP的请求和响应"><a href="#2-HTTP的请求和响应" class="headerlink" title="2.HTTP的请求和响应"></a>2.HTTP的请求和响应</h3><p>HTTP请求的格式包含：</p><p>（method—请求方法） （request—URL请求URL） （version—HTTP报文版本）</p><p>（headers—请求头部）</p><p>（entity-body—请求数据）</p><p>HTTP响应的格式包含：</p><p>（version） （status—请求过程状态） （reason-phrase）</p><p>（headers）</p><p>（entity-body）</p><p>常用响应码：</p><p>100——<code>状态码</code>。返回消息</p><p>200—<code>（成功）</code>服务器成功处理请求</p><p>301/302 Moved Permanently—<code>（域名不存在）</code>请求的域名已被移走，这个域名不存在了</p><p>304 Not Modified<code>（未修改）</code> 表示客户所请求的缓存资源是最新的，无需修改</p><p>404 Not Found <code>未找到资源</code></p><p>501 Internal Server Error<code>（服务器遇到错误）</code>服务器发生故障，无法对请求提供服务</p><hr><h3 id="3-数字证书相关问题——网页加密"><a href="#3-数字证书相关问题——网页加密" class="headerlink" title="3.数字证书相关问题——网页加密"></a>3.数字证书相关问题——网页加密</h3><p>数字证书：由证书中心CA的颁布，是网站对应的权威公共钥匙，用于验证网站发送的数字签名。</p><p>客户端       ————请求———&gt;                  服务器</p><p>客户端  &lt;—————数字证书 + 网页———      服务器</p><p>客户端    &lt;—————网页 + 数字签名—————   服务器</p><p>客户端根据数字证书获得的公钥，然后利用公钥验证数字签名，确认是从对应的服务器发送来的数据。</p><p>总结：</p><ul><li>私钥——<strong>用于生成数字签名</strong>  +  解密      </li><li>公钥——*<em>用于验证数字签名 *</em> +  解密</li></ul><hr><h3 id="问题1-浏览器输入域名访问的整个过程"><a href="#问题1-浏览器输入域名访问的整个过程" class="headerlink" title="问题1.浏览器输入域名访问的整个过程"></a>问题1.浏览器输入域名访问的整个过程</h3><p>首先客户端获取URL - &gt; DNS解析 - &gt; </p><p>TCP请求连接 - &gt;客户端发送HTTP请求 - &gt;服务端响应HTTP请求 - &gt;</p><p>浏览器获得html代码 - &gt;浏览器解析html代码，并请求html代码中的资源 - &gt;</p><p>浏览器解析渲染页面 - &gt;</p><p>TCP断开连接<br> <img src="/pictures/clipboard12.png" alt="img1"></p><hr><h3 id="问题2-TCP怎么保证可靠，以及它建立和断开的过程"><a href="#问题2-TCP怎么保证可靠，以及它建立和断开的过程" class="headerlink" title="问题2.TCP怎么保证可靠，以及它建立和断开的过程"></a>问题2.TCP怎么保证可靠，以及它建立和断开的过程</h3><ul><li>1.三次握手和四次挥手保证连接和断开的正确性</li><li>2.校验和：将发送前的数据和发送后数据进行计算，比较结果</li><li>3.确认重传：接收方会告诉发送方接收了到了哪些数据，哪些数据是不完整的需要重新传递，保证数据的完整性。</li><li>4.流量控制：会根据ACK报头的窗口大小进行速度的调整</li><li>5.拥塞窗口：采用慢启动方法，先少量数据探路，再决定多大传输速度。定义了拥塞窗口概念：刚开始为1，逐渐增大，同时会和反馈获得的窗口大小进行比较，取小值</li></ul><p><strong>三次握手建立连接：</strong></p><ul><li>客户端向服务器发送请求连接报文 + 序列号</li><li>服务器收到后向客户端发送确认报文，并同步客户端起始序列号</li><li>客户端向服务器确认其发送序列号，并同步服务器起始序列号</li></ul><p><strong>四次挥手断开连接：</strong></p><p>由于TCP连接是双工模式，即客户端和服务器都可以收发数据，所以需要双方同时满足收发完成，才可以断开连接。</p><ol><li>首先客户端向服务器发送请求终止报文，进入FIN  _WAIT状态——表示我的数据接受完成可以断开</li><li>服务器根据回复确认报文——表示当我的数据接收完成后，再次确认</li><li>服务器数据接收完成后，向客户端发送终止报文——表示我的数据接收完成，可以关闭</li><li>客户端接收到服务器的FIN报文后，进入TIME_WAIT状态，等待两个周期的报文最长生存时间，如果此阶段未收到服务器信息，说明没有问题，断开连接。</li></ol><hr><h3 id="问题3-说一说TCP模型，状态转移"><a href="#问题3-说一说TCP模型，状态转移" class="headerlink" title="问题3.说一说TCP模型，状态转移"></a>问题3.说一说TCP模型，状态转移</h3><p>五层从下到上：物理层，数据链路层，网络层，传输层，应用层</p><p>3次握手建立连接，传输数据，4次挥手断开连接。</p><hr><h3 id="问题3-1请回答一下HTTP和HTTPS的区别，以及HTTPS有什么缺点？"><a href="#问题3-1请回答一下HTTP和HTTPS的区别，以及HTTPS有什么缺点？" class="headerlink" title="问题3.1请回答一下HTTP和HTTPS的区别，以及HTTPS有什么缺点？"></a>问题3.1请回答一下HTTP和HTTPS的区别，以及HTTPS有什么缺点？</h3><ol><li>HTTP协议是以明文的方式在网络中传输的，而HTTPS传输的数据是经过TLS加密的，HTTPS具有更高的安全性</li><li>HTTPS在三次握手之后，需要进行SSL的握手，协商后加密使用的对称加密密钥</li><li>HTTPS需要服务端申请证书，浏览器安装相应证书。</li><li>HTTP协议端口是80，HTTPS是443</li></ol><ul><li>HTTPS优点：A数据加密安全性更高，B协议可以认证用户和服务器，确保数据发送到正确的用户和服务器。</li><li>HTTPS缺点：<ul><li>A：握手阶段增加SSL握手，延时增加</li><li>B：部署成本较高：使用证书来验证安全，需要购买CA证书。</li><li>C：采用HTTPS协议需要进行加密解密计算，对服务器要求也更高</li></ul></li></ul><hr><h3 id="问题3-2请你说一说HTTP返回码"><a href="#问题3-2请你说一说HTTP返回码" class="headerlink" title="问题3.2请你说一说HTTP返回码"></a>问题3.2请你说一说HTTP返回码</h3><ul><li>100——状态码。返回消息</li><li>200—（成功）服务器成功处理请求</li><li>301/302 Moved Permanently—（域名不存在）请求的域名已被移走，这个域名不存在了</li><li>304 Not Modified（未修改） 表示客户所请求的缓存资源是最新的，无需修改</li><li>404 Not Found 未找到资源</li><li>501 Internal Server Error（服务器遇到错误）服务器发生故障，无法对请求提供服务</li></ul><hr><h3 id="问题4-请你说一说IP地址作用，以及MAC地址作用"><a href="#问题4-请你说一说IP地址作用，以及MAC地址作用" class="headerlink" title="问题4.请你说一说IP地址作用，以及MAC地址作用"></a>问题4.请你说一说IP地址作用，以及MAC地址作用</h3><p>MAC地址是一个硬件地址，又称网卡地址，来定义网络设备的位置，由生产制造商写在硬件内部，位于数据链路层。</p><p>IP地址（用逻辑地址屏蔽物理地址）是IP协议提供的一种地址格式，它给每个网络和每台主机分配一个逻辑地址，用于屏蔽物理地址的差异。</p><hr><h3 id="问题5-请回答OSI七层模型和TCP-IP四层模型，每层列举2个协议"><a href="#问题5-请回答OSI七层模型和TCP-IP四层模型，每层列举2个协议" class="headerlink" title="问题5.请回答OSI七层模型和TCP/IP四层模型，每层列举2个协议"></a>问题5.请回答OSI七层模型和TCP/IP四层模型，每层列举2个协议</h3><p>OSI七层模型：</p><ul><li>应用层：为应用程序提网络服务接口。主要协议HTTP，HTTPS，FTP，DNS</li><li>展示层：对数据进行翻译；JPEG ASII</li><li>会话层：建立，管理，终止会话；NFS ，RPC</li><li>传输层：提供端口到端口的可靠报文传递：UDP，TCP</li><li>网络层：提供端到端的传输。传递路径选择和优化传输：IP协议，ARP</li><li>数据链路层：提供点到点的数据帧传递：MAC，VLAN</li><li>物理层：提供硬件支持，消除设备间的物理差异，传输比特流，主要协议RJ45</li></ul><p>TCP/IP模型：</p><ul><li>应用层HTTP  DNS  </li><li>传输层UDP TCP</li><li>网络层IP ARP</li><li>数据链路层：MAC，VLAN</li></ul><hr><h3 id="问题6-输入一个网址，计算机都用到了哪些层"><a href="#问题6-输入一个网址，计算机都用到了哪些层" class="headerlink" title="问题6.输入一个网址，计算机都用到了哪些层"></a>问题6.输入一个网址，计算机都用到了哪些层</h3><p>TCP/IP协议中的五个层都用到了。</p><p>首先客户端获取URL - &gt; DNS解析 - &gt; （应用层的https超文本传输协议，DNS域名解析协议）</p><p>TCP请求连接 - &gt;客户端发送HTTP请求 - &gt;服务端响应HTTP请求 - &gt;</p><p>浏览器获得html代码 - &gt;浏览器解析html代码，并请求html代码中的资源 - &gt;浏览器解析渲染页面 - &gt;</p><p> TCP断开连接</p><p>（传输层的TCP协议 / 网络层的IP协议、ARP地址解析协议）<br>（底层数据的传输用到了数据链路层和物理层，提供硬件支持，同时传递数据）</p><hr><h3 id="问题7-说一下TCP中的拥塞控制？说明时候开始慢慢增长"><a href="#问题7-说一下TCP中的拥塞控制？说明时候开始慢慢增长" class="headerlink" title="问题7.说一下TCP中的拥塞控制？说明时候开始慢慢增长"></a>问题7.说一下TCP中的拥塞控制？说明时候开始慢慢增长</h3><ul><li><p>网络层：路径选择、流量控制</p></li><li><p>传输层：确认重传、滑动窗口、拥塞控制</p></li><li><p>拥塞：是防止服务器和客户端之间过多的数据传输，使得网络中的路由器和链路发生过载而瘫痪。</p><ol><li><p>首先慢开始 ，出现拥塞情况，慢启动极限变为一半，拥塞窗口重新从0开始增加）</p></li><li><p>快速重传和快速恢复</p></li></ol></li></ul><hr><h3 id="问题8-说一下数据链路层的交互过程）——-通过MAC地址交互"><a href="#问题8-说一下数据链路层的交互过程）——-通过MAC地址交互" class="headerlink" title="问题8.说一下数据链路层的交互过程）—— 通过MAC地址交互"></a>问题8.说一下数据链路层的交互过程）—— 通过MAC地址交互</h3><p>网络层到数据链路层采用MAC地址作为通信地址。</p><p>数据包从网络层准备发往数据链路层时，首先会去地址缓存表中查找相应的ip_mac对应关系表，如果查到了就将ip的mac地址封装到链路层数据包的包头。</p><p>如果没有，就采用<strong>广播的形式</strong>，查找相应ip的mac地址，相应的主机收到广播后会回复自己IP对应得mac地址。</p><hr><h3 id="问题9-说一下数据传递到IP层如何知道报文传递给哪个应用程序，它怎么区分UDP还是TCP报文"><a href="#问题9-说一下数据传递到IP层如何知道报文传递给哪个应用程序，它怎么区分UDP还是TCP报文" class="headerlink" title="问题9.说一下数据传递到IP层如何知道报文传递给哪个应用程序，它怎么区分UDP还是TCP报文"></a>问题9.说一下数据传递到IP层如何知道报文传递给哪个应用程序，它怎么区分UDP还是TCP报文</h3><p>根据端口区分给哪个应用。</p><p>根据报文头中的协议标识字段，17 / UDP，6 / TCP</p><hr><h3 id="问题10-SOCKET具体的网络层是如何操作的"><a href="#问题10-SOCKET具体的网络层是如何操作的" class="headerlink" title="问题10.SOCKET具体的网络层是如何操作的"></a>问题10.SOCKET具体的网络层是如何操作的</h3><p> <img src="/pictures/clipboard13.png" alt="img1"></p><p> <strong>首先服务器需要打开</strong></p><p>服务端：</p><ol><li>创建socket套接字</li><li>bind将本机地址绑定套接字</li><li>listen设置此套接字可最大连接的客户端</li><li>accept开始监听等待客户端的连接</li></ol><p>客户端：</p><ol><li>socket创建套接字</li><li>connect发送请求连接的请求</li></ol><p>建立连接后Recv / Send</p><hr><h3 id="问题11-服务端监听的端口，但是还没有客户端连接进来，此时处于什么状态"><a href="#问题11-服务端监听的端口，但是还没有客户端连接进来，此时处于什么状态" class="headerlink" title="问题11.服务端监听的端口，但是还没有客户端连接进来，此时处于什么状态"></a>问题11.服务端监听的端口，但是还没有客户端连接进来，此时处于什么状态</h3><p>需要看用到了什么编程模型，如果是socket中的recv，一般是阻塞状态，而epoll，select等这样的io复用情况则是处于运行状态。</p><hr><h3 id="问题12-TCP和UDP个自适应的场景"><a href="#问题12-TCP和UDP个自适应的场景" class="headerlink" title="问题12.TCP和UDP个自适应的场景"></a>问题12.TCP和UDP个自适应的场景</h3><ul><li>TCP是面向连接的，可靠的字节流服务。</li><li>UDP是面向无连接的，不可靠的数据包服务。</li><li>UDP可以一对多，TCP为端口对端口。</li><li>TCP的开销为20个字节，UDP8个字节。</li></ul><p>综上UDP快，但是不可靠。TCP慢，但是可靠</p><ul><li>TCP用于——要求准确的文件传输</li><li>UDP用于——视频传输、实时通信、广播通信等。</li></ul><hr><h3 id="问题13-说一下HTTP协议"><a href="#问题13-说一下HTTP协议" class="headerlink" title="问题13.说一下HTTP协议"></a>问题13.说一下HTTP协议</h3><ul><li><p>HTTP协议是超文本传输协议，是从万维网服务器到本地浏览器的超文本传输协议。</p></li><li><p>基于TCP / IP通信协议来传输数据的。属于应用层面向对象的协议，适用于分布式超媒体信息系统。HTTP协议工作于客户端和服务端架构上。</p></li><li><p>浏览器作为HTTP的客户端通过URL向WEB服务器发送请求，WEB服务器根据接收到的请求后，向客户端发送响应信息及传输数据。</p></li></ul><hr><h3 id="问题14-说一下HTTP协议中GET和POST的区别"><a href="#问题14-说一下HTTP协议中GET和POST的区别" class="headerlink" title="问题14.说一下HTTP协议中GET和POST的区别"></a>问题14.说一下HTTP协议中GET和POST的区别</h3><p>http主要包括四种和服务器交互的方法：GET、POST、PUT、DELETE</p><p><strong>GET、POST区别：</strong></p><p>理解方式：货车和运输公司的关系，货物放在车顶，车厢内，允许不允许超载，卸货</p><ul><li><p>HTTP协议是基于TCP/IP协议的，GET和POST本质上都是TCP连接。但是其在请求方式上存在差异。</p></li><li><p>GET请求的数据存放在请求URL中，而POST存放在请求包体中</p></li><li><p>一般浏览器对请求URL长度有限制，所以导致GET请求获取的数据一般比POST少</p></li><li><p>同时由于请求数据暴露，所以使得GET的安全性也较低。</p></li><li><p>同时GET请求产生一个TCP数据报，而POST产生两个，对于验证数据的完整性更好。</p></li></ul><p>GET——请求header和请求data一起发送——返回200</p><p>POST——请求header先发送——返回100——再发送请求data——返回200</p><hr>]]></content>
      
      
      <categories>
          
          <category> learn </category>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>基础概念 / 操作系统 </title>
      <link href="/2020/07/13/inter2/"/>
      <url>/2020/07/13/inter2/</url>
      
        <content type="html"><![CDATA[<h2 id="核心：CPU管理、内存管理"><a href="#核心：CPU管理、内存管理" class="headerlink" title="核心：CPU管理、内存管理"></a>核心：CPU管理、内存管理</h2><p><img src="/pictures/clipboard.png" alt="img1"></p><h2 id="操作系统概念"><a href="#操作系统概念" class="headerlink" title="操作系统概念"></a>操作系统概念</h2><h3 id="1-操作系统主要内容：定义（CPU管理、内存管理）"><a href="#1-操作系统主要内容：定义（CPU管理、内存管理）" class="headerlink" title="1.操作系统主要内容：定义（CPU管理、内存管理）"></a><strong>1.操作系统主要内容：定义（CPU管理、内存管理）</strong></h3><ul><li>定义：用于控制和管理计算机的硬件和软件，合理调度CPU和内存等资源，分配给用户和其他软件的接口和环境</li><li>分类：分时操作系统，实时操作系统。<ol><li>分时操作系统（windows）——计算机以时间片为单位，轮流给各个用户服务。解决了人机交互问题。（各个用户通过终端与计算机交互）</li><li>实时操作系统（嵌入式）：计算机接收到外部信号后及时处理，触发马上反应。（即时性和可靠性）</li></ol></li></ul><hr><h3 id="2-操作系统的基本特性"><a href="#2-操作系统的基本特性" class="headerlink" title="2.操作系统的基本特性"></a><strong>2.操作系统的基本特性</strong></h3><ol><li>并发性：操作系统可以同时运行多个进程。不管是多核CPU还是单核CPU的计算机。（分时运行，分是获得CPU资源）</li><li>共享性：同时运行的进程可以共同使用系统中的资源。（互斥和同步访问）同步也是在互斥的基础上实现的访问机制。</li><li>异步性：进程不是一次性执行完成，而是走走停停的，但是最后结果不变。</li><li>虚拟性：虚拟是指将物理上的一个实体变为多个对应逻辑物。计算机中主要用于时分复用（CPU）和空分复用（虚拟内存）。</li></ol><p>补充：并发指的是多个程序同时运行，但是单核CPU穿插运行两个进程，通过时分复用来提高CPU的效率。<br>     并行指的是在多核CPU上分别运行进程，是并行运算提高计算机性能。</p><hr><h3 id="3-计算机的主要功能"><a href="#3-计算机的主要功能" class="headerlink" title="3.计算机的主要功能"></a><strong>3.计算机的主要功能</strong></h3><ol><li>CPU管理——合理分配CPU资源，进行进程管理：进程同步，通信、调度等</li><li>内存管理——对内存和虚拟内存管理：合理分配内存空间，进程间不发生死锁等异常情况。</li><li>文件管理——系统、用户文件的管理</li><li>IO设备管理——对外围设备的管理，分配接口等</li></ol><hr><h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><p>线程：是CPU调度的最小单位。</p><p>进程：是系统资源调度分配基本单位。</p><h3 id="1-进程定义"><a href="#1-进程定义" class="headerlink" title="1.进程定义"></a><strong>1.进程定义</strong></h3><p>进程定义：进程是对运行程序的封装，一个进程可以包含一个或多个程序。进程是系统资源调度的基本单位。运行的微信、QQ都是一个进程。</p><p>生命周期：（获得其他资源和CPU资源的过程）</p><ol><li>新建：未获得资源</li><li>就绪：获得其他资源，等待CPU资源</li><li>运行：获得其他资源，获得CPU资源</li><li>阻塞：等待触发事件以获得时间片资源，CPU空闲也不会运行</li><li>终止：退出，释放所有资源<br><img src="/pictures/clipboard1.png" alt="img2"></li></ol><p><strong>CPU资源以时间片来分配</strong></p><hr><h3 id="2-进程和程序的关系"><a href="#2-进程和程序的关系" class="headerlink" title="2.进程和程序的关系"></a><strong>2.进程和程序的关系</strong></h3><p>程序由一系列代码组成。而进程由程序、程序包含的数据，进程块组成。<br>从广度上看，进程是程序的动态体现，程序是进程的静态体现，两者相辅相成。<br>程序构建进程，进程执行程序。</p><h3 id="3-进程间的通信方式——作用——共享内存-套接字-信号-信号量"><a href="#3-进程间的通信方式——作用——共享内存-套接字-信号-信号量" class="headerlink" title="3.进程间的通信方式——作用——共享内存/套接字/信号/信号量"></a><strong>3.进程间的通信方式——作用——共享内存/套接字/信号/信号量</strong></h3><ol><li>管道通信pipe：多用于父子进程间通信</li><li>信号signal：通过接收事件信号，告知进程某事已经发生</li><li>共享内存shared memory：应用最为广泛，进程间通过共享内存上数据的更新，获得信息。</li><li>信号量：用于进程中不同线程的同步</li><li>套接字socket：不同计算机进程间的通信</li></ol><p>作用：A.数据传输及共享   B事件通知    C进程控制</p><h3 id="4-进程同步-调度算法——进程获得CPU资源的先后执行顺序——CPU分配"><a href="#4-进程同步-调度算法——进程获得CPU资源的先后执行顺序——CPU分配" class="headerlink" title="4.进程同步 / 调度算法——进程获得CPU资源的先后执行顺序——CPU分配"></a><strong>4.进程同步 / 调度算法——进程获得CPU资源的先后执行顺序——CPU分配</strong></h3><p>多进程提高了CPU的利用率，但是进程的异步性会给系统造成混乱。进程同步就是：协调进程间的执行顺序，使得并发的进程间可以有效的共享资源、相互合作。</p><p>总结：多进程的异步性造成系统混乱，我们需要协调进程执行顺序，让进程间有效共享资源，相互合作。</p><p>进程调度算法：CPU分配算法<br>主要指标：CPU利用率、系统吞吐量、周转时间、等待时间、响应时间等</p><ul><li>A.先来先服务算法（FCFS）：先来先服务调度算法，队列实现</li><li>B.短作业优先算法（SJF）：优先进行预估时间较短的进程（平均等待时间，周转时间最少）</li><li>C.优先级调度算法：优先级越高的，先分配到CPU</li><li>D.最高响应比算法（HRN）： 根据响应比决定优先级，响应比=(等待时间+要求服务时间)/要求服务时间；(兼顾长作业和短作业)</li><li>E.时间片轮转调度（RR）： 按到达的先后对进程放入队列中，依次分配相同的时间片，时间片用完，马上剥夺CPU</li><li>F.多级反馈队列调度算法（较好的算法）： 设置多个就绪队列，为每个队列赋予不同优先级，优先级不同分配的时间片也不同。第一个队列优先级最高，分配的时间片也越短。</li></ul><h3 id="6-死锁现象-处理死锁的方法"><a href="#6-死锁现象-处理死锁的方法" class="headerlink" title="6.死锁现象 / 处理死锁的方法"></a><strong>6.死锁现象 / 处理死锁的方法</strong></h3><p>死锁现象：多个进程争夺同一资源而陷入僵局，导致无法推进下去，进程无限阻塞，相互等待资源，最后卡死。</p><p>死锁原因：进程竞争资源，资源释放不合理</p><p>死锁产生的四大必要条件——发生死锁，四条至少一条成立</p><ul><li>—–1.互斥，2.请求和保持，3.不可剥夺，4.循环等待—–</li><li>互斥条件：一个资源每次只能被一个进程使用。</li><li>请求和保持条件：一个进程申请新资源时，对以旧资源不放</li><li>不可剥夺条件：进程获得资源在未使用完前，是不会释放它的</li><li>环路等待条件：若干进程之间形成一种头尾相接的环形等待资源关系</li></ul><p><strong>处理死锁的方法：打破四大条件</strong></p><ul><li>1.互斥条件不可打破</li><li>2.打破请和保持条件——实行预分配，只有满足进程所有资源要求时，才分配</li><li>3.打破不可剥夺条件——允许进程剥夺其他进程占有的资源，但是降低系统性能</li><li>4.打破环路等待条件——对资源进行编号，只有占用了小号资源才能申请大号资源。</li><li>基本思想都是：<strong>动态检测资源分配</strong>，从而保证系统处于安全状态。</li></ul><p>最常见的是<strong>银行家算法</strong>：检查申请者对资源的最大需求，如果各类资源都满足，就分配。这样可以很快完成计算，然后释放申请者申请的资源。</p><h3 id="7-临界资源的概念"><a href="#7-临界资源的概念" class="headerlink" title="7.临界资源的概念"></a><strong>7.临界资源的概念</strong></h3><p>共享性，让进程间可以共享系统资源。但是有的资源只能被单一进程使用，我们称其为临界资源。比如：打印机</p><p>临界资源的访问必须遵循互斥原则，访问临界资源的代码，我们称为临界区。</p><hr><h3 id="8-线程同步——按照某种特定顺序访问临界资源，避免线程冲突——内存资源分配"><a href="#8-线程同步——按照某种特定顺序访问临界资源，避免线程冲突——内存资源分配" class="headerlink" title="8.线程同步——按照某种特定顺序访问临界资源，避免线程冲突——内存资源分配"></a><strong>8.线程同步——按照某种特定顺序访问临界资源，避免线程冲突——内存资源分配</strong></h3><ul><li>1.临界区（用户态）Critical Section             WINDOWS特有</li><li>2.互斥量Mutex（内核态）</li><li>3.信号量Semaphore（限制访问某些资源的线程数量）</li><li>4.事件对象（内核）</li></ul><hr><ul><li>Linux线程同步方式：——无临界区<ol><li>互斥量  </li><li>信号量 </li><li>事件对象</li></ol></li></ul><hr><ul><li>Windows线程同步方式：<ol><li>互斥量  </li><li>临界区  </li><li>信号量  </li><li>事件对象</li></ol></li></ul><p><strong>tips：互斥和临界区采用互斥控制，拥有才会执行，执行完释放。</strong></p><p> <strong>信号量和事件对象采用通知控制，主要用于同步。</strong></p><hr><p>特点：</p><ul><li>A：临界区只能同步本进程内线程，（互斥量、信号量、事件）不可跨进程同步线程。</li><li>B：<ol><li>临界区在用户态下操作，速度快。</li><li>互斥量在内核态下进行锁操作，速度慢。</li></ol></li><li>C：Linux下不可以使用临界区</li></ul><hr><h3 id="9-线程简介"><a href="#9-线程简介" class="headerlink" title="9.线程简介"></a><strong>9.线程简介</strong></h3><p>线程是轻量化的进程，是进程组成的基本单位。不拥有系统所有资源，但是<strong>同一进程内的线程共享进程所有资源。</strong></p><p>线程组成：线程ID，当前指令指针，寄存器，堆栈。</p><ul><li>1.线程ID：用于表示线程</li><li>2.寄存器组的值：线程并发运行，切换时需要将原线程寄存器状态保存，用于重新切换时恢复。</li><li>3.堆栈：是保证线程独立运行的根本。线程函数可以调用函数，所以线程必须拥有自己的函数堆栈，而不受其他函数影响。位于进程的线程共享堆区内。（heap）</li><li>4.错误返回码</li><li>5.线程信号屏蔽码</li><li>6.线程优先级</li></ul><p>进程一般包含多个线程，所有线程间也存在着制约关系，有：就绪，阻塞，运行三种状态</p><hr><h3 id="10-进程和线程的区别"><a href="#10-进程和线程的区别" class="headerlink" title="10.进程和线程的区别"></a><strong>10.进程和线程的区别</strong></h3><ul><li><p>1.</p><ol><li>进程是程序的封装，是系统调度的基本单元，用于实现系统的并发性。</li><li>线程则是进程的子任务，是CPU调度的基本单元，用于实现进程的并发性。</li></ol></li><li><p>2.线程的开销比进程小很多，易于调度，多用可以提高CPU的利用率，提高程序并发性。</p></li><li><p>3.进程用于自己独立的内存空间，而线程至共享其父进程的内存空间。</p></li><li><p>4.父进程内的线程间可以直接通信，而进程间通信需要借助操作系统。</p></li></ul><h4 id="有了进程为什么还要线程？"><a href="#有了进程为什么还要线程？" class="headerlink" title="有了进程为什么还要线程？"></a><strong>有了进程为什么还要线程？</strong></h4><p>答：1.进程是系统调度的基本单元，而线程是CPU调度的基本单元。</p><p>2.在进程的基础上使用线程可以提高程序并发率，CPU的利用率，同时线程作为进程的子任务开销也较小。</p><p>3.进程拥有独立的内存空间，无法直接通信。而线程虽然没有独立的内存空间，但是父进程下的子线程都可以共享进程内数据，可以改善程序结构，提高计算效率。</p><hr><hr><h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><h3 id="1-内存管理"><a href="#1-内存管理" class="headerlink" title="1.内存管理"></a><strong>1.内存管理</strong></h3><ul><li>A：内存空间的分配与回收</li><li>B：地址转换——内存物理地址与逻辑地址的转换</li><li>C：内存空间的管理：虚拟内存和自动覆盖技术，逻辑上扩充内存。</li><li>D：内存保护：进程间的内存空间互不干扰</li></ul><hr><h3 id="2-逻辑地址和物理地址"><a href="#2-逻辑地址和物理地址" class="headerlink" title="2.逻辑地址和物理地址"></a><strong>2.逻辑地址和物理地址</strong></h3><p><strong>逻辑地址</strong>：程序编译后，每个模块都是从0单元开始编址的，称为模块的逻辑地址。当各个模块链接成一个完整可执行目标时，就成了逻辑地址。</p><p><strong>物理地址</strong>：内存物理地址的集合，它是地址转换的最终地址。</p><p><strong>地址重定位</strong>：进程在运行指令和访问数据时都需要物理地址来存取主存。必须将逻辑值转化为物理地址才能正确访问数据，此过程称为地址重定位。</p><hr><h3 id="3-内存分配的管理方式（分配程序空间）"><a href="#3-内存分配的管理方式（分配程序空间）" class="headerlink" title="3.内存分配的管理方式（分配程序空间）"></a><strong>3.内存分配的管理方式（分配程序空间）</strong></h3><p>A连续分配 / B非连续分配</p><h4 id="A连续分配：分配一个连续的内存空间"><a href="#A连续分配：分配一个连续的内存空间" class="headerlink" title="A连续分配：分配一个连续的内存空间"></a>A连续分配：分配一个连续的内存空间</h4><p> <strong>固定分区分配（产生内部碎片）</strong></p><p>示例：</p><p>分区A_10MB     分区B_10MB———内部碎片4和 6</p><p>进程A_6MB        进程B_4MB</p><p> <strong>动态分区分配（产生外部碎片）</strong></p><p>通过  “紧凑”  技术提高利用率，时间花销大。</p><h4 id="B非连续分配：将一个进程分散地装在不相邻的分区中，就无需再凑来节约空间。"><a href="#B非连续分配：将一个进程分散地装在不相邻的分区中，就无需再凑来节约空间。" class="headerlink" title="B非连续分配：将一个进程分散地装在不相邻的分区中，就无需再凑来节约空间。"></a>B非连续分配：将一个进程分散地装在不相邻的分区中，就无需再凑来节约空间。</h4><p><img src="/pictures/clipboard2.png" alt="img2"></p><p> *<em>基于分页的存储管理：（无外部碎片，极少数内部碎片） *</em></p><p>将内存分为一个一个相等的小块，再按照块大小拆分进程，放入内存。</p><hr><p><img src="/pictures/clipboard3.png" alt="img2"><br> *<em>基于分段的存储管理：（分配基本单位为逻辑上的段） *</em></p><p>进程的地址空间按照逻辑分为若干段，每段从0开始编址。以段为单位进行分配，每个段在内存中占据连续空间，但是各个段不相邻。</p><hr><p><strong>分页和分段的对比：————页大小固定，段不固定</strong></p><p>页是物理单位：为了实现内存的充分利用。是系统管理上的需要，对用户不可见。</p><p>段是逻辑单位：为了满足用户的逻辑习惯，以段进行分区包含一个逻辑模块。对用户可见，用户编程需要显示地给出段名。</p><p><strong>分页地址空间是一维的。</strong></p><p>分段地址空间则是二维的，程序员识别地址时，需要给出段名以及段内地址。</p><p>分段比分页更容易实现信息的共享和保护。</p><p><img src="/pictures/clipboard4.png" alt="img2"><br><strong>段页存储概念：先分段，再分页，内存管理仍采用分页存储管理。</strong></p><p>页式存储-&gt;提高内存利用效率</p><p>段式存储-&gt;反映程序的逻辑结构，利于段的共享和信息保护、程序可在执行时再动态链接</p><hr><h3 id="虚拟内存管理："><a href="#虚拟内存管理：" class="headerlink" title="虚拟内存管理："></a>虚拟内存管理：</h3><p>进程的<strong>驻留性</strong>，进程数据必须一次装进内存中，直至作业完成。这就导致了很多暂时不用的数据占据了内存大量空间。</p><p>虚拟内存概念：————内存 / 外寸 / 置换内存</p><p>基于<strong>局部性原理</strong>，将进程的部分数据装入<strong>内存</strong>，其余部分驻留<strong>外存</strong>，即可以运行程序。当进程需要外存中的数据时，我们将数据调入内存，置换出不需要的内存。这样就可以提供一个比实际物理内存大的多的存储器，称为虚拟内存。</p><p><strong>————需要的数据放入内存，暂时不需要的放置在外存。需要时再置换回内存。</strong></p><h4 id="1-虚拟内存的存储管理方式"><a href="#1-虚拟内存的存储管理方式" class="headerlink" title="1.虚拟内存的存储管理方式"></a>1.虚拟内存的存储管理方式</h4><p>分页存储管理，分段存储管理，段页存储管理。</p><p>使用最多的是分页管理方式，为了支持虚拟内存的管理，增加：1.请求调页功能  2.页面置换功能</p><p>需要的硬件支持：1.一定容量内存+外存 2.页表机制 3.终端机构 4.地址变换机构</p><h4 id="2-虚拟内存中的页面置换算法"><a href="#2-虚拟内存中的页面置换算法" class="headerlink" title="2.虚拟内存中的页面置换算法"></a>2.虚拟内存中的页面置换算法</h4><p>定义：在进程运行过程中，地址映射发现所访问的页不在内存中，将缺失的页从外存中点入内存中。但是当内存无空闲空间，需要移除页给准备进入的页腾位置。</p><p>常用的置换算法：</p><p>1.OPT——<strong>最佳置换算法</strong>——置换出接下来最不会被访问的页。理论上的算法，我们不知道哪个页接下来最不会被访问。常常用来作评价算法，因无法实现。</p><p>2.FIFO——<strong>先进先出置换算法</strong>——最早进入的页被置换出内存：当物理内存快增加，可能置换的次数反而变多，因为先进入的页可能被淘汰但是马上又要用。</p><p>3.LRU——<strong>最久未使用置换算法</strong>——将最久未访问的页置换：LRU算法的性能是最好的，但是需要寄存器和硬件的辅助计算支持，LRU是堆栈类算法。</p><h4 id="3-虚拟内存的优缺点"><a href="#3-虚拟内存的优缺点" class="headerlink" title="3.虚拟内存的优缺点"></a>3.虚拟内存的优缺点</h4><p>优点：  </p><ul><li>1.提高了逻辑内存大小，内存的利用率</li><li>2.每个进程互不干扰，都在自己的虚拟内存空间下</li></ul><p>缺点：  </p><ul><li>1.增加一些内存开销（虚拟内存的管理）</li><li>2.增加一些CPU开销（虚拟地址到物理地址的转换、页面置的时间）</li></ul><h4 id="4-虚拟内存的特点"><a href="#4-虚拟内存的特点" class="headerlink" title="4.虚拟内存的特点"></a>4.虚拟内存的特点</h4><ul><li>多次性：数据分多次装入内存中</li><li>置换性：进程运行的同时进行数据，内存外存置换</li><li>虚拟性：提高了逻辑内存大小<h4 id="5-页面置换中的-颠簸-抖动——频繁缺页中断，置换页面——CPU开销增大"><a href="#5-页面置换中的-颠簸-抖动——频繁缺页中断，置换页面——CPU开销增大" class="headerlink" title="5.页面置换中的  颠簸 / 抖动——频繁缺页中断，置换页面——CPU开销增大"></a>5.页面置换中的  颠簸 / 抖动——频繁缺页中断，置换页面——CPU开销增大</h4></li></ul><p>定义：页面置换中，当置换出的页，接下来马上又要使用，这样会不断产生缺页中断，这种现象称为颠簸。</p><p>需要注意：虚拟内存可以提高逻辑内存，但是页面管理及置换算法不当时，会花费CPU很大的时间去交换页面，而不是执行进程命令，大大降低系统的效率。</p><h4 id="6-工作集的概念"><a href="#6-工作集的概念" class="headerlink" title="6.工作集的概念"></a>6.工作集的概念</h4><p>定义：某段时间内，进程访问页面的集合。经常被访问的页，我们将其放在工作集内，防止产生抖动现象，因此我们需要选择合适的工作集。</p><p>————单独开辟的进程常访问页的内存区域————</p><p>作用：选择正确的工作集，可以提高内存的利用率和吞吐效率，减少页面置换的花销。</p><h4 id="7-页表寻址——找寻虚拟内存地址对应的物理地址"><a href="#7-页表寻址——找寻虚拟内存地址对应的物理地址" class="headerlink" title="7.页表寻址——找寻虚拟内存地址对应的物理地址"></a>7.页表寻址——找寻虚拟内存地址对应的物理地址</h4><p>页表是计算机虚拟内存地址到物理内存地址的映射。页表中的每一项都记录着页的首地址。</p><p>首先通过页表的找寻逻辑地址对应的页的首地址，然后通过页的首地址  加上偏移量找到最后的物理地址。<br><img src="/pictures/clipboard5.png" alt="img2"></p><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="问题1-单核计算机多线程程序需要加锁吗"><a href="#问题1-单核计算机多线程程序需要加锁吗" class="headerlink" title="问题1.单核计算机多线程程序需要加锁吗"></a>问题1.单核计算机多线程程序需要加锁吗</h3><p>需要，因为程序锁的目的是为了保证线程的同步，防止读取共享数据时发生死锁等线程。单核计算机仍然存在线程同步问题，所以也需要加锁。</p><h3 id="问题2-游戏服务器应该为每个用户开辟一个线程还是一个进程，为什么？（互不影响）"><a href="#问题2-游戏服务器应该为每个用户开辟一个线程还是一个进程，为什么？（互不影响）" class="headerlink" title="问题2.游戏服务器应该为每个用户开辟一个线程还是一个进程，为什么？（互不影响）"></a>问题2.游戏服务器应该为每个用户开辟一个线程还是一个进程，为什么？（互不影响）</h3><p>开辟进程。同一进程间的线程会相互影响，一个线程死掉会影响其他线程，为了保证用户间互不影响，应该开辟进程。</p><h3 id="问题3-请你说一说互斥锁机制，以及互斥锁和读写锁的区别"><a href="#问题3-请你说一说互斥锁机制，以及互斥锁和读写锁的区别" class="headerlink" title="问题3.请你说一说互斥锁机制，以及互斥锁和读写锁的区别"></a>问题3.请你说一说互斥锁机制，以及互斥锁和读写锁的区别</h3><ul><li>互斥锁：保证单一对象只有单一线程对其进行操作。</li><li>读写锁：分为读锁和写锁。处于读操作时，允许多个线程同时获得读操作，但是同一时刻只允许一个线程获得写操作。同时写锁会阻塞其他操作</li></ul><p>不同：</p><ul><li>读写锁区分读和写，而互斥锁不区分。</li><li>互斥锁只允许一个线程访问该对象。读写锁允许多个读者，但是同一时间只允许一个写着。</li></ul><h3 id="问题4-怎样确定当前线程是繁忙还是阻塞"><a href="#问题4-怎样确定当前线程是繁忙还是阻塞" class="headerlink" title="问题4.怎样确定当前线程是繁忙还是阻塞"></a>问题4.怎样确定当前线程是繁忙还是阻塞</h3><p>linux下用ps命令查看</p><h3 id="问题5-windows消息机制知道吗，请说一说"><a href="#问题5-windows消息机制知道吗，请说一说" class="headerlink" title="问题5.windows消息机制知道吗，请说一说"></a>问题5.windows消息机制知道吗，请说一说</h3><p>消息机制是系统将用户的具体操作转化为消息，告诉给进程。有点类似进程通信中的信号。</p><h3 id="问题6-说一下僵尸进程和孤儿进程（未回收信息的子进程）"><a href="#问题6-说一下僵尸进程和孤儿进程（未回收信息的子进程）" class="headerlink" title="问题6.说一下僵尸进程和孤儿进程（未回收信息的子进程）"></a>问题6.说一下僵尸进程和孤儿进程（未回收信息的子进程）</h3><p>父进程创建子进程，子进程再创建新子进程。子进程的结束和父进程的运行是个异步过程。父进程需要调用wait（）等操作取得子进程的终止状态。</p><ul><li><p>孤儿进程：父进程结束了，子进程还在运行。孤儿进程会被进程号为1的进程收养。</p></li><li><p>僵尸进程：子进程退出时，父进程没有调用wait回收子进程的信息，那么子进程的信息仍保留在系统中，这种进程称为僵尸进程。</p></li><li><p>危害：僵尸进程是进程必须经过的过程，但是如果父进程未来得及处理退出的子进程，就会变成僵尸进程。这样的话僵尸进程保留的那段信息就不会释放，进程号一直被占用，会导致逐渐没有可用的进程号。</p></li><li><p>解决：通过kill发出指令，僵尸进程变孤儿进程，再由新的父进程接管消灭。在子进程结束的时候父进程及时wait（）取得子进程的终止状态。</p></li></ul><h3 id="问题6-请你来介绍一下5种IO模型"><a href="#问题6-请你来介绍一下5种IO模型" class="headerlink" title="问题6.请你来介绍一下5种IO模型"></a>问题6.请你来介绍一下5种IO模型</h3><ul><li>1.阻塞型IO：等待函数返回，不返回不继续，反复检索函数有没有返回</li><li>2.非阻塞型IO：每隔一段时间检查IO事件是否就绪，没有仍可以做其他事情</li><li>3.信号驱动IO：安装一个信号处理函数，进程不阻塞，收到信号处理IO事件。</li><li>4.复用IO：poll，select函数实现复用模型</li><li>5.异步IO：可以调用aio_read函数告诉内核描述字缓冲区指针和缓冲区的大小、文件偏移及通知的方式，然后立即返回，当内核将数据拷贝到缓冲区后，再通知应用程序。</li></ul><h3 id="问题7-请你说一说异步编程的事件循环"><a href="#问题7-请你说一说异步编程的事件循环" class="headerlink" title="问题7.请你说一说异步编程的事件循环"></a>问题7.请你说一说异步编程的事件循环</h3><p>事件循环就是事件是处理器一个一个依次执行的。当一个事件执行完毕，事件循环就会继续等待下一个事件的触发，不断往复。</p><p>当单个线程绑定了两个处理器，那么第二个处理器也会等待第一个处理器执行完毕后，才开始执行。</p><h3 id="问题8-请你回答一下操作系统为什么要分内核态（root）和用户态（非root）"><a href="#问题8-请你回答一下操作系统为什么要分内核态（root）和用户态（非root）" class="headerlink" title="问题8.请你回答一下操作系统为什么要分内核态（root）和用户态（非root）"></a>问题8.请你回答一下操作系统为什么要分内核态（root）和用户态（非root）</h3><p>为了系统的安全性。CPU中的一些指令用错会导致整个系统崩溃。当用户态满足使用要求时尽量使用用户态，避免发生不必要的错误。</p><h3 id="问题9-请问怎么实现线程池"><a href="#问题9-请问怎么实现线程池" class="headerlink" title="问题9.请问怎么实现线程池"></a>问题9.请问怎么实现线程池</h3><ul><li>1.设置一个生产消费者队列，作为申请线程的临时资源</li><li>2.初始化n个线程，并运行，加锁去队列中获取任务</li><li>3.无任务，线程阻塞。有任务，队列加锁，条件变量通知其中阻塞的一个线程运行</li></ul><h3 id="问题10-说一下C-源文件从文本——-gt-可执行文件-——经历的过程"><a href="#问题10-说一下C-源文件从文本——-gt-可执行文件-——经历的过程" class="headerlink" title="问题10.说一下C++源文件从文本——&gt;可执行文件 ——经历的过程"></a>问题10.说一下C++源文件从文本——&gt;可执行文件 ——经历的过程</h3><ul><li>1.预处理(产生.i文件)：将所以源文件(.cpp)和相关头文件，预处理成一个 .i文件<ol><li>将#define删除，并且宏替换</li><li>将#ifdef，#ifndef等不需要的代码删除          </li><li>将注释的代码删除</li><li>处理#include预编译指令，将包含的文件插入到该预编译指令的位置，此过程递归进行。</li><li>保留#pragma编译器指令，因为编译器需要。</li></ol></li></ul><p>#ifdef，#ifndef作用：防止头文件重复包含</p><p>#include&lt;&gt;和#include”  “区别：前者从标准库中找，后者从当前目录开始寻找。</p><ul><li><p>2.编译(产生.s文件)：（核心）<br>  将预处理后的文件，进行一系列的词法分析，语义分析以及优化后产生相应的  汇编代码文件</p></li><li><p>3.汇编(产生.o/.obj文件)：<br>  汇编实质上是把汇编语言代码  翻译成目标机器指令的过程，即生成目标文件。</p></li><li><p>4.链接(产生.out/.exe文件)：<br>  链接就是代码中用了别的库，将其和程序进行链接，然后生成可执行文件。按照它们的要求将它们组装起来，链接主要解决的是源代码之间的相互依赖问题，链接的过程包括地址和空间的分配，符号决议，和重定位等这些步骤。</p></li></ul><p><strong>总结</strong></p><ul><li>预处理（头文件解析，删除注释，宏替换等）</li><li>编译（将预处理后文件，语义分析，优化后生成汇编语言）</li><li>汇编（将汇编语言翻译成机器语言，生成目标文件）</li><li>链接（链接其他使用了的库，和目标文件结合生成可执行文件）</li></ul><h3 id="问题11-静态库-动态库的区别"><a href="#问题11-静态库-动态库的区别" class="headerlink" title="问题11.静态库 / 动态库的区别"></a>问题11.静态库 / 动态库的区别</h3><ul><li>静态库（.a/lib ）/动态库(.so/dll )的区别：</li><li>两者都由.o目标文件编译生成。可以理解为目标文件的一个集合。</li><li>静态库在链接过程中，会将静态库和目标文件（.o）一起打包到可执行文件中。删除后，程序仍可以执行。</li><li>动态库并不会打包到可执行文件中，只有在程序被执行时才会被载入，避免了浪费资源。</li></ul>]]></content>
      
      
      <categories>
          
          <category> learn </category>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++ / 获得系统实时时间ms</title>
      <link href="/2020/07/11/time/"/>
      <url>/2020/07/11/time/</url>
      
        <content type="html"><![CDATA[<h2 id="系统时间的获取-ms"><a href="#系统时间的获取-ms" class="headerlink" title="系统时间的获取_ms"></a>系统时间的获取_ms</h2><h3 id="1-windows"><a href="#1-windows" class="headerlink" title="1.windows"></a>1.windows</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">getTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">SYSTEMTIME st;</span><br><span class="line">GetLocalTime(&amp;st);</span><br><span class="line"><span class="built_in">string</span> tmp = to_string(st.wYear) + <span class="string">"-"</span> + to_string(st.wMonth) + <span class="string">"-"</span> + to_string(st.wDay) + <span class="string">"-"</span> + to_string(st.wHour) + <span class="string">"-"</span> + to_string(st.wMinute) + <span class="string">"-"</span> + to_string(st.wSecond) + <span class="string">"-"</span> + to_string(st.wMilliseconds);</span><br><span class="line"><span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-linux"><a href="#2-linux" class="headerlink" title="2.linux"></a>2.linux</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">get_time</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">string</span> time;</span><br><span class="line">timeval tv;</span><br><span class="line">gettimeofday(&amp;tv, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tm</span>* <span class="title">ptm</span>;</span></span><br><span class="line">ptm = localtime(&amp;(tv.tv_sec));</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> time_string[<span class="number">40</span>];</span><br><span class="line"><span class="keyword">long</span> milliseconds;</span><br><span class="line"></span><br><span class="line">strftime(time_string, <span class="keyword">sizeof</span>(time_string), <span class="string">"%Y-%m-%d-%H-%M-%S-"</span>, ptm);</span><br><span class="line">milliseconds = tv.tv_usec / <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">time = time_string + to_string(milliseconds);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> time;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 获取系统实时时间 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Others / Blog模板</title>
      <link href="/2020/07/10/hello-world/"/>
      <url>/2020/07/10/hello-world/</url>
      
        <content type="html"><![CDATA[<h2 id="Blog模板"><a href="#Blog模板" class="headerlink" title="Blog模板"></a>Blog模板</h2><h3 id="1-标题1"><a href="#1-标题1" class="headerlink" title="1.标题1"></a>1.标题1</h3><p><img src="/pictures/clipboard14.png" alt="img"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p> <code>AAA</code></p><ul><li><blockquote><p>进程是程序的封装，是系统调度的基本单元，用于实现系统的并发性。啊实打实大大</p></blockquote></li><li><blockquote><p>啊大大进程是程序的封装，是系统调度的基本单元，用于实现系统的并发性。进程是程序的封装，是系统调度的基本单元，用于实现系统的并发性。进程是程序的封装，是系统调度的基本单元，用于实现系统的并发性。</p></blockquote></li></ul><p><font size=6> 为什么要四次挥手？</font> </p><ul><li>一.<ol><li>进程是程序的封装，是系统调度的基本单元，用于实现系统的并发性。</li><li>线程则是进程的子任务，是CPU调度的基本单元，用于实现进程的并发性。<ol><li>进程</li><li>进程</li></ol></li></ol></li><li>文本1</li><li>文本2</li><li>文本3</li></ul><p><em>倾斜</em></p><p><strong>加粗</strong></p><p><strong><em>斜体加粗</em></strong></p><p><del>删除线</del></p><p>分割线</p><hr><p><img src="/pictures/inter.jpg" alt="img1"></p><hr><table><thead><tr><th>概念</th><th>特征</th><th>网络范围</th><th>默认子网掩码</th></tr></thead><tbody><tr><td>A类地址</td><td>0XXX  XXXX</td><td>0——127.x.x.x</td><td>255.0.0.0/8</td></tr><tr><td>B类地址</td><td>0XXX  XXXX</td><td>128——191.x.x.x</td><td>255.255.0.0/16</td></tr><tr><td>C类地址</td><td>0XXX  XXXX</td><td>192——223.x.x.x</td><td>255.255.255.0/24</td></tr><tr><td>D类地址</td><td>1110    XXXX</td><td>192——223.x.x.x</td><td>用于组播</td></tr><tr><td>E类地址</td><td>1111    0XXX</td><td>192——223.x.x.x</td><td>用于科研保留</td></tr></tbody></table><hr><hr><p>超链接More info: <a href="https://tieba.baidu.com/f?kw=%B9%FA%BC%CA%C3%D7%C0%BC&fr=ala0&tpl=5" target="_blank" rel="noopener">INTER</a></p><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">|     |       |     /  |   / |</span><br><span class="line">|     |       |     /  |   / |</span><br><span class="line">|     |       |     /  |   / |</span><br></pre></td></tr></table></figure><hr><ul><li><blockquote><p>日志</p></blockquote></li><li>2020/08/22<ul><li>划水的一天</li></ul></li><li>2020/08/23<ul><li>1.上午：面经学习</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Others </category>
          
          <category> 博客模板 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
