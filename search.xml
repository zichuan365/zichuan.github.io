<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>LeetCode / 785. 判断二分图</title>
      <link href="/2020/07/16/leetcode2/"/>
      <url>/2020/07/16/leetcode2/</url>
      
        <content type="html"><![CDATA[<h2 id="785-判断二分图"><a href="#785-判断二分图" class="headerlink" title=" 785. 判断二分图"></a><font size=6> 785. 判断二分图</font></h2><p> <code>题目</code></p><ul><li><p>给定一个无向图graph，当这个图为二分图时返回true。</p></li><li><p>如果我们能将一个图的节点集合分割成两个独立的子集A和B，并使图中的每一条边的两个节点一个来自A集合，一个来自B集合，我们就将这个图称为二分图。</p></li><li><p>graph将会以邻接表方式给出，graph[i]表示图中与节点i相连的所有节点。每个节点都是一个在0到graph.length-1之间的整数。这图中没有自环和平行边： graph[i] 中不存在i，并且graph[i]中没有重复的值。</p></li></ul><hr><p><code>理解</code>：graph[i]代表i结点所相连接的所有节点</p><p><code>二分图理解</code>：</p><ul><li>二分图：顶点由两个<strong>集合A</strong>和<strong>集合B</strong>组成，且所有边的两个顶点正好分别处于两个集合里</li><li>更形象化地去表示：我们可以用两种颜色代表这两个集合，相邻的顶点不能是同一种颜色</li><li>下图右边例子：<ol><li>对顶点0来说，1、2、3和它相邻所以不同色，</li><li>对顶点1，2来说，1和2因此同色，不是二分图</li></ol></li></ul><p><img src="/pictures/clipboard17.png" alt="img1"></p><p><strong>总结</strong>：将点到点的集合——划分为不相交的两个子集（点在两个子集和里），同时所对应的两个   顶点i  和  顶点j  分别在不同的集合中。</p><p><code>例题</code></p><p><img src="/pictures/clipboard18.png" alt="img1"></p><p><code>解题</code></p><ul><li><blockquote><p>动态规划：题解如上，分个数讨论，依次从1、2、3、4往上，在前者的基础上讨论现在的可能情况</p></blockquote></li></ul><hr><p><code>代码</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="comment">//-1——未染色</span></span><br><span class="line">    <span class="comment">// 0——染为0</span></span><br><span class="line">    <span class="comment">// 1——染为1</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isBipartite</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; graph)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = graph.<span class="built_in">size</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v</span><span class="params">(n,<span class="number">-1</span>)</span></span>;        <span class="comment">// 给所有节点标记为 -1（未染色）</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123; <span class="comment">// 依次遍历每一个节点</span></span><br><span class="line">            <span class="keyword">if</span>(v[i] == <span class="number">-1</span>)&#123; <span class="comment">// 未染色入栈进行操作</span></span><br><span class="line">                <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">                q.push(i);</span><br><span class="line">                v[i] = <span class="number">0</span>;   <span class="comment">//将其染为0</span></span><br><span class="line">                <span class="keyword">while</span>(!q.empty())</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">int</span> cur = q.front();                <span class="comment">//当前节点颜色</span></span><br><span class="line">                    <span class="keyword">int</span> cur_neighbor = (v[cur] == <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>);<span class="comment">// 记录接下来相邻节点要染的另一种颜色    </span></span><br><span class="line">                    q.pop();</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> node_neighbor : graph[cur]) <span class="comment">// 遍历节点node的相邻节点</span></span><br><span class="line">                    &#123; </span><br><span class="line">                        <span class="keyword">if</span>(v[node_neighbor] == <span class="number">-1</span>)   <span class="comment">//没染色，进行染色，同时入栈</span></span><br><span class="line">                        &#123;</span><br><span class="line">                            q.push(node_neighbor);</span><br><span class="line">                            v[node_neighbor] = cur_neighbor;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span>(v[node_neighbor] != cur_neighbor) <span class="comment">//染色了，若颜色相同，说明在同一个子集里</span></span><br><span class="line">                        <span class="comment">// 相邻节点染色 不是 cur_neighbor</span></span><br><span class="line">                            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
          <category> 785.判断二分图 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode / 120. 三角形最小路径和</title>
      <link href="/2020/07/16/leetcode1/"/>
      <url>/2020/07/16/leetcode1/</url>
      
        <content type="html"><![CDATA[<h2 id="120-三角形最小路径和"><a href="#120-三角形最小路径和" class="headerlink" title=" 120.三角形最小路径和"></a><font size=6> 120.三角形最小路径和</font></h2><p> <code>题目</code></p><ul><li>给定一个整数 n，求以 1 … n 为节点组成的二叉搜索树有多少种？</li></ul><p><code>例题</code></p><ul><li><p>[</p></li><li><p>[ <strong>2</strong> ],</p></li><li><p>[<strong>3</strong> , 4 ],</p></li><li><p>[6 , <strong>5</strong> , 7 ],</p></li><li><p>[ 4 , <strong>1</strong>  ,8 , 3 ]</p></li><li><p>]</p></li></ul><p>自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。</p><p><code>解题</code></p><ul><li><blockquote><p>动态规划：从上或者从下依次往上遍历，直到走到终点，比较最短的路程。</p></blockquote></li></ul><p><img src="/pictures/clipboard14.png" alt="img1"></p><ul><li><blockquote><p>可以发现：从上—除了两侧的只有一条路来  /  从下—都是有两条路来</p></blockquote></li><li><p>从上到下</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">第一个：res[i][0] = res[i-1][0] + triangle[i][0];</span><br><span class="line">中间的：res[i][j] = triangle[i][j] + min(res[i-1][j-1],res[i-1][j]);</span><br><span class="line">最后个：res[i][i]  = res[i-1][i-1] + triangle[i][i];</span><br></pre></td></tr></table></figure><ul><li>从下到上</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">triangle[i][j] += min(triangle[i+1][j],triangle[i+1][j+1]);</span><br></pre></td></tr></table></figure><hr><p><code>代码</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minimumTotal</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; triangle)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> lenX = triangle.<span class="built_in">size</span>();</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;res(lenX, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(lenX, <span class="number">0</span>));</span><br><span class="line">res[<span class="number">0</span>][<span class="number">0</span>] = triangle[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; lenX; i++) &#123;</span><br><span class="line"><span class="comment">//第一个数据</span></span><br><span class="line"><span class="keyword">int</span> temp = i;</span><br><span class="line">res[i][<span class="number">0</span>] = res[i - <span class="number">1</span>][<span class="number">0</span>] + triangle[i][<span class="number">0</span>];</span><br><span class="line"><span class="comment">//中间数据</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; temp; j++) &#123;</span><br><span class="line">res[i][j] = triangle[i][j] + <span class="built_in">min</span>(res[i - <span class="number">1</span>][j - <span class="number">1</span>], res[i - <span class="number">1</span>][j]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//最后一个数据</span></span><br><span class="line">res[i][temp] = res[i - <span class="number">1</span>][temp - <span class="number">1</span>] + triangle[i][temp];</span><br><span class="line">&#125;</span><br><span class="line">sort(res.back().<span class="built_in">begin</span>(), res.back().<span class="built_in">end</span>());</span><br><span class="line"><span class="keyword">return</span> res.back()[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minimumTotal</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; triangle)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = triangle.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; j++) &#123;</span><br><span class="line">triangle[i][j] += <span class="built_in">min</span>(triangle[i + <span class="number">1</span>][j], triangle[i + <span class="number">1</span>][j + <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> triangle[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
          <category> 120.三角形最小路径和 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode / 96. 不同的二叉搜索树</title>
      <link href="/2020/07/16/leetcode/"/>
      <url>/2020/07/16/leetcode/</url>
      
        <content type="html"><![CDATA[<h2 id="96-不同的二叉搜索树"><a href="#96-不同的二叉搜索树" class="headerlink" title=" 96. 不同的二叉搜索树"></a><font size=6> 96. 不同的二叉搜索树</font></h2><p> <code>题目</code></p><ul><li>给定一个整数 n，求以 1 … n 为节点组成的二叉搜索树有多少种？</li></ul><p><code>例题</code></p><p><img src="/pictures/clipboard15.png" alt="img1"></p><p><code>解题</code></p><ul><li><blockquote><p>动态规划：题解如上，分个数讨论，依次从1、2、3、4往上，在前者的基础上讨论现在的可能情况</p></blockquote></li></ul><hr><p><code>代码</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">2</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;dp(n + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="comment">//求dp[3]——— 02 11 20</span></span><br><span class="line">dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">dp[i] += dp[j] * dp[i - j - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><ul><li><blockquote><p>类似题型</p></blockquote></li></ul><h2 id="22-括号的生成"><a href="#22-括号的生成" class="headerlink" title=" 22.括号的生成"></a><font size=6> 22.括号的生成</font></h2><p> <code>题目</code></p><ul><li>数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。</li></ul><p><code>例题</code></p><ul><li>输入：n = 3</li><li>输出：</li></ul><p><img src="/pictures/clipboard16.png" alt="img1"></p><p><code>代码</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> &#123; <span class="string">""</span> &#125;;</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">1</span>)<span class="keyword">return</span> &#123; <span class="string">"()"</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt;dp(n + <span class="number">1</span>);</span><br><span class="line">dp[<span class="number">0</span>] = &#123; <span class="string">""</span> &#125;;</span><br><span class="line">dp[<span class="number">1</span>] = &#123; <span class="string">"()"</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">string</span> p : dp[j]) &#123;     <span class="comment">//左和右的不同组合，添加到vector中去，使用vector添加</span></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">string</span> q : dp[i - j - <span class="number">1</span>]) &#123;</span><br><span class="line"><span class="built_in">string</span> str = <span class="string">"("</span> + p + <span class="string">")"</span> + q;</span><br><span class="line">dp[i].push_back(str);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
          <category> 96.不同的二叉搜索树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Daily record—INTER</title>
      <link href="/2020/07/15/target/"/>
      <url>/2020/07/15/target/</url>
      
        <content type="html"><![CDATA[<h3 id="Targets"><a href="#Targets" class="headerlink" title="Targets"></a>Targets</h3><ol><li>7.15把博客好好打理一下</li><li></li><li></li><li></li><li></li><li></li></ol><h3 id="Must-to-do"><a href="#Must-to-do" class="headerlink" title="Must to do"></a>Must to do</h3><ol><li><p>字好好写，<strong>把名字写好！！！</strong></p></li><li><p>卡路里爆炸的No eat</p></li><li><p>卡路里爆炸的No eat</p></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>基础概念 / 计算机网络</title>
      <link href="/2020/07/14/714/"/>
      <url>/2020/07/14/714/</url>
      
        <content type="html"><![CDATA[<h2 id="计算机网络的核心就是网络协议（如TCP-IP协议）"><a href="#计算机网络的核心就是网络协议（如TCP-IP协议）" class="headerlink" title="计算机网络的核心就是网络协议（如TCP / IP协议）"></a>计算机网络的核心就是网络协议（如TCP / IP协议）</h2><p>网络协议：规定着网络中<strong>数据交换</strong>的规则。用户间的数据终端是不同的，所以必须建立在一定的标准上计算机才能在网络中交互。</p><p>————<strong>建立网络通信规则、实现用户间的交互</strong>————</p><p><img src="/pictures/clipboard6.png" alt="img1"><br><img src="/pictures/clipboard7.png" alt="img1"></p><ol start="7"><li>应用层：为操作系统或网络应用程序提供访问网络的服务接口—提供进程访问网络的接口</li><li>表示层：对传送的数据进行处理，包括转换、压缩、加密等，以保证被其他应用层理解（数据表示）</li><li>会话`：在传输层基础上，帮助进程建立、管理对话——主机间通信</li><li>传输层：通过流量控制、差错控制等，健壮IP协议不可靠的传输，同时实现进程间端口到端口的传输</li><li>网络层：在数据链路层基础上，提供主机端到端的传输服务—路径选择、优化传输IP数据报</li><li>数据链路层：数据组合成块，提供网络层到网络层的数据帧传输</li><li>物理层：提供硬件支持，解决通讯设备间的物理差异，将数据转换为比特流传输</li></ol><hr><h2 id="网络层的划分"><a href="#网络层的划分" class="headerlink" title="网络层的划分"></a>网络层的划分</h2><p>为了让不同型号的计算机可以互相通信，提出了开放系统互连 / 参考模型。即OSI / RM模型。Open system interconnect / Reference Model。</p><p>主要有七层，从下到上：物理层、数据链路层、网络层、传输层、会话表示应用层。</p><p><strong>开放系统互连，OSI各层的划分</strong></p><hr><h3 id="物理层："><a href="#物理层：" class="headerlink" title="物理层："></a>物理层：</h3><p> <strong>提供硬件支持，消除设备差异，转化为比特流传输</strong></p><p> <code>定义</code>：硬件层，给上层接口提供物理传输媒介，解决不同通讯设备间的信号差异，将数据转换为比特流传输。</p><p> <code>设备</code>：集线器（扩大信号、增加接口）、中继器（扩大信号）</p><hr><h3 id="数据链路层："><a href="#数据链路层：" class="headerlink" title="数据链路层："></a>数据链路层：</h3><p> <strong>提供网络层到网络层的数据帧传输（帧转发）</strong></p><p> <code>定义</code>：为网络层提供可靠的数据传输，将网络层数据可靠传输到目标网络层。</p><p><code>方法</code>：如何数据组合成块，数据链路层我们将数据称为frame帧，在两个网络实体间提供数据链路的建立、维持和释放的管理。</p><p><code>总结</code>：物理寻址，数据成帧，帧转发</p><p><code>设备</code>：网桥（连接LAN之间）、交换机（连接LAN之间）——帧转发</p><hr><h3 id="网络层："><a href="#网络层：" class="headerlink" title="网络层："></a>网络层：</h3><p>数据链路层的基础上，实现主机间<strong>端到端</strong>的数据传输（<code>路径选择</code>、<code>优化传输</code>） </p><p> <code>定义</code>：网络层的目的是实现两个系统之间的端到端的传输，具体功能包括寻址和路由选择、连接的建立、保持和终止等。它提供的服务使传输层不需要了解网络中的数据传输和交换技术。</p><p><code>主要协议</code>：IP协议、地址解析协议ARP、逆RARP，英特网报文协议ICMP、英特网管组协议IGMP</p><p><code>方法</code>：对子网数据包进行路由选择、选择最优达到主机的路径。同时依靠分组交换等技术优化传输。</p><p><code>设备</code>：路由器       传输数据单位：数据包packet——IP数据报</p><h4 id="1-什么是IP协议、IP地址、IP数据报"><a href="#1-什么是IP协议、IP地址、IP数据报" class="headerlink" title="1.什么是IP协议、IP地址、IP数据报"></a>1.什么是IP协议、IP地址、IP数据报</h4><p><code>IP协议</code>：即互联网协议，是TCP / IP协议中的网络层。其目是是为了提高互联网的可拓展性。<br>1.实现互联网的大规模互联互通  2.分割网络应用和网络技术，便于两者的独立发展。根据端到端的设计原则，IP为主机提供一种无连接、不可靠、尽力而为的数据传输。</p><p><code>IP地址</code>：IP协议提供的一种<strong>地址格式</strong>，为互联网上的每一台主机分配一个<strong>逻辑地址</strong>，屏蔽物理地址的差异。32/128</p><p><code>IP数据报</code>：IP协议传输的数据单位，无确认数据包是否完整、按顺序发送等，是不可靠的。包含了发送地址、目标地址。<br>IP地址——电话号码        路由器——电信局的交换机</p><hr><h4 id="2-IP地址的表示"><a href="#2-IP地址的表示" class="headerlink" title="2.IP地址的表示"></a>2.IP地址的表示</h4><ul><li><p>IP地址 = 网络地址 + 主机地址。</p></li><li><p>网络号：用于识别主机所在网络区域    </p></li><li><p>主机号：识别该网络中的哪一台主机<br><img src="/pictures/clipboard8.png" alt="img1"></p><table><thead><tr><th>概念</th><th>特征</th><th>网络范围</th><th>默认子网掩码</th></tr></thead><tbody><tr><td>A类地址</td><td>0XXX  XXXX</td><td>0——127.x.x.x</td><td>255.0.0.0/8</td></tr><tr><td>B类地址</td><td>0XXX  XXXX</td><td>128——191.x.x.x</td><td>255.255.0.0/16</td></tr><tr><td>C类地址</td><td>0XXX  XXXX</td><td>192——223.x.x.x</td><td>255.255.255.0/24</td></tr><tr><td>D类地址</td><td>1110    XXXX</td><td>192——223.x.x.x</td><td>用于组播</td></tr><tr><td>E类地址</td><td>1111    0XXX</td><td>192——223.x.x.x</td><td>用于科研保留</td></tr></tbody></table></li></ul><ul><li><p>127.0.0.1是回环地址，用预测是本地通信。</p></li><li><p>子网掩码：明确区分出IP地址的两部分——网络地址和主机地址（1网络地址、0主机地址）</p></li><li><p>广播地址：专门向网络中所有工作站发送信息的地址</p></li></ul><hr><h4 id="3-IP地址的计算"><a href="#3-IP地址的计算" class="headerlink" title="3.IP地址的计算"></a>3.IP地址的计算</h4><ol><li>区分网络号和主机号——根据子网掩码</li><li>网络地址 =  IP地址 &amp; 子网掩码（全1）  </li><li>广播地址 = 网络地址的基础上，主机位地址全变1</li><li>子网主机个数 = 2^(主机地址位数) - 2（网络地址+广播地址）</li></ol><ul><li>第一个主机IP = 网络地址 + 1</li><li>最后一个主机IP = 广播地址 - 1</li></ul><p><strong>例题1：202.112.14.137/255.255.255.224，计算对应网络地址、广播地址、主机数</strong></p><p>202.112.14.137  ——202_112_14_1000 1001</p><p>255.255.255.224——255_255_255_1110 0000</p><p>网络地址：IP地址的前27位——202.112.14.1000 0000——202.112.14.128</p><p>广播地址：202.112.14.1001 1111</p><p>主机数：2的5次 - 2 = 30台</p><p><strong>例题2：206.110.4 .0/18被划分成16个子网，每个子网掩码多少台主机？</strong></p><p><strong>子网划分的目的</strong>：子网的划分通过不同的子网掩码——解决IPv4地址的紧缺</p><p>解题：206.110.4 .0/18——主机数量 2^(32-18) / 16 = 2^(10)</p><hr><h4 id="3-网络层的地址解析协议"><a href="#3-网络层的地址解析协议" class="headerlink" title="3.网络层的地址解析协议"></a>3.网络层的地址解析协议</h4><p>  <code>ARP地址解析协议</code>——IP地址求MAC地址：主机对网络上的所有主机进行广播，发送包含IP地址的地址解析请求，并保存获得反馈mac地址，从而主机间便可以通信。</p><p><code>RARP逆地址解析协议</code>——向服务器问询自己MAC地址对应的IP地址</p><hr><h4 id="4-网络层的路由选择协议"><a href="#4-网络层的路由选择协议" class="headerlink" title="4.网络层的路由选择协议"></a>4.网络层的路由选择协议</h4><p>  <code>路由选择协议定义</code>：两台非直连的计算机经过几个网络通信时，需要路由器来找寻一条最优化的路线。</p><p><code>RIP路由信息协议</code>：用于网络设备之间交换路由信息，是向量-距离路由选择算法在局域网上的：自接实现。</p><p><code>OSPF开放式最短路经优先协议</code>：OSPF采用的是一种链路-状态算法，并因此克服了RIP协议和其他采用距离矢量算法协议的方法。</p><p>路由协议包括：</p><ul><li><p>IGP内部网关协议——RIP协议_UDP，OSPF协议_IP报文</p></li><li><p>EGP外部网关协议——BGP协议_TCP</p><hr><h4 id="5-ICMP和IGMP—IP协的子协议"><a href="#5-ICMP和IGMP—IP协的子协议" class="headerlink" title="5.ICMP和IGMP—IP协的子协议"></a>5.ICMP和IGMP—IP协的子协议</h4></li></ul><p><code>ICMP—Internet控制报文协议</code>：它是TCP/IP协议簇的一个子协议，用于在IP主机、路由器之间传递控制消息。</p><p><code>IGMP—Internet 组管理协议称为IGMP协议</code>：是因特网协议家族中的一个组播协议。该协议运行在主机和组播路由器之间。IGMP协议共有三个版本，即IGMPv1、v2 和v3。</p><hr><h3 id="传输层："><a href="#传输层：" class="headerlink" title="传输层："></a>传输层：</h3><p>  网络层实现了<strong>端口到端口</strong>的数据传输，而传输层则更近一步提供进程间端口到端口的连接通信。</p><p>  <strong>流量控制（滑动窗口，拥塞窗口）、差错控制（确认重传）、健壮IP不可靠传输</strong></p><ul><li><p>定义：</p><ul><li><p>A_单个主机运行多个进程，所以传输层具有复用和分用功能。</p></li><li><p>B_传输层具有流量控制、差错控制来保证数据传输的可靠性。</p></li><li><p>C_解决和健壮网络层提供的不可靠服务（重复、丢包）</p></li></ul></li><li><p>主要协议：TCP协议（传输控制协议），UDP协议（用户数据报协议）</p></li><li><p>设备：网关，又称协议转换器——用于高层协议不同的网络互联。（数据重新打包，满足不同网络的互联）</p></li></ul><p>实质上是一个网络通向其他网络的IP地址。<br>比如有网络A和网络B，网络A的IP地址范围为“192.168.1.1_192. 168.1.254”，子网掩码为255.255.255.0；网络B的IP地址范围为“192.168.2.1_192.168.2.254”，子网掩码为255.255.255.0。而要实现这两个网络之间的通信，则必须通过网关。</p><hr><h4 id="1-说一下啊TCP-IP协议"><a href="#1-说一下啊TCP-IP协议" class="headerlink" title="1.说一下啊TCP / IP协议"></a>1.说一下啊TCP / IP协议</h4><p>TCP / IP协议是互联网最基本的协议，由网络层的IP协议和传输层的TCP协议组成。</p><p>简单来说：他们分工明确，网络层的IP协议负责数据端到端的传输，将数据从源地址传递到目标地址。</p><p>在此基础上，传输层的TCP协议通过流量控制、差错控制等，健壮IP协议不可靠的传输，同时进一步的实现进程间端口到端口的传输。</p><p>TCP协议：</p><ol><li><p>面向端口到端口的通信协议，通过三次握手建立连接和四次挥手结束连接。</p></li><li><p>是一种可靠的数据流服务，采用“确认重传”技术来实现传输的可靠性。TCP还采用一种称为“滑动窗口”的方式进行流量控制，所谓窗口实际表示接收能力，用以限制发送方的发送速度。</p><p> ————稳定可靠，确认重传，流量控制，快速重传。</p><hr><h4 id="2-TCP报文"><a href="#2-TCP报文" class="headerlink" title="2.TCP报文"></a>2.TCP报文</h4><p><img src="/pictures/clipboard9.png" alt="img1"></p></li></ol><h4 id="3-TCP建立和断开连接—握手握的是双方数据原点的序列号seq"><a href="#3-TCP建立和断开连接—握手握的是双方数据原点的序列号seq" class="headerlink" title="3.TCP建立和断开连接—握手握的是双方数据原点的序列号seq"></a>3.TCP建立和断开连接—握手握的是双方数据原点的序列号seq</h4><p>  <img src="/pictures/clipboard10.png" alt="img1"></p><ul><li><p>ACK:”acknowledge”确认号；SYN:”synchronize”请求同步标志；</p></li><li><p>FIN：”Finally”结束标志；seq:序列号——————都带有序列号</p></li></ul><p><strong><font size=6>建立连接：三次握手</font></strong></p><p>A            SYN  seq=x    -》                     B               </p><p>A        《- ACK  seq=x+1   SYN  seq=y           B     </p><p>A            ACK  seq=y+1    -》                B      </p><ul><li><p><strong>总结</strong>：</p></li><li><p>客户端向服务发送<strong>请求</strong>连接报文,并*<em>同步起始序列号 *</em> </p></li><li><p>服务器收到后，回复<strong>确认</strong>报文，并*<em>同步起始序列号 *</em> </p></li><li><p>客户端收到后也发送<strong>确认</strong>报文。连接建立</p></li></ul><p>**<font size=6>为什么要三次握手？——面向字节的连接，依靠序列号</font> **</p><p>所以建立可靠的连接，需要确认客户端和服务器的起始序列号。而二次握手只确认了客户端的起始序列号。所以不能保证可靠的连接。</p><p><strong>例子</strong>：——客户端请求延迟、服务器回复丢失导致开始无限发送</p><ul><li><p>原理：客户端发送延迟</p></li><li><p>1.浪费资源——客户端发送的请求连接包由于传输问题阻塞，延时传递到了，此时服务器还是会和其建立连接。但是客户端已经放弃了这个连接，而服务器则会为这个连接浪费资源。</p></li><li><p>原理：服务器确认报文丢失</p></li><li><p>2.服务器资源发生死锁——客户端请求连接，服务器回应建立连接。但是服务器的应答传送失败。而服务器认为传递成功，开始传递数据，客户端则不会接收。服务器无线重复发送，资源形成死锁。  </p></li></ul><hr><p>**<font size=6> 断开连接：四次挥手</font> **<br><img src="/pictures/clipboard11.png" alt="img1"></p><ul><li><p>A                FIN  seq=x+2    -》            B</p></li><li><p>A             《- ACK  seq=x+3                B</p></li><li><p>A             《- FIN  seq=y+1                B</p></li><li><p>A                ACK  seq=y+2    -》            B</p></li><li><p>四次挥手：————主动关闭方</p><ul><li><p>1.客户端向服务器发送FIN报文，请求中断——表示我的数据传输完成了</p></li><li><p>2.服务器向客户端发送确认报文——表示当我的数据传输完了再中断</p></li><li><p>客户端进入FIN_WAIT——终止等待状态</p></li><li><p>3.服务器向客户端发送FIN报文——表示我的数据也传输完了</p></li><li><p>4.客户端向服务器发送确认报文，——表示可以断开连接</p></li><li><p>客户端进入TIME_WAIT状态，等待2MSL，确认服务器是否收到了确认报文。如果没收到，客户端会再次发送FIN指令。所以服务器先关闭，后客户端再关闭。</p></li></ul></li></ul><p><strong>重要：如果没有TIME_WAIT状态，最后一次ACK丢失，客户端直接CLOSE，服务器会一直发送FIN</strong></p><p>MSL——报文最大生存周期</p><p>**<font size=6> 为什么要四次挥手？</font> **</p><p>因为服务器和客户端双方<strong>都可以发送和接收数据</strong>，是<strong>全双工模式</strong>，接收到FIN时意味一方完成了数据的收发，但是另一方未知。所以需要保证双方的发送和接收数据都完成了才能断开连接。</p><p>使用TCP的协议：FTP文本传输协议，Telent远程登陆协议，SMTP简单邮件传输协议，POP3邮箱协议，HTTP协议等。</p><hr><h4 id="4-UDP协议——用户数据协议-TCP协议—传输控制协议"><a href="#4-UDP协议——用户数据协议-TCP协议—传输控制协议" class="headerlink" title="4.UDP协议——用户数据协议 / TCP协议—传输控制协议"></a>4.UDP协议——用户数据协议 / TCP协议—传输控制协议</h4><ul><li>UDP协议是用户数据协议，是面向无连接的通讯协议。由于通讯不需要连接，所以可以实现广播发送。</li><li>UDP不需要接收方确认，属于不可靠的连接，可能产生丢包等现象。UDP信息包8个字节，TCP20字节。</li><li>UDP和TCP同属一层，但是它不管数据包的顺序，错误或重发。其主要面向的是那些以查询—应答的服务，如NFS（共享文件）、视频直播等。</li></ul><p>两者区别：</p><ol><li>TCP面向连接的，<strong>可靠的字节流服务</strong></li><li>UDP面向无连接的，<strong>不可靠的数据报服务</strong>——只知道：接收端IP和端口，所以每次只能读取一个报文数据</li></ol><hr><h4 id="5-传输层——NAT协议——网络地址转换协议"><a href="#5-传输层——NAT协议——网络地址转换协议" class="headerlink" title="5.传输层——NAT协议——网络地址转换协议"></a>5.传输层——NAT协议——网络地址转换协议</h4><p>NAT网络协议属于接入广域网的一种技术，将私有地址转换为IP地址，广泛运用于各种互联网接入上。</p><p>网关利用网络地址转换协议，<strong>有效地解决了IP地址不够地问题</strong>，同时也可以避免计算机收到网络的攻击。——（对外隐藏内部IP地址，减少IP减少IP地址产生的费用）</p><ul><li>A类 10.0.0.0/8， 即10.0.0.0–10.255.255.255</li><li>B类 172.16.0.0/12， 即172.16.0.0–172.31.255.255</li><li>C类 192.168.0.0/ 16， 即192.168.0.0–192.168.255.255</li></ul><hr><h3 id="会话层（建立管理对话）、表示层（为应用层翻译）："><a href="#会话层（建立管理对话）、表示层（为应用层翻译）：" class="headerlink" title="会话层（建立管理对话）、表示层（为应用层翻译）："></a>会话层（建立管理对话）、表示层（为应用层翻译）：</h3><p><code>会话层</code>：在传输层基础上，<strong>帮助进程建立并管理对话。</strong></p><p><code>表示层</code>：<strong>对传送的数据进行操作</strong>，包括转换、加密、压缩等，以保证被其他应用层理解。</p><h3 id="应用层："><a href="#应用层：" class="headerlink" title="应用层："></a>应用层：</h3><p><code>定义</code>：为网络进程提供访问网络的接口。同时规定应用在通讯时，所需遵守的协议</p><p><code>数据传输单位</code>：报文</p><p><code>主要协议</code>：FTP文件传送协议，Telnet远程登陆协议，DNS域名解析协议，SMTP邮件传送协议，POP3邮局协议，HTTP超文本传输协议。</p><hr><p><strong>DNS域名解析协议—应用层</strong></p><ul><li><p>DNS域名解析协议：简单来说就是将URL域名转换为IP地址。</p></li><li><p>域名是由圆点分开的一串字母单词组成的，每个域名都对应一个唯一的IP地址。<br>DNS服务器之间传输时使用TCP，而客户端与DNS服务器之间传输时用的是UDP</p></li></ul><hr><p><strong>DHCP协议—应用层协议，使用UDP协议</strong></p><ul><li><p>DHCP动态主机设置协议（Dynamic Host Configuration Protocol）是一个局域网的网络协议，使用UDP协议工作。</p></li><li><p>主要有两个用途：<strong>给内部网络或网络服务供应商自动分配IP地址</strong>，给用户或者内部网络管理员作为对所有计算机作中央管理的手段。</p></li></ul><hr><p><strong>HTTP协议 / 超文本传输协议</strong></p><ul><li><p>是互联网上运用最广泛的一种协议，所有万维网的数据通信必须遵守它。</p></li><li><p>是一个客户端与服务器请求和应答的标准。</p></li><li><p>我们通过浏览器等工具发起http请求到指定服务器，然后获取我们所想要浏览的信息。</p></li></ul><hr><h2 id="具体问题"><a href="#具体问题" class="headerlink" title="具体问题"></a>具体问题</h2><h3 id="问题：1-HTTP协议包括哪些请求？"><a href="#问题：1-HTTP协议包括哪些请求？" class="headerlink" title="问题：1.HTTP协议包括哪些请求？"></a>问题：1.HTTP协议包括哪些请求？</h3><p>主要包括四种和服务器交互的方法：GET、POST、PUT、DELETE</p><p><strong>GET、POST区别：</strong></p><p>理解方式：货车和运输公司的关系，货物放在车顶，车厢内，允许不允许超载，卸货</p><ul><li><p>HTTP协议是基于TCP/IP协议的，GET和POST本质上都是TCP连接。但是其在请求方式上存在差异。</p></li><li><p>GET请求的数据存放在请求URL中，而POST存放在请求包体中</p></li><li><p>一般浏览器对请求URL长度有限制，所以导致GET请求获取的数据一般比POST少</p></li><li><p>同时由于请求数据暴露，所以使得GET的安全性也较低。</p></li><li><p>同时GET请求产生一个TCP数据报，而POST产生两个，对于验证数据的完整性更好。</p></li></ul><p>GET——请求header和请求data一起发送——返回200</p><p>POST——请求header先发送——返回100——再发送请求data——返回200</p><hr><h3 id="2-HTTP的请求和响应"><a href="#2-HTTP的请求和响应" class="headerlink" title="2.HTTP的请求和响应"></a>2.HTTP的请求和响应</h3><p>HTTP请求的格式包含：</p><p>（method—请求方法） （request—URL请求URL） （version—HTTP报文版本）</p><p>（headers—请求头部）</p><p>（entity-body—请求数据）</p><p>HTTP响应的格式包含：</p><p>（version） （status—请求过程状态） （reason-phrase）</p><p>（headers）</p><p>（entity-body）</p><p>常用响应码：</p><p>100——<code>状态码</code>。返回消息</p><p>200—<code>（成功）</code>服务器成功处理请求</p><p>301/302 Moved Permanently—<code>（域名不存在）</code>请求的域名已被移走，这个域名不存在了</p><p>304 Not Modified<code>（未修改）</code> 表示客户所请求的缓存资源是最新的，无需修改</p><p>404 Not Found <code>未找到资源</code></p><p>501 Internal Server Error<code>（服务器遇到错误）</code>服务器发生故障，无法对请求提供服务</p><hr><h3 id="3-数字证书相关问题——网页加密"><a href="#3-数字证书相关问题——网页加密" class="headerlink" title="3.数字证书相关问题——网页加密"></a>3.数字证书相关问题——网页加密</h3><p>数字证书：由证书中心CA的颁布，是网站对应的权威公共钥匙，用于验证网站发送的数字签名。</p><p>客户端       ————请求———&gt;                  服务器</p><p>客户端  &lt;—————数字证书 + 网页———      服务器</p><p>客户端    &lt;—————网页 + 数字签名—————   服务器</p><p>客户端根据数字证书获得的公钥，然后利用公钥验证数字签名，确认是从对应的服务器发送来的数据。</p><p>总结：</p><ul><li>私钥——<strong>用于生成数字签名</strong>  +  解密      </li><li>公钥——*<em>用于验证数字签名 *</em> +  解密</li></ul><hr><h3 id="问题1-浏览器输入域名访问的整个过程"><a href="#问题1-浏览器输入域名访问的整个过程" class="headerlink" title="问题1.浏览器输入域名访问的整个过程"></a>问题1.浏览器输入域名访问的整个过程</h3><p>首先客户端获取URL - &gt; DNS解析 - &gt; </p><p>TCP请求连接 - &gt;客户端发送HTTP请求 - &gt;服务端响应HTTP请求 - &gt;</p><p>浏览器获得html代码 - &gt;浏览器解析html代码，并请求html代码中的资源 - &gt;</p><p>浏览器解析渲染页面 - &gt;</p><p>TCP断开连接<br> <img src="/pictures/clipboard12.png" alt="img1"></p><hr><h3 id="问题2-TCP怎么保证可靠，以及它建立和断开的过程"><a href="#问题2-TCP怎么保证可靠，以及它建立和断开的过程" class="headerlink" title="问题2.TCP怎么保证可靠，以及它建立和断开的过程"></a>问题2.TCP怎么保证可靠，以及它建立和断开的过程</h3><ul><li>1.三次握手和四次挥手保证连接和断开的正确性</li><li>2.校验和：将发送前的数据和发送后数据进行计算，比较结果</li><li>3.确认重传：接收方会告诉发送方接收了到了哪些数据，哪些数据是不完整的需要重新传递，保证数据的完整性。</li><li>4.流量控制：会根据ACK报头的窗口大小进行速度的调整</li><li>5.拥塞窗口：采用慢启动方法，先少量数据探路，再决定多大传输速度。定义了拥塞窗口概念：刚开始为1，逐渐增大，同时会和反馈获得的窗口大小进行比较，取小值</li></ul><p><strong>三次握手建立连接：</strong></p><ul><li>客户端向服务器发送请求连接报文 + 序列号</li><li>服务器收到后向客户端发送确认报文，并同步客户端起始序列号</li><li>客户端向服务器确认其发送序列号，并同步服务器起始序列号</li></ul><p><strong>四次挥手断开连接：</strong></p><p>由于TCP连接是双工模式，即客户端和服务器都可以收发数据，所以需要双方同时满足收发完成，才可以断开连接。</p><ol><li>首先客户端向服务器发送请求终止报文，进入FIN  _WAIT状态——表示我的数据接受完成可以断开</li><li>服务器根据回复确认报文——表示当我的数据接收完成后，再次确认</li><li>服务器数据接收完成后，向客户端发送终止报文——表示我的数据接收完成，可以关闭</li><li>客户端接收到服务器的FIN报文后，进入TIME_WAIT状态，等待两个周期的报文最长生存时间，如果此阶段未收到服务器信息，说明没有问题，断开连接。</li></ol><hr><h3 id="问题3-说一说TCP模型，状态转移"><a href="#问题3-说一说TCP模型，状态转移" class="headerlink" title="问题3.说一说TCP模型，状态转移"></a>问题3.说一说TCP模型，状态转移</h3><p>五层从下到上：物理层，数据链路层，网络层，传输层，应用层</p><p>3次握手建立连接，传输数据，4次挥手断开连接。</p><hr><h3 id="问题3-1请回答一下HTTP和HTTPS的区别，以及HTTPS有什么缺点？"><a href="#问题3-1请回答一下HTTP和HTTPS的区别，以及HTTPS有什么缺点？" class="headerlink" title="问题3.1请回答一下HTTP和HTTPS的区别，以及HTTPS有什么缺点？"></a>问题3.1请回答一下HTTP和HTTPS的区别，以及HTTPS有什么缺点？</h3><ol><li>HTTP协议是以明文的方式在网络中传输的，而HTTPS传输的数据是经过TLS加密的，HTTPS具有更高的安全性</li><li>HTTPS在三次握手之后，需要进行SSL的握手，协商后加密使用的对称加密密钥</li><li>HTTPS需要服务端申请证书，浏览器安装相应证书。</li><li>HTTP协议端口是80，HTTPS是443</li></ol><ul><li>HTTPS优点：A数据加密安全性更高，B协议可以认证用户和服务器，确保数据发送到正确的用户和服务器。</li><li>HTTPS缺点：<ul><li>A：握手阶段增加SSL握手，延时增加</li><li>B：部署成本较高：使用证书来验证安全，需要购买CA证书。</li><li>C：采用HTTPS协议需要进行加密解密计算，对服务器要求也更高</li></ul></li></ul><hr><h3 id="问题3-2请你说一说HTTP返回码"><a href="#问题3-2请你说一说HTTP返回码" class="headerlink" title="问题3.2请你说一说HTTP返回码"></a>问题3.2请你说一说HTTP返回码</h3><ul><li>100——状态码。返回消息</li><li>200—（成功）服务器成功处理请求</li><li>301/302 Moved Permanently—（域名不存在）请求的域名已被移走，这个域名不存在了</li><li>304 Not Modified（未修改） 表示客户所请求的缓存资源是最新的，无需修改</li><li>404 Not Found 未找到资源</li><li>501 Internal Server Error（服务器遇到错误）服务器发生故障，无法对请求提供服务</li></ul><hr><h3 id="问题4-请你说一说IP地址作用，以及MAC地址作用"><a href="#问题4-请你说一说IP地址作用，以及MAC地址作用" class="headerlink" title="问题4.请你说一说IP地址作用，以及MAC地址作用"></a>问题4.请你说一说IP地址作用，以及MAC地址作用</h3><p>MAC地址是一个硬件地址，又称网卡地址，来定义网络设备的位置，由生产制造商写在硬件内部，位于数据链路层。</p><p>IP地址（用逻辑地址屏蔽物理地址）是IP协议提供的一种地址格式，它给每个网络和每台主机分配一个逻辑地址，用于屏蔽物理地址的差异。</p><hr><h3 id="问题5-请回答OSI七层模型和TCP-IP四层模型，每层列举2个协议"><a href="#问题5-请回答OSI七层模型和TCP-IP四层模型，每层列举2个协议" class="headerlink" title="问题5.请回答OSI七层模型和TCP/IP四层模型，每层列举2个协议"></a>问题5.请回答OSI七层模型和TCP/IP四层模型，每层列举2个协议</h3><p>OSI七层模型：</p><ul><li>应用层：为应用程序提网络服务接口。主要协议HTTP，HTTPS，FTP，DNS</li><li>展示层：对数据进行翻译；JPEG ASII</li><li>会话层：建立，管理，终止会话；NFS ，RPC</li><li>传输层：提供端口到端口的可靠报文传递：UDP，TCP</li><li>网络层：提供端到端的传输。传递路径选择和优化传输：IP协议，ARP</li><li>数据链路层：提供点到点的数据帧传递：MAC，VLAN</li><li>物理层：提供硬件支持，消除设备间的物理差异，传输比特流，主要协议RJ45</li></ul><p>TCP/IP模型：</p><ul><li>应用层HTTP  DNS  </li><li>传输层UDP TCP</li><li>网络层IP ARP</li><li>数据链路层：MAC，VLAN</li></ul><hr><h3 id="问题6-输入一个网址，计算机都用到了哪些层"><a href="#问题6-输入一个网址，计算机都用到了哪些层" class="headerlink" title="问题6.输入一个网址，计算机都用到了哪些层"></a>问题6.输入一个网址，计算机都用到了哪些层</h3><p>TCP/IP协议中的五个层都用到了。</p><p>首先客户端获取URL - &gt; DNS解析 - &gt; （应用层的https超文本传输协议，DNS域名解析协议）</p><p>TCP请求连接 - &gt;客户端发送HTTP请求 - &gt;服务端响应HTTP请求 - &gt;</p><p>浏览器获得html代码 - &gt;浏览器解析html代码，并请求html代码中的资源 - &gt;浏览器解析渲染页面 - &gt;</p><p> TCP断开连接</p><p>（传输层的TCP协议 / 网络层的IP协议、ARP地址解析协议）<br>（底层数据的传输用到了数据链路层和物理层，提供硬件支持，同时传递数据）</p><hr><h3 id="问题7-说一下TCP中的拥塞控制？说明时候开始慢慢增长"><a href="#问题7-说一下TCP中的拥塞控制？说明时候开始慢慢增长" class="headerlink" title="问题7.说一下TCP中的拥塞控制？说明时候开始慢慢增长"></a>问题7.说一下TCP中的拥塞控制？说明时候开始慢慢增长</h3><ul><li><p>网络层：路径选择、流量控制</p></li><li><p>传输层：确认重传、滑动窗口、拥塞控制</p></li><li><p>拥塞：是防止服务器和客户端之间过多的数据传输，使得网络中的路由器和链路发生过载而瘫痪。</p><ol><li><p>首先慢开始 ，出现拥塞情况，慢启动极限变为一半，拥塞窗口重新从0开始增加）</p></li><li><p>快速重传和快速恢复</p></li></ol></li></ul><hr><h3 id="问题8-说一下数据链路层的交互过程）——-通过MAC地址交互"><a href="#问题8-说一下数据链路层的交互过程）——-通过MAC地址交互" class="headerlink" title="问题8.说一下数据链路层的交互过程）—— 通过MAC地址交互"></a>问题8.说一下数据链路层的交互过程）—— 通过MAC地址交互</h3><p>网络层到数据链路层采用MAC地址作为通信地址。</p><p>数据包从网络层准备发往数据链路层时，首先会去地址缓存表中查找相应的ip_mac对应关系表，如果查到了就将ip的mac地址封装到链路层数据包的包头。</p><p>如果没有，就采用<strong>广播的形式</strong>，查找相应ip的mac地址，相应的主机收到广播后会回复自己IP对应得mac地址。</p><hr><h3 id="问题9-说一下数据传递到IP层如何知道报文传递给哪个应用程序，它怎么区分UDP还是TCP报文"><a href="#问题9-说一下数据传递到IP层如何知道报文传递给哪个应用程序，它怎么区分UDP还是TCP报文" class="headerlink" title="问题9.说一下数据传递到IP层如何知道报文传递给哪个应用程序，它怎么区分UDP还是TCP报文"></a>问题9.说一下数据传递到IP层如何知道报文传递给哪个应用程序，它怎么区分UDP还是TCP报文</h3><p>根据端口区分给哪个应用。</p><p>根据报文头中的协议标识字段，17 / UDP，6 / TCP</p><hr><h3 id="问题10-SOCKET具体的网络层是如何操作的"><a href="#问题10-SOCKET具体的网络层是如何操作的" class="headerlink" title="问题10.SOCKET具体的网络层是如何操作的"></a>问题10.SOCKET具体的网络层是如何操作的</h3><p> <img src="/pictures/clipboard13.png" alt="img1"></p><p> <strong>首先服务器需要打开</strong></p><p>服务端：</p><ol><li>创建socket套接字</li><li>bind将本机地址绑定套接字</li><li>listen设置此套接字可最大连接的客户端</li><li>accept开始监听等待客户端的连接</li></ol><p>客户端：</p><ol><li>socket创建套接字</li><li>connect发送请求连接的请求</li></ol><p>建立连接后Recv / Send</p><hr><h3 id="问题11-服务端监听的端口，但是还没有客户端连接进来，此时处于什么状态"><a href="#问题11-服务端监听的端口，但是还没有客户端连接进来，此时处于什么状态" class="headerlink" title="问题11.服务端监听的端口，但是还没有客户端连接进来，此时处于什么状态"></a>问题11.服务端监听的端口，但是还没有客户端连接进来，此时处于什么状态</h3><p>需要看用到了什么编程模型，如果是socket中的recv，一般是阻塞状态，而epoll，select等这样的io复用情况则是处于运行状态。</p><hr><h3 id="问题12-TCP和UDP个自适应的场景"><a href="#问题12-TCP和UDP个自适应的场景" class="headerlink" title="问题12.TCP和UDP个自适应的场景"></a>问题12.TCP和UDP个自适应的场景</h3><ul><li>TCP是面向连接的，可靠的字节流服务。</li><li>UDP是面向无连接的，不可靠的数据包服务。</li><li>UDP可以一对多，TCP为端口对端口。</li><li>TCP的开销为20个字节，UDP8个字节。</li></ul><p>综上UDP快，但是不可靠。TCP慢，但是可靠</p><ul><li>TCP用于——要求准确的文件传输</li><li>UDP用于——视频传输、实时通信、广播通信等。</li></ul><hr><h3 id="问题13-说一下HTTP协议"><a href="#问题13-说一下HTTP协议" class="headerlink" title="问题13.说一下HTTP协议"></a>问题13.说一下HTTP协议</h3><ul><li><p>HTTP协议是超文本传输协议，是从万维网服务器到本地浏览器的超文本传输协议。</p></li><li><p>基于TCP / IP通信协议来传输数据的。属于应用层面向对象的协议，适用于分布式超媒体信息系统。HTTP协议工作于客户端和服务端架构上。</p></li><li><p>浏览器作为HTTP的客户端通过URL向WEB服务器发送请求，WEB服务器根据接收到的请求后，向客户端发送响应信息及传输数据。</p></li></ul><hr><h3 id="问题14-说一下HTTP协议中GET和POST的区别"><a href="#问题14-说一下HTTP协议中GET和POST的区别" class="headerlink" title="问题14.说一下HTTP协议中GET和POST的区别"></a>问题14.说一下HTTP协议中GET和POST的区别</h3><p>http主要包括四种和服务器交互的方法：GET、POST、PUT、DELETE</p><p><strong>GET、POST区别：</strong></p><p>理解方式：货车和运输公司的关系，货物放在车顶，车厢内，允许不允许超载，卸货</p><ul><li><p>HTTP协议是基于TCP/IP协议的，GET和POST本质上都是TCP连接。但是其在请求方式上存在差异。</p></li><li><p>GET请求的数据存放在请求URL中，而POST存放在请求包体中</p></li><li><p>一般浏览器对请求URL长度有限制，所以导致GET请求获取的数据一般比POST少</p></li><li><p>同时由于请求数据暴露，所以使得GET的安全性也较低。</p></li><li><p>同时GET请求产生一个TCP数据报，而POST产生两个，对于验证数据的完整性更好。</p></li></ul><p>GET——请求header和请求data一起发送——返回200</p><p>POST——请求header先发送——返回100——再发送请求data——返回200</p><hr>]]></content>
      
      
      <categories>
          
          <category> learn </category>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>基础概念 / 操作系统 </title>
      <link href="/2020/07/13/inter2/"/>
      <url>/2020/07/13/inter2/</url>
      
        <content type="html"><![CDATA[<h2 id="核心：CPU管理、内存管理"><a href="#核心：CPU管理、内存管理" class="headerlink" title="核心：CPU管理、内存管理"></a>核心：CPU管理、内存管理</h2><p><img src="/pictures/clipboard.png" alt="img1"></p><h2 id="操作系统概念"><a href="#操作系统概念" class="headerlink" title="操作系统概念"></a>操作系统概念</h2><h3 id="1-操作系统主要内容：定义（CPU管理、内存管理）"><a href="#1-操作系统主要内容：定义（CPU管理、内存管理）" class="headerlink" title="1.操作系统主要内容：定义（CPU管理、内存管理）"></a><strong>1.操作系统主要内容：定义（CPU管理、内存管理）</strong></h3><ul><li>定义：用于控制和管理计算机的硬件和软件，合理调度CPU和内存等资源，分配给用户和其他软件的接口和环境</li><li>分类：分时操作系统，实时操作系统。<ol><li>分时操作系统（windows）——计算机以时间片为单位，轮流给各个用户服务。解决了人机交互问题。（各个用户通过终端与计算机交互）</li><li>实时操作系统（嵌入式）：计算机接收到外部信号后及时处理，触发马上反应。（即时性和可靠性）</li></ol></li></ul><hr><h3 id="2-操作系统的基本特性"><a href="#2-操作系统的基本特性" class="headerlink" title="2.操作系统的基本特性"></a><strong>2.操作系统的基本特性</strong></h3><ol><li>并发性：操作系统可以同时运行多个进程。不管是多核CPU还是单核CPU的计算机。（分时运行，分是获得CPU资源）</li><li>共享性：同时运行的进程可以共同使用系统中的资源。（互斥和同步访问）同步也是在互斥的基础上实现的访问机制。</li><li>异步性：进程不是一次性执行完成，而是走走停停的，但是最后结果不变。</li><li>虚拟性：虚拟是指将物理上的一个实体变为多个对应逻辑物。计算机中主要用于时分复用（CPU）和空分复用（虚拟内存）。</li></ol><p>补充：并发指的是多个程序同时运行，但是单核CPU穿插运行两个进程，通过时分复用来提高CPU的效率。<br>     并行指的是在多核CPU上分别运行进程，是并行运算提高计算机性能。</p><hr><h3 id="3-计算机的主要功能"><a href="#3-计算机的主要功能" class="headerlink" title="3.计算机的主要功能"></a><strong>3.计算机的主要功能</strong></h3><ol><li>CPU管理——合理分配CPU资源，进行进程管理：进程同步，通信、调度等</li><li>内存管理——对内存和虚拟内存管理：合理分配内存空间，进程间不发生死锁等异常情况。</li><li>文件管理——系统、用户文件的管理</li><li>IO设备管理——对外围设备的管理，分配接口等</li></ol><hr><h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><p>线程：是CPU调度的最小单位。</p><p>进程：是系统资源调度分配基本单位。</p><h3 id="1-进程定义"><a href="#1-进程定义" class="headerlink" title="1.进程定义"></a><strong>1.进程定义</strong></h3><p>进程定义：进程是对运行程序的封装，一个进程可以包含一个或多个程序。进程是系统资源调度的基本单位。运行的微信、QQ都是一个进程。</p><p>生命周期：（获得其他资源和CPU资源的过程）</p><ol><li>新建：未获得资源</li><li>就绪：获得其他资源，等待CPU资源</li><li>运行：获得其他资源，获得CPU资源</li><li>阻塞：等待触发事件以获得时间片资源，CPU空闲也不会运行</li><li>终止：退出，释放所有资源<br><img src="/pictures/clipboard1.png" alt="img2"></li></ol><p><strong>CPU资源以时间片来分配</strong></p><hr><h3 id="2-进程和程序的关系"><a href="#2-进程和程序的关系" class="headerlink" title="2.进程和程序的关系"></a><strong>2.进程和程序的关系</strong></h3><p>程序由一系列代码组成。而进程由程序、程序包含的数据，进程块组成。<br>从广度上看，进程是程序的动态体现，程序是进程的静态体现，两者相辅相成。<br>程序构建进程，进程执行程序。</p><h3 id="3-进程间的通信方式——作用——共享内存-套接字-信号-信号量"><a href="#3-进程间的通信方式——作用——共享内存-套接字-信号-信号量" class="headerlink" title="3.进程间的通信方式——作用——共享内存/套接字/信号/信号量"></a><strong>3.进程间的通信方式——作用——共享内存/套接字/信号/信号量</strong></h3><ol><li>管道通信pipe：多用于父子进程间通信</li><li>信号signal：通过接收事件信号，告知进程某事已经发生</li><li>共享内存shared memory：应用最为广泛，进程间通过共享内存上数据的更新，获得信息。</li><li>信号量：用于进程中不同线程的同步</li><li>套接字socket：不同计算机进程间的通信</li></ol><p>作用：A.数据传输及共享   B事件通知    C进程控制</p><h3 id="4-进程同步-调度算法——进程获得CPU资源的先后执行顺序——CPU分配"><a href="#4-进程同步-调度算法——进程获得CPU资源的先后执行顺序——CPU分配" class="headerlink" title="4.进程同步 / 调度算法——进程获得CPU资源的先后执行顺序——CPU分配"></a><strong>4.进程同步 / 调度算法——进程获得CPU资源的先后执行顺序——CPU分配</strong></h3><p>多进程提高了CPU的利用率，但是进程的异步性会给系统造成混乱。进程同步就是：协调进程间的执行顺序，使得并发的进程间可以有效的共享资源、相互合作。</p><p>总结：多进程的异步性造成系统混乱，我们需要协调进程执行顺序，让进程间有效共享资源，相互合作。</p><p>进程调度算法：CPU分配算法<br>主要指标：CPU利用率、系统吞吐量、周转时间、等待时间、响应时间等</p><ul><li>A.先来先服务算法（FCFS）：先来先服务调度算法，队列实现</li><li>B.短作业优先算法（SJF）：优先进行预估时间较短的进程（平均等待时间，周转时间最少）</li><li>C.优先级调度算法：优先级越高的，先分配到CPU</li><li>D.最高响应比算法（HRN）： 根据响应比决定优先级，响应比=(等待时间+要求服务时间)/要求服务时间；(兼顾长作业和短作业)</li><li>E.时间片轮转调度（RR）： 按到达的先后对进程放入队列中，依次分配相同的时间片，时间片用完，马上剥夺CPU</li><li>F.多级反馈队列调度算法（较好的算法）： 设置多个就绪队列，为每个队列赋予不同优先级，优先级不同分配的时间片也不同。第一个队列优先级最高，分配的时间片也越短。</li></ul><h3 id="6-死锁现象-处理死锁的方法"><a href="#6-死锁现象-处理死锁的方法" class="headerlink" title="6.死锁现象 / 处理死锁的方法"></a><strong>6.死锁现象 / 处理死锁的方法</strong></h3><p>死锁现象：多个进程争夺同一资源而陷入僵局，导致无法推进下去，进程无限阻塞，相互等待资源，最后卡死。</p><p>死锁原因：进程竞争资源，资源释放不合理</p><p>死锁产生的四大必要条件——发生死锁，四条至少一条成立</p><ul><li>—–1.互斥，2.请求和保持，3.不可剥夺，4.循环等待—–</li><li>互斥条件：一个资源每次只能被一个进程使用。</li><li>请求和保持条件：一个进程申请新资源时，对以旧资源不放</li><li>不可剥夺条件：进程获得资源在未使用完前，是不会释放它的</li><li>环路等待条件：若干进程之间形成一种头尾相接的环形等待资源关系</li></ul><p><strong>处理死锁的方法：打破四大条件</strong></p><ul><li>1.互斥条件不可打破</li><li>2.打破请和保持条件——实行预分配，只有满足进程所有资源要求时，才分配</li><li>3.打破不可剥夺条件——允许进程剥夺其他进程占有的资源，但是降低系统性能</li><li>4.打破环路等待条件——对资源进行编号，只有占用了小号资源才能申请大号资源。</li><li>基本思想都是：<strong>动态检测资源分配</strong>，从而保证系统处于安全状态。</li></ul><p>最常见的是<strong>银行家算法</strong>：检查申请者对资源的最大需求，如果各类资源都满足，就分配。这样可以很快完成计算，然后释放申请者申请的资源。</p><h3 id="7-临界资源的概念"><a href="#7-临界资源的概念" class="headerlink" title="7.临界资源的概念"></a><strong>7.临界资源的概念</strong></h3><p>共享性，让进程间可以共享系统资源。但是有的资源只能被单一进程使用，我们称其为临界资源。比如：打印机</p><p>临界资源的访问必须遵循互斥原则，访问临界资源的代码，我们称为临界区。</p><hr><h3 id="8-线程同步——按照某种特定顺序访问临界资源，避免线程冲突——内存资源分配"><a href="#8-线程同步——按照某种特定顺序访问临界资源，避免线程冲突——内存资源分配" class="headerlink" title="8.线程同步——按照某种特定顺序访问临界资源，避免线程冲突——内存资源分配"></a><strong>8.线程同步——按照某种特定顺序访问临界资源，避免线程冲突——内存资源分配</strong></h3><ul><li>1.临界区（用户态）Critical Section             WINDOWS特有</li><li>2.互斥量Mutex（内核态）</li><li>3.信号量Semaphore（限制访问某些资源的线程数量）</li><li>4.事件对象（内核）</li></ul><hr><ul><li>Linux线程同步方式：——无临界区<ol><li>互斥量  </li><li>信号量 </li><li>事件对象</li></ol></li></ul><hr><ul><li>Windows线程同步方式：<ol><li>互斥量  </li><li>临界区  </li><li>信号量  </li><li>事件对象</li></ol></li></ul><p><strong>tips：互斥和临界区采用互斥控制，拥有才会执行，执行完释放。</strong></p><p> <strong>信号量和事件对象采用通知控制，主要用于同步。</strong></p><hr><p>特点：</p><ul><li>A：临界区只能同步本进程内线程，（互斥量、信号量、事件）不可跨进程同步线程。</li><li>B：<ol><li>临界区在用户态下操作，速度快。</li><li>互斥量在内核态下进行锁操作，速度慢。</li></ol></li><li>C：Linux下不可以使用临界区</li></ul><hr><h3 id="9-线程简介"><a href="#9-线程简介" class="headerlink" title="9.线程简介"></a><strong>9.线程简介</strong></h3><p>线程是轻量化的进程，是进程组成的基本单位。不拥有系统所有资源，但是<strong>同一进程内的线程共享进程所有资源。</strong></p><p>线程组成：线程ID，当前指令指针，寄存器，堆栈。</p><ul><li>1.线程ID：用于表示线程</li><li>2.寄存器组的值：线程并发运行，切换时需要将原线程寄存器状态保存，用于重新切换时恢复。</li><li>3.堆栈：是保证线程独立运行的根本。线程函数可以调用函数，所以线程必须拥有自己的函数堆栈，而不受其他函数影响。位于进程的线程共享堆区内。（heap）</li><li>4.错误返回码</li><li>5.线程信号屏蔽码</li><li>6.线程优先级</li></ul><p>进程一般包含多个线程，所有线程间也存在着制约关系，有：就绪，阻塞，运行三种状态</p><hr><h3 id="10-进程和线程的区别"><a href="#10-进程和线程的区别" class="headerlink" title="10.进程和线程的区别"></a><strong>10.进程和线程的区别</strong></h3><ul><li><p>1.</p><ol><li>进程是程序的封装，是系统调度的基本单元，用于实现系统的并发性。</li><li>线程则是进程的子任务，是CPU调度的基本单元，用于实现进程的并发性。</li></ol></li><li><p>2.线程的开销比进程小很多，易于调度，多用可以提高CPU的利用率，提高程序并发性。</p></li><li><p>3.进程用于自己独立的内存空间，而线程至共享其父进程的内存空间。</p></li><li><p>4.父进程内的线程间可以直接通信，而进程间通信需要借助操作系统。</p></li></ul><h4 id="有了进程为什么还要线程？"><a href="#有了进程为什么还要线程？" class="headerlink" title="有了进程为什么还要线程？"></a><strong>有了进程为什么还要线程？</strong></h4><p>答：1.进程是系统调度的基本单元，而线程是CPU调度的基本单元。</p><p>2.在进程的基础上使用线程可以提高程序并发率，CPU的利用率，同时线程作为进程的子任务开销也较小。</p><p>3.进程拥有独立的内存空间，无法直接通信。而线程虽然没有独立的内存空间，但是父进程下的子线程都可以共享进程内数据，可以改善程序结构，提高计算效率。</p><hr><hr><h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><h3 id="1-内存管理"><a href="#1-内存管理" class="headerlink" title="1.内存管理"></a><strong>1.内存管理</strong></h3><ul><li>A：内存空间的分配与回收</li><li>B：地址转换——内存物理地址与逻辑地址的转换</li><li>C：内存空间的管理：虚拟内存和自动覆盖技术，逻辑上扩充内存。</li><li>D：内存保护：进程间的内存空间互不干扰</li></ul><hr><h3 id="2-逻辑地址和物理地址"><a href="#2-逻辑地址和物理地址" class="headerlink" title="2.逻辑地址和物理地址"></a><strong>2.逻辑地址和物理地址</strong></h3><p><strong>逻辑地址</strong>：程序编译后，每个模块都是从0单元开始编址的，称为模块的逻辑地址。当各个模块链接成一个完整可执行目标时，就成了逻辑地址。</p><p><strong>物理地址</strong>：内存物理地址的集合，它是地址转换的最终地址。</p><p><strong>地址重定位</strong>：进程在运行指令和访问数据时都需要物理地址来存取主存。必须将逻辑值转化为物理地址才能正确访问数据，此过程称为地址重定位。</p><hr><h3 id="3-内存分配的管理方式（分配程序空间）"><a href="#3-内存分配的管理方式（分配程序空间）" class="headerlink" title="3.内存分配的管理方式（分配程序空间）"></a><strong>3.内存分配的管理方式（分配程序空间）</strong></h3><p>A连续分配 / B非连续分配</p><h4 id="A连续分配：分配一个连续的内存空间"><a href="#A连续分配：分配一个连续的内存空间" class="headerlink" title="A连续分配：分配一个连续的内存空间"></a>A连续分配：分配一个连续的内存空间</h4><p> <strong>固定分区分配（产生内部碎片）</strong></p><p>示例：</p><p>分区A_10MB     分区B_10MB———内部碎片4和 6</p><p>进程A_6MB        进程B_4MB</p><p> <strong>动态分区分配（产生外部碎片）</strong></p><p>通过  “紧凑”  技术提高利用率，时间花销大。</p><h4 id="B非连续分配：将一个进程分散地装在不相邻的分区中，就无需再凑来节约空间。"><a href="#B非连续分配：将一个进程分散地装在不相邻的分区中，就无需再凑来节约空间。" class="headerlink" title="B非连续分配：将一个进程分散地装在不相邻的分区中，就无需再凑来节约空间。"></a>B非连续分配：将一个进程分散地装在不相邻的分区中，就无需再凑来节约空间。</h4><p><img src="/pictures/clipboard2.png" alt="img2"></p><p> *<em>基于分页的存储管理：（无外部碎片，极少数内部碎片） *</em></p><p>将内存分为一个一个相等的小块，再按照块大小拆分进程，放入内存。</p><hr><p><img src="/pictures/clipboard3.png" alt="img2"><br> *<em>基于分段的存储管理：（分配基本单位为逻辑上的段） *</em></p><p>进程的地址空间按照逻辑分为若干段，每段从0开始编址。以段为单位进行分配，每个段在内存中占据连续空间，但是各个段不相邻。</p><hr><p><strong>分页和分段的对比：————页大小固定，段不固定</strong></p><p>页是物理单位：为了实现内存的充分利用。是系统管理上的需要，对用户不可见。</p><p>段是逻辑单位：为了满足用户的逻辑习惯，以段进行分区包含一个逻辑模块。对用户可见，用户编程需要显示地给出段名。</p><p><strong>分页地址空间是一维的。</strong></p><p>分段地址空间则是二维的，程序员识别地址时，需要给出段名以及段内地址。</p><p>分段比分页更容易实现信息的共享和保护。</p><p><img src="/pictures/clipboard4.png" alt="img2"><br><strong>段页存储概念：先分段，再分页，内存管理仍采用分页存储管理。</strong></p><p>页式存储-&gt;提高内存利用效率</p><p>段式存储-&gt;反映程序的逻辑结构，利于段的共享和信息保护、程序可在执行时再动态链接</p><hr><h3 id="虚拟内存管理："><a href="#虚拟内存管理：" class="headerlink" title="虚拟内存管理："></a>虚拟内存管理：</h3><p>进程的<strong>驻留性</strong>，进程数据必须一次装进内存中，直至作业完成。这就导致了很多暂时不用的数据占据了内存大量空间。</p><p>虚拟内存概念：————内存 / 外寸 / 置换内存</p><p>基于<strong>局部性原理</strong>，将进程的部分数据装入<strong>内存</strong>，其余部分驻留<strong>外存</strong>，即可以运行程序。当进程需要外存中的数据时，我们将数据调入内存，置换出不需要的内存。这样就可以提供一个比实际物理内存大的多的存储器，称为虚拟内存。</p><p><strong>————需要的数据放入内存，暂时不需要的放置在外存。需要时再置换回内存。</strong></p><h4 id="1-虚拟内存的存储管理方式"><a href="#1-虚拟内存的存储管理方式" class="headerlink" title="1.虚拟内存的存储管理方式"></a>1.虚拟内存的存储管理方式</h4><p>分页存储管理，分段存储管理，段页存储管理。</p><p>使用最多的是分页管理方式，为了支持虚拟内存的管理，增加：1.请求调页功能  2.页面置换功能</p><p>需要的硬件支持：1.一定容量内存+外存 2.页表机制 3.终端机构 4.地址变换机构</p><h4 id="2-虚拟内存中的页面置换算法"><a href="#2-虚拟内存中的页面置换算法" class="headerlink" title="2.虚拟内存中的页面置换算法"></a>2.虚拟内存中的页面置换算法</h4><p>定义：在进程运行过程中，地址映射发现所访问的页不在内存中，将缺失的页从外存中点入内存中。但是当内存无空闲空间，需要移除页给准备进入的页腾位置。</p><p>常用的置换算法：</p><p>1.OPT——<strong>最佳置换算法</strong>——置换出接下来最不会被访问的页。理论上的算法，我们不知道哪个页接下来最不会被访问。常常用来作评价算法，因无法实现。</p><p>2.FIFO——<strong>先进先出置换算法</strong>——最早进入的页被置换出内存：当物理内存快增加，可能置换的次数反而变多，因为先进入的页可能被淘汰但是马上又要用。</p><p>3.LRU——<strong>最久未使用置换算法</strong>——将最久未访问的页置换：LRU算法的性能是最好的，但是需要寄存器和硬件的辅助计算支持，LRU是堆栈类算法。</p><h4 id="3-虚拟内存的优缺点"><a href="#3-虚拟内存的优缺点" class="headerlink" title="3.虚拟内存的优缺点"></a>3.虚拟内存的优缺点</h4><p>优点：  </p><ul><li>1.提高了逻辑内存大小，内存的利用率</li><li>2.每个进程互不干扰，都在自己的虚拟内存空间下</li></ul><p>缺点：  </p><ul><li>1.增加一些内存开销（虚拟内存的管理）</li><li>2.增加一些CPU开销（虚拟地址到物理地址的转换、页面置的时间）</li></ul><h4 id="4-虚拟内存的特点"><a href="#4-虚拟内存的特点" class="headerlink" title="4.虚拟内存的特点"></a>4.虚拟内存的特点</h4><ul><li>多次性：数据分多次装入内存中</li><li>置换性：进程运行的同时进行数据，内存外存置换</li><li>虚拟性：提高了逻辑内存大小<h4 id="5-页面置换中的-颠簸-抖动——频繁缺页中断，置换页面——CPU开销增大"><a href="#5-页面置换中的-颠簸-抖动——频繁缺页中断，置换页面——CPU开销增大" class="headerlink" title="5.页面置换中的  颠簸 / 抖动——频繁缺页中断，置换页面——CPU开销增大"></a>5.页面置换中的  颠簸 / 抖动——频繁缺页中断，置换页面——CPU开销增大</h4></li></ul><p>定义：页面置换中，当置换出的页，接下来马上又要使用，这样会不断产生缺页中断，这种现象称为颠簸。</p><p>需要注意：虚拟内存可以提高逻辑内存，但是页面管理及置换算法不当时，会花费CPU很大的时间去交换页面，而不是执行进程命令，大大降低系统的效率。</p><h4 id="6-工作集的概念"><a href="#6-工作集的概念" class="headerlink" title="6.工作集的概念"></a>6.工作集的概念</h4><p>定义：某段时间内，进程访问页面的集合。经常被访问的页，我们将其放在工作集内，防止产生抖动现象，因此我们需要选择合适的工作集。</p><p>————单独开辟的进程常访问页的内存区域————</p><p>作用：选择正确的工作集，可以提高内存的利用率和吞吐效率，减少页面置换的花销。</p><h4 id="7-页表寻址——找寻虚拟内存地址对应的物理地址"><a href="#7-页表寻址——找寻虚拟内存地址对应的物理地址" class="headerlink" title="7.页表寻址——找寻虚拟内存地址对应的物理地址"></a>7.页表寻址——找寻虚拟内存地址对应的物理地址</h4><p>页表是计算机虚拟内存地址到物理内存地址的映射。页表中的每一项都记录着页的首地址。</p><p>首先通过页表的找寻逻辑地址对应的页的首地址，然后通过页的首地址  加上偏移量找到最后的物理地址。<br><img src="/pictures/clipboard5.png" alt="img2"></p><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="问题1-单核计算机多线程程序需要加锁吗"><a href="#问题1-单核计算机多线程程序需要加锁吗" class="headerlink" title="问题1.单核计算机多线程程序需要加锁吗"></a>问题1.单核计算机多线程程序需要加锁吗</h3><p>需要，因为程序锁的目的是为了保证线程的同步，防止读取共享数据时发生死锁等线程。单核计算机仍然存在线程同步问题，所以也需要加锁。</p><h3 id="问题2-游戏服务器应该为每个用户开辟一个线程还是一个进程，为什么？（互不影响）"><a href="#问题2-游戏服务器应该为每个用户开辟一个线程还是一个进程，为什么？（互不影响）" class="headerlink" title="问题2.游戏服务器应该为每个用户开辟一个线程还是一个进程，为什么？（互不影响）"></a>问题2.游戏服务器应该为每个用户开辟一个线程还是一个进程，为什么？（互不影响）</h3><p>开辟进程。同一进程间的线程会相互影响，一个线程死掉会影响其他线程，为了保证用户间互不影响，应该开辟进程。</p><h3 id="问题3-请你说一说互斥锁机制，以及互斥锁和读写锁的区别"><a href="#问题3-请你说一说互斥锁机制，以及互斥锁和读写锁的区别" class="headerlink" title="问题3.请你说一说互斥锁机制，以及互斥锁和读写锁的区别"></a>问题3.请你说一说互斥锁机制，以及互斥锁和读写锁的区别</h3><ul><li>互斥锁：保证单一对象只有单一线程对其进行操作。</li><li>读写锁：分为读锁和写锁。处于读操作时，允许多个线程同时获得读操作，但是同一时刻只允许一个线程获得写操作。同时写锁会阻塞其他操作</li></ul><p>不同：</p><ul><li>读写锁区分读和写，而互斥锁不区分。</li><li>互斥锁只允许一个线程访问该对象。读写锁允许多个读者，但是同一时间只允许一个写着。</li></ul><h3 id="问题4-怎样确定当前线程是繁忙还是阻塞"><a href="#问题4-怎样确定当前线程是繁忙还是阻塞" class="headerlink" title="问题4.怎样确定当前线程是繁忙还是阻塞"></a>问题4.怎样确定当前线程是繁忙还是阻塞</h3><p>linux下用ps命令查看</p><h3 id="问题5-windows消息机制知道吗，请说一说"><a href="#问题5-windows消息机制知道吗，请说一说" class="headerlink" title="问题5.windows消息机制知道吗，请说一说"></a>问题5.windows消息机制知道吗，请说一说</h3><p>消息机制是系统将用户的具体操作转化为消息，告诉给进程。有点类似进程通信中的信号。</p><h3 id="问题6-说一下僵尸进程和孤儿进程（未回收信息的子进程）"><a href="#问题6-说一下僵尸进程和孤儿进程（未回收信息的子进程）" class="headerlink" title="问题6.说一下僵尸进程和孤儿进程（未回收信息的子进程）"></a>问题6.说一下僵尸进程和孤儿进程（未回收信息的子进程）</h3><p>父进程创建子进程，子进程再创建新子进程。子进程的结束和父进程的运行是个异步过程。父进程需要调用wait（）等操作取得子进程的终止状态。</p><ul><li><p>孤儿进程：父进程结束了，子进程还在运行。孤儿进程会被进程号为1的进程收养。</p></li><li><p>僵尸进程：子进程退出时，父进程没有调用wait回收子进程的信息，那么子进程的信息仍保留在系统中，这种进程称为僵尸进程。</p></li><li><p>危害：僵尸进程是进程必须经过的过程，但是如果父进程未来得及处理退出的子进程，就会变成僵尸进程。这样的话僵尸进程保留的那段信息就不会释放，进程号一直被占用，会导致逐渐没有可用的进程号。</p></li><li><p>解决：通过kill发出指令，僵尸进程变孤儿进程，再由新的父进程接管消灭。在子进程结束的时候父进程及时wait（）取得子进程的终止状态。</p></li></ul><h3 id="问题6-请你来介绍一下5种IO模型"><a href="#问题6-请你来介绍一下5种IO模型" class="headerlink" title="问题6.请你来介绍一下5种IO模型"></a>问题6.请你来介绍一下5种IO模型</h3><ul><li>1.阻塞型IO：等待函数返回，不返回不继续，反复检索函数有没有返回</li><li>2.非阻塞型IO：每隔一段时间检查IO事件是否就绪，没有仍可以做其他事情</li><li>3.信号驱动IO：安装一个信号处理函数，进程不阻塞，收到信号处理IO事件。</li><li>4.复用IO：poll，select函数实现复用模型</li><li>5.异步IO：可以调用aio_read函数告诉内核描述字缓冲区指针和缓冲区的大小、文件偏移及通知的方式，然后立即返回，当内核将数据拷贝到缓冲区后，再通知应用程序。</li></ul><h3 id="问题7-请你说一说异步编程的事件循环"><a href="#问题7-请你说一说异步编程的事件循环" class="headerlink" title="问题7.请你说一说异步编程的事件循环"></a>问题7.请你说一说异步编程的事件循环</h3><p>事件循环就是事件是处理器一个一个依次执行的。当一个事件执行完毕，事件循环就会继续等待下一个事件的触发，不断往复。</p><p>当单个线程绑定了两个处理器，那么第二个处理器也会等待第一个处理器执行完毕后，才开始执行。</p><h3 id="问题8-请你回答一下操作系统为什么要分内核态（root）和用户态（非root）"><a href="#问题8-请你回答一下操作系统为什么要分内核态（root）和用户态（非root）" class="headerlink" title="问题8.请你回答一下操作系统为什么要分内核态（root）和用户态（非root）"></a>问题8.请你回答一下操作系统为什么要分内核态（root）和用户态（非root）</h3><p>为了系统的安全性。CPU中的一些指令用错会导致整个系统崩溃。当用户态满足使用要求时尽量使用用户态，避免发生不必要的错误。</p><h3 id="问题9-请问怎么实现线程池"><a href="#问题9-请问怎么实现线程池" class="headerlink" title="问题9.请问怎么实现线程池"></a>问题9.请问怎么实现线程池</h3><ul><li>1.设置一个生产消费者队列，作为申请线程的临时资源</li><li>2.初始化n个线程，并运行，加锁去队列中获取任务</li><li>3.无任务，线程阻塞。有任务，队列加锁，条件变量通知其中阻塞的一个线程运行</li></ul><h3 id="问题10-说一下C-源文件从文本——-gt-可执行文件-——经历的过程"><a href="#问题10-说一下C-源文件从文本——-gt-可执行文件-——经历的过程" class="headerlink" title="问题10.说一下C++源文件从文本——&gt;可执行文件 ——经历的过程"></a>问题10.说一下C++源文件从文本——&gt;可执行文件 ——经历的过程</h3><ul><li>1.预处理(产生.i文件)：将所以源文件(.cpp)和相关头文件，预处理成一个 .i文件<ol><li>将#define删除，并且宏替换</li><li>将#ifdef，#ifndef等不需要的代码删除          </li><li>将注释的代码删除</li><li>处理#include预编译指令，将包含的文件插入到该预编译指令的位置，此过程递归进行。</li><li>保留#pragma编译器指令，因为编译器需要。</li></ol></li></ul><p>#ifdef，#ifndef作用：防止头文件重复包含</p><p>#include&lt;&gt;和#include”  “区别：前者从标准库中找，后者从当前目录开始寻找。</p><ul><li><p>2.编译(产生.s文件)：（核心）<br>  将预处理后的文件，进行一系列的词法分析，语义分析以及优化后产生相应的  汇编代码文件</p></li><li><p>3.汇编(产生.o/.obj文件)：<br>  汇编实质上是把汇编语言代码  翻译成目标机器指令的过程，即生成目标文件。</p></li><li><p>4.链接(产生.out/.exe文件)：<br>  链接就是代码中用了别的库，将其和程序进行链接，然后生成可执行文件。按照它们的要求将它们组装起来，链接主要解决的是源代码之间的相互依赖问题，链接的过程包括地址和空间的分配，符号决议，和重定位等这些步骤。</p></li></ul><p><strong>总结</strong></p><ul><li>预处理（头文件解析，删除注释，宏替换等）</li><li>编译（将预处理后文件，语义分析，优化后生成汇编语言）</li><li>汇编（将汇编语言翻译成机器语言，生成目标文件）</li><li>链接（链接其他使用了的库，和目标文件结合生成可执行文件）</li></ul><h3 id="问题11-静态库-动态库的区别"><a href="#问题11-静态库-动态库的区别" class="headerlink" title="问题11.静态库 / 动态库的区别"></a>问题11.静态库 / 动态库的区别</h3><ul><li>静态库（.a/lib ）/动态库(.so/dll )的区别：</li><li>两者都由.o目标文件编译生成。可以理解为目标文件的一个集合。</li><li>静态库在链接过程中，会将静态库和目标文件（.o）一起打包到可执行文件中。删除后，程序仍可以执行。</li><li>动态库并不会打包到可执行文件中，只有在程序被执行时才会被载入，避免了浪费资源。</li></ul>]]></content>
      
      
      <categories>
          
          <category> learn </category>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>target / make a better Blog</title>
      <link href="/2020/07/11/inter1/"/>
      <url>/2020/07/11/inter1/</url>
      
        <content type="html"><![CDATA[<p>-&gt;  Make a better Blog</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C++ / 获得系统实时时间ms</title>
      <link href="/2020/07/11/time/"/>
      <url>/2020/07/11/time/</url>
      
        <content type="html"><![CDATA[<h2 id="系统时间的获取-ms"><a href="#系统时间的获取-ms" class="headerlink" title="系统时间的获取_ms"></a>系统时间的获取_ms</h2><h3 id="1-windows"><a href="#1-windows" class="headerlink" title="1.windows"></a>1.windows</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">getTime</span><span class="params">()</span></span>&#123;</span><br><span class="line">  SYSTEMTIME st;</span><br><span class="line">  GetLocalTime(&amp;st);</span><br><span class="line">  <span class="built_in">string</span> tmp = to_string(st.wYear)+<span class="string">"-"</span> + to_string(st.wMonth) + <span class="string">"-"</span> + to_string(st.wDay) + <span class="string">"-"</span> + to_string(st.wHour)+ <span class="string">"-"</span> + to_string(st.wMinute) + <span class="string">"-"</span> + to_string(st.wSecond) + <span class="string">"-"</span> + to_string(st.wMilliseconds);</span><br><span class="line">  <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-linux"><a href="#2-linux" class="headerlink" title="2.linux"></a>2.linux</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">get_time</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">string</span> time;</span><br><span class="line">  timeval tv;</span><br><span class="line">  gettimeofday(&amp;tv,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tm</span>* <span class="title">ptm</span>;</span></span><br><span class="line">  ptm = localtime (&amp;(tv.tv_sec));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">char</span> time_string[<span class="number">40</span>];</span><br><span class="line">  <span class="keyword">long</span> milliseconds;</span><br><span class="line"></span><br><span class="line">  strftime (time_string, <span class="keyword">sizeof</span>(time_string), <span class="string">"%Y-%m-%d-%H-%M-%S-"</span>,ptm);</span><br><span class="line">  milliseconds = tv.tv_usec / <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">  time= time_string+to_string(milliseconds);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> time;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> learn </category>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Blog模板</title>
      <link href="/2020/07/10/hello-world/"/>
      <url>/2020/07/10/hello-world/</url>
      
        <content type="html"><![CDATA[<h2 id="Blog模板"><a href="#Blog模板" class="headerlink" title="Blog模板"></a>Blog模板</h2><h3 id="1-标题1"><a href="#1-标题1" class="headerlink" title="1.标题1"></a>1.标题1</h3><p> <code>AAA</code></p><ul><li><blockquote><p>进程是程序的封装，是系统调度的基本单元，用于实现系统的并发性。啊实打实大大</p></blockquote></li><li><blockquote><p>啊大大进程是程序的封装，是系统调度的基本单元，用于实现系统的并发性。进程是程序的封装，是系统调度的基本单元，用于实现系统的并发性。进程是程序的封装，是系统调度的基本单元，用于实现系统的并发性。</p></blockquote></li></ul><p>**<font size=6> 为什么要四次挥手？</font> **</p><ul><li>一.<ol><li>进程是程序的封装，是系统调度的基本单元，用于实现系统的并发性。</li><li>线程则是进程的子任务，是CPU调度的基本单元，用于实现进程的并发性。<ol><li>进程</li><li>进程</li></ol></li></ol></li><li>文本1</li><li>文本2</li><li>文本3</li></ul><p><em>倾斜</em></p><p><strong>加粗</strong></p><p><strong><em>斜体加粗</em></strong></p><p><del>删除线</del></p><p>分割线</p><hr><p><img src="/pictures/clipboard14.png" alt="img1"><br><img src="/pictures/inter.jpg" alt="img1"></p><hr><table><thead><tr><th>概念</th><th>特征</th><th>网络范围</th><th>默认子网掩码</th></tr></thead><tbody><tr><td>A类地址</td><td>0XXX  XXXX</td><td>0——127.x.x.x</td><td>255.0.0.0/8</td></tr><tr><td>B类地址</td><td>0XXX  XXXX</td><td>128——191.x.x.x</td><td>255.255.0.0/16</td></tr><tr><td>C类地址</td><td>0XXX  XXXX</td><td>192——223.x.x.x</td><td>255.255.255.0/24</td></tr><tr><td>D类地址</td><td>1110    XXXX</td><td>192——223.x.x.x</td><td>用于组播</td></tr><tr><td>E类地址</td><td>1111    0XXX</td><td>192——223.x.x.x</td><td>用于科研保留</td></tr></tbody></table><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minimumTotal</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; triangle)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> lenX = triangle.<span class="built_in">size</span>();</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;res(lenX,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(lenX,<span class="number">0</span>));</span><br><span class="line">res[<span class="number">0</span>][<span class="number">0</span>] = triangle[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>超链接More info: <a href="https://tieba.baidu.com/f?kw=%B9%FA%BC%CA%C3%D7%C0%BC&fr=ala0&tpl=5" target="_blank" rel="noopener">INTER</a></p><hr><p>github+hexo教程：<br><a href="https://handsomesuperred.github.io/archives/" target="_blank" rel="noopener">https://handsomesuperred.github.io/archives/</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
